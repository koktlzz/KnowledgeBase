<!doctype html><html lang=en-us><head><script async src="https://www.googletagmanager.com/gtag/js?id=G-D022F6NT2P"></script><script>window.dataLayer=window.dataLayer||[];function gtag(){dataLayer.push(arguments)}gtag('js',new Date),gtag('config','G-D022F6NT2P')</script><script>(function(b,d,e,a,g){b[a]=b[a]||[],b[a].push({'gtm.start':(new Date).getTime(),event:'gtm.js'});var f=d.getElementsByTagName(e)[0],c=d.createElement(e),h=a!='dataLayer'?'&l='+a:'';c.async=!0,c.src='https://www.googletagmanager.com/gtm.js?id='+g+h,f.parentNode.insertBefore(c,f)})(window,document,'script','dataLayer','GTM-P72R45W')</script><meta charset=utf-8><meta http-equiv=x-ua-compatible content="ie=edge"><meta name=viewport content="width=device-width,initial-scale=1,shrink-to-fit=no"><link rel=preload as=font href=https://koktlzz.github.io/fonts/vendor/jost/jost-v4-latin-regular.woff2 type=font/woff2 crossorigin><link rel=preload as=font href=https://koktlzz.github.io/fonts/vendor/jost/jost-v4-latin-700.woff2 type=font/woff2 crossorigin><link rel=preload as=font href=https://koktlzz.github.io/fonts/KaTeX_Main-Regular.woff2 type=font/woff2 crossorigin><link rel=preload as=font href=https://koktlzz.github.io/fonts/KaTeX_Math-Italic.woff2 type=font/woff2 crossorigin><link rel=stylesheet href=https://koktlzz.github.io/main.09ec2f025fdb9f947415a273a44df08d5f3ec03e47aaa8b29ade63a14a6c9a7bc68d57acd1f4c9231d9c21a0673bb8280a543e2552346241f7c2b9c86274c6ff.css integrity="sha512-CewvAl/bn5R0FaJzpE3wjV8+wD5Hqqiymt5joUpsmnvGjVes0fTJIx2cIaBnO7goClQ+JVI0YkH3wrnIYnTG/w==" crossorigin=anonymous><noscript><style>img.lazyload{display:none}</style></noscript><meta name=robots content="index, follow"><meta name=googlebot content="index, follow, max-snippet:-1, max-image-preview:large, max-video-preview:-1"><meta name=bingbot content="index, follow, max-snippet:-1, max-image-preview:large, max-video-preview:-1"><title>TCP/IP 网络模型 | KnowledgeBase</title><meta name=description content><link rel=canonical href=https://koktlzz.github.io/infrastructure/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/tcpip%E7%BD%91%E7%BB%9C%E6%A8%A1%E5%9E%8B/><meta property="og:locale" content="en_US"><meta property="og:type" content="article"><meta property="og:title" content="TCP/IP 网络模型"><meta property="og:description" content="应用层 HTTP1.0 在 Linux 系统中输入命令 nc www.baidu.com 80，与 baidu.com 的 80 端口建立一个连接。此时再打开一个终端，输入命令 netstat -natp：
发现本地与百度已经建立起一个连接，进程号 50603。此时如果本地向和百度进行通讯，则请求必须遵循 HTTP 协议。在第一个终端中继续输入命令 GET / HTTP/1.0 并两次回车：
百度则返回给主机响应头和响应体（HTML），依然遵循应用层的 HTTP1.0 协议。
HTTP1.1 和 HTTP2.0 输入命令 curl baidu.com -v：
上述连接采用了 HTTP1.1 协议。那么它和 1.0 协议的区别是什么呢？我们使用 telnet 命令新建一个连接，如果使用 HTTP1.1 协议，即输入 GET / HTTP/1.1 后两次回车，我们可以看到 baidu.com 的响应且连接依然存在；然而如果输入的是 GET / HTTP/1.0，那么我们接收到响应后连接就中断了：
因此在 HTTP1.0 中，连接将在响应后立即关闭，这意味着必须为每个查询打开新的连接。 HTTP1.1 在同一个连接中只能有一个正在处理的请求，但是可以依次处理多个请求（当一个网页打开完成后，客户端和服务器之间用于传输 HTTP 数据的 TCP 连接不会关闭，如果客户端再次访问这个服务器上的网页，会继续使用这一条已经建立的 TCP 连接）。而 HTTP2.0 优于 HTTP1.1 的好处之一是，我们可以在同一连接上有多个处理中的请求。
其他应用层协议 而如果主机想要和其他的服务器，如 Tomcat，Redis 等，则要遵循相应的应用层协议。 例如连接 Redis 服务器，输入相关命令： 上述通讯便遵循了 Redis 的应用层协议。而主机输入的请求是怎么传输到服务端的呢？主机是如何与服务端建立连接呢？这便是内核层的工作。"><meta property="og:url" content="https://koktlzz.github.io/infrastructure/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/tcpip%E7%BD%91%E7%BB%9C%E6%A8%A1%E5%9E%8B/"><meta property="og:site_name" content="KnowledgeBase"><meta property="article:published_time" content="2021-02-24T22:05:45+08:00"><meta property="article:modified_time" content="2021-02-24T22:05:45+08:00"><meta property="og:image" content="https://koktlzz.github.io/doks.png"><meta property="og:image:alt" content="KnowledgeBase"><meta name=twitter:card content="summary_large_image"><meta name=twitter:site content="@getdoks"><meta name=twitter:creator content="@henkverlinde"><meta name=twitter:title content="TCP/IP 网络模型"><meta name=twitter:description content><meta name=twitter:image content="https://koktlzz.github.io/doks.png"><meta name=twitter:image:alt content="TCP/IP 网络模型"><script type=application/ld+json>{"@context":"https://schema.org","@graph":[{"@type":"Organization","@id":"https://koktlzz.github.io/#/schema/organization/1","name":"Doks","url":"https://koktlzz.github.io/","sameAs":["https://twitter.com/getdoks","https://github.com/h-enk/doks"],"logo":{"@type":"ImageObject","@id":"https://koktlzz.github.io/#/schema/image/1","url":"https://koktlzz.github.io/logo-doks.png","width":512,"height":512,"caption":"Doks"},"image":{"@id":"https://koktlzz.github.io/#/schema/image/1"}},{"@type":"WebSite","@id":"https://koktlzz.github.io/#/schema/website/1","url":"https://koktlzz.github.io/","name":"KnowledgeBase","description":"","publisher":{"@id":"https://koktlzz.github.io/#/schema/organization/1"}},{"@type":"WebPage","@id":"https://koktlzz.github.io/infrastructure/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/tcpip%E7%BD%91%E7%BB%9C%E6%A8%A1%E5%9E%8B/","url":"https://koktlzz.github.io/infrastructure/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/tcpip%E7%BD%91%E7%BB%9C%E6%A8%A1%E5%9E%8B/","name":"TCP\/IP 网络模型","description":"","isPartOf":{"@id":"https://koktlzz.github.io/#/schema/website/1"},"about":{"@id":"https://koktlzz.github.io/#/schema/organization/1"},"datePublished":"2021-02-24T22:05:45CET","dateModified":"2021-02-24T22:05:45CET","breadcrumb":{"@id":"https://koktlzz.github.io/infrastructure/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/tcpip%E7%BD%91%E7%BB%9C%E6%A8%A1%E5%9E%8B/#/schema/breadcrumb/1"},"primaryImageOfPage":{"@id":"https://koktlzz.github.io/infrastructure/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/tcpip%E7%BD%91%E7%BB%9C%E6%A8%A1%E5%9E%8B/#/schema/image/2"},"inLanguage":"en-US","potentialAction":[{"@type":"ReadAction","target":["https://koktlzz.github.io/infrastructure/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/tcpip%E7%BD%91%E7%BB%9C%E6%A8%A1%E5%9E%8B/"]}]},{"@type":"BreadcrumbList","@id":"https://koktlzz.github.io/infrastructure/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/tcpip%E7%BD%91%E7%BB%9C%E6%A8%A1%E5%9E%8B/#/schema/breadcrumb/1","name":"Breadcrumbs","itemListElement":[{"@type":"ListItem","position":1,"item":{"@type":"WebPage","@id":"https://koktlzz.github.io/","url":"https://koktlzz.github.io/","name":"Home"}},{"@type":"ListItem","position":2,"item":{"@type":"WebPage","@id":"https://koktlzz.github.io/infrastructure/","url":"https://koktlzz.github.io/infrastructure/","name":"Infrastructure"}},{"@type":"ListItem","position":3,"item":{"@type":"WebPage","@id":"https://koktlzz.github.io/infrastructure/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/","url":"https://koktlzz.github.io/infrastructure/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/","name":"% E8% Ae% A1% E7% Ae%97% E6%9 C% Ba% E7% Bd%91% E7% Bb%9 C"}},{"@type":"ListItem","position":4,"item":{"@id":"https://koktlzz.github.io/infrastructure/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/tcpip%E7%BD%91%E7%BB%9C%E6%A8%A1%E5%9E%8B/"}}]},{"@context":"https://schema.org","@graph":[{"@type":"ImageObject","@id":"https://koktlzz.github.io/infrastructure/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/tcpip%E7%BD%91%E7%BB%9C%E6%A8%A1%E5%9E%8B/#/schema/image/2","url":"https://koktlzz.github.io/doks.png","contentUrl":"https://koktlzz.github.io/doks.png","caption":"TCP\/IP 网络模型"}]}]}</script><meta name=theme-color content="#fff"><link rel=apple-touch-icon sizes=180x180 href=https://koktlzz.github.io/apple-touch-icon.png><link rel=icon type=image/png sizes=32x32 href=https://koktlzz.github.io/favicon-32x32.ico><link rel=icon type=image/png sizes=16x16 href=https://koktlzz.github.io/favicon-16x16.ico><link rel=manifest crossorigin=use-credentials href=https://koktlzz.github.io/site.webmanifest></head><body class="Infrastructure single dark"><noscript><iframe src="https://www.googletagmanager.com/ns.html?id=GTM-P72R45W" height=0 width=0 style=display:none;visibility:hidden></iframe></noscript><div class="header-bar fixed-top"></div><header class="navbar fixed-top navbar-expand-md navbar-light"><div class=container-fluid><input class="menu-btn order-0" type=checkbox id=menu-btn>
<label class="menu-icon d-md-none" for=menu-btn><span class=navicon></span></label><a class="navbar-brand order-1 order-md-0 me-auto" href=https://koktlzz.github.io/>KnowledgeBase</a>
<button id=mode class="btn btn-link order-2 order-md-4" type=button aria-label="Toggle mode">
<span class=toggle-dark><svg xmlns="http://www.w3.org/2000/svg" width="20" height="20" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="feather feather-moon"><path d="M21 12.79A9 9 0 1111.21 3 7 7 0 0021 12.79z"/></svg></span><span class=toggle-light><svg xmlns="http://www.w3.org/2000/svg" width="20" height="20" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="feather feather-sun"><circle cx="12" cy="12" r="5"/><line x1="12" y1="1" x2="12" y2="3"/><line x1="12" y1="21" x2="12" y2="23"/><line x1="4.22" y1="4.22" x2="5.64" y2="5.64"/><line x1="18.36" y1="18.36" x2="19.78" y2="19.78"/><line x1="1" y1="12" x2="3" y2="12"/><line x1="21" y1="12" x2="23" y2="12"/><line x1="4.22" y1="19.78" x2="5.64" y2="18.36"/><line x1="18.36" y1="5.64" x2="19.78" y2="4.22"/></svg></span></button><ul class="navbar-nav social-nav order-3 order-md-5"><li class=nav-item><a class=nav-link href=https://github.com/koktlzz><svg xmlns="http://www.w3.org/2000/svg" width="20" height="20" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="feather feather-github"><path d="M9 19c-5 1.5-5-2.5-7-3m14 6v-3.87a3.37 3.37.0 00-.94-2.61c3.14-.35 6.44-1.54 6.44-7A5.44 5.44.0 0020 4.77 5.07 5.07.0 0019.91 1S18.73.65 16 2.48a13.38 13.38.0 00-7 0C6.27.65 5.09 1 5.09 1A5.07 5.07.0 005 4.77 5.44 5.44.0 003.5 8.55c0 5.42 3.3 6.61 6.44 7A3.37 3.37.0 009 18.13V22"/></svg><span class="ms-2 visually-hidden">GitHub</span></a></li></ul><div class="collapse navbar-collapse order-4 order-md-1"><ul class="navbar-nav main-nav me-auto order-5 order-md-2"><li class=nav-item><a class=nav-link href=https://koktlzz.github.io/container/docker/intro>Container</a></li><li class=nav-item><a class=nav-link href=https://koktlzz.github.io/observability/elasticstack/intro>Observability</a></li><li class=nav-item><a class=nav-link href=https://koktlzz.github.io/programming/go/intro>Programming</a></li><li class=nav-item><a class=nav-link href=https://koktlzz.github.io/infrastructure/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/tcpip%E7%BD%91%E7%BB%9C%E6%A8%A1%E5%9E%8B>Infrastructure</a></li></ul><div class="break order-6 d-md-none"></div></div></div></header><div class="wrap container-fluid" role=document><div class=content><div class="row flex-xl-nowrap"><div class="col-lg-4 col-xl-3 d-none d-xl-block"><nav class=docs-links aria-label="Main navigation"><h3>计算机网络</h3><ul class=list-unstyled><li><a class=docs-link href=https://koktlzz.github.io/infrastructure/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/tcpip%E7%BD%91%E7%BB%9C%E6%A8%A1%E5%9E%8B/>TCP/IP 网络模型</a></li><li><a class=docs-link href=https://koktlzz.github.io/infrastructure/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/dnshttps/>DNS、UDP 与 HTTPS</a></li><li><a class=docs-link href=https://koktlzz.github.io/infrastructure/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/%E8%99%9A%E6%8B%9F%E6%9C%BA%E7%BD%91%E7%BB%9C/>虚拟机网络</a></li><li><a class=docs-link href=https://koktlzz.github.io/infrastructure/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/vlan/>VLAN</a></li></ul><h3>CSAPP</h3><ul class=list-unstyled><li><a class=docs-link href=https://koktlzz.github.io/infrastructure/csapp/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9F%E4%B9%8B%E6%97%85/>计算机系统之旅</a></li><li><a class=docs-link href=https://koktlzz.github.io/infrastructure/csapp/%E4%BF%A1%E6%81%AF%E7%9A%84%E8%A1%A8%E7%A4%BA%E5%92%8C%E5%A4%84%E7%90%86/>信息的表示和处理</a></li><li><a class=docs-link href=https://koktlzz.github.io/infrastructure/csapp/%E7%A8%8B%E5%BA%8F%E7%9A%84%E6%9C%BA%E5%99%A8%E7%BA%A7%E8%A1%A8%E7%A4%BA/>程序的机器级表示</a></li></ul><h3>Linux</h3><ul class=list-unstyled><li><a class=docs-link href=https://koktlzz.github.io/infrastructure/linux/filepermission/>文件权限</a></li></ul></nav></div><main class="docs-content col-lg-12 col-xl-10"><h1>TCP/IP 网络模型</h1><p class=lead></p><p><img src=https://cdn.jsdelivr.net/gh/koktlzz/ImgBed@master/layer.PNG alt=layer></p><h2 id=应用层>应用层<a href=#应用层 class=anchor aria-hidden=true>#</a></h2><h3 id=http10>HTTP1.0<a href=#http10 class=anchor aria-hidden=true>#</a></h3><p>在 Linux 系统中输入命令 <strong>nc www.baidu.com 80</strong>，与 baidu.com 的 80 端口建立一个连接。此时再打开一个终端，输入命令 <strong>netstat -natp</strong>：</p><p><img src=https://cdn.jsdelivr.net/gh/koktlzz/NoteImg@main/20201223170157.png alt=20201223170157></p><p>发现本地与百度已经建立起一个连接，进程号 50603。此时如果本地向和百度进行通讯，则请求必须遵循 HTTP 协议。在第一个终端中继续输入命令 <strong>GET / HTTP/1.0</strong> 并两次回车：</p><p><img src=https://cdn.jsdelivr.net/gh/koktlzz/NoteImg@main/20201223165806.png alt=20201223165806></p><p>百度则返回给主机响应头和响应体（HTML），依然遵循应用层的 HTTP1.0 协议。</p><h3 id=http11-和-http20>HTTP1.1 和 HTTP2.0<a href=#http11-和-http20 class=anchor aria-hidden=true>#</a></h3><p>输入命令 <strong>curl baidu.com -v</strong>：</p><p><img src=https://cdn.jsdelivr.net/gh/koktlzz/NoteImg@main/20201223153643.png alt=20201223153643></p><p>上述连接采用了 HTTP1.1 协议。那么它和 1.0 协议的区别是什么呢？我们使用 <strong>telnet</strong> 命令新建一个连接，如果使用 HTTP1.1 协议，即输入 <strong>GET / HTTP/1.1</strong> 后两次回车，我们可以看到 baidu.com 的响应且连接依然存在；然而如果输入的是 <strong>GET / HTTP/1.0</strong>，那么我们接收到响应后连接就中断了：</p><p><img src=https://cdn.jsdelivr.net/gh/koktlzz/NoteImg@main/20201223160159.png alt=20201223160159></p><p><img src=https://cdn.jsdelivr.net/gh/koktlzz/NoteImg@main/20201223160034.png alt=20201223160034></p><p>因此在 HTTP1.0 中，连接将在响应后立即关闭，这意味着必须为每个查询打开新的连接。 HTTP1.1 在同一个连接中只能有一个正在处理的请求，但是可以依次处理多个请求（当一个网页打开完成后，客户端和服务器之间用于传输 HTTP 数据的 TCP 连接不会关闭，如果客户端再次访问这个服务器上的网页，会继续使用这一条已经建立的 TCP 连接）。而 HTTP2.0 优于 HTTP1.1 的好处之一是，我们可以在同一连接上有多个处理中的请求。</p><h3 id=其他应用层协议>其他应用层协议<a href=#其他应用层协议 class=anchor aria-hidden=true>#</a></h3><p>而如果主机想要和其他的服务器，如 Tomcat，Redis 等，则要遵循相应的应用层协议。
例如连接 Redis 服务器，输入相关命令：
<img src=https://cdn.jsdelivr.net/gh/koktlzz/NoteImg@main/20201223163117.png alt=20201223163117></p><p>上述通讯便遵循了 Redis 的应用层协议。而主机输入的请求是怎么传输到服务端的呢？主机是如何与服务端建立连接呢？这便是内核层的工作。</p><h2 id=传输控制层>传输控制层<a href=#传输控制层 class=anchor aria-hidden=true>#</a></h2><p>应用层与传输控制层之间通过套接字（Socket）传递数据，套接字是传输控制层与应用层的一个中间媒介，位于两层之间。</p><p><img src=https://cdn.jsdelivr.net/gh/koktlzz/ImgBed@master/tcp.PNG alt=tcp></p><ul><li>SYN:Synchronous 建立连接</li><li>ACK:Acknowledge 确认</li><li>FIN:Finish 结束连接</li></ul><p>使用抓包工具 <strong>tcpdump</strong>：</p><div class=highlight><pre style=color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-bash data-lang=bash><span style=color:#6272a4># -nn : 数字的方式显示 IP 和端口，一个 n 是 ip</span>
<span style=color:#6272a4># -i : 网卡</span>
<span style=color:#6272a4># port : 端口号</span>
tcpdump -nn -i eth0 port <span style=color:#bd93f9>80</span>  
</code></pre></div><p>当 tcpdump 开始监听 eth0 后，使用 <strong>curl</strong> 命令连接到百度服务器：</p><p><img src=https://cdn.jsdelivr.net/gh/koktlzz/NoteImg@main/20201210102906.png alt=20201210102906></p><p>命令行参数说明：</p><ul><li>192.168.150.11 : 本机 ip 地址</li><li>220.181.38.149 : 服务端 ip 地址</li><li>[S] : SYN</li><li>[P] : PUSH（发送方通知接收方传输层应该尽快的将这个报文段交给应用层）</li><li>[.] : ACK</li><li>[F] : FIN</li><li>length 168 : 客户端发出的请求头</li><li>length 1460/1321 : 服务端发出的响应头和响应体，分两个包传输。</li><li>win : 大小表示内核中可用的 TCP 缓冲区长度，可用来缓冲接收到的数据包。大小为 0 意味着接收端有很多滞后要从其套接字缓冲区中捕获，发送端必须暂停发送数据包，以便接收端能够应付。这种流量控制防止了接收端慢和发送端快的问题。</li></ul><h2 id=网络层>网络层<a href=#网络层 class=anchor aria-hidden=true>#</a></h2><h3 id=ip>IP<a href=#ip class=anchor aria-hidden=true>#</a></h3><p>IPv4 点分字节：四个字节，一个字节 8 个二进制位（0~255），如 192.168.150.1。</p><p>查看<code>/etc/sysconfig/network-scripts/ifcfg-eth0</code>路径下的网卡配置文件信息：</p><p><img src=https://cdn.jsdelivr.net/gh/koktlzz/NoteImg@main/20201210132006.png alt=20201210132006></p><ul><li>#HWADDR : 物理地址（MAC 地址）</li><li>IPADDR : 主机 IP 地址</li><li>NETMASK : 子网掩码</li><li>GATEWAY : 网关</li><li>DNS : DNS 服务器（将域名转换为 IP 地址）</li><li>网络号（网段）</li></ul><p>通过 ip 地址与子网掩码进行<strong>二进制按位与</strong>运算得到，例如：
主机 ip：192.168.150.11
子网掩码：255.255.255.0
则该局域网网段为 192.168.150.0，该主机的主机号为 11。在此局域网下的其他主机 ip 可能为 192.168.150.1, 192.168.150.2, 192.168.150.3……等。</p><h3 id=route路由表>Route（路由表）<a href=#route路由表 class=anchor aria-hidden=true>#</a></h3><p>使用命令 <strong>route -n</strong>：</p><p>得到本机路由表信息如下：</p><p><img src=https://cdn.jsdelivr.net/gh/koktlzz/NoteImg@main/1607578833(1).png alt=1607578833(1)></p><ul><li>Destination : 可以连接的网络地址</li><li>Gateway : 网关</li><li>Genmask : 掩码</li><li>Iface : 网络连接走的接口为 eth0</li></ul><p>路由表的每一行代表一个路由规则：将服务端 ip 与掩码进行二进制按位与运算。如果计算得到的地址存在于本机路由表中的 Destination 中，则传输控制层可以向该服务端发送数据包，从而建立连接。
例如：服务端为同一局域网的另一台主机，ip 地址 192.168.150.n。那么它与掩码 255.255.255.0 二进制按位与运算后的结果为 192.168.150.0，即路由表中第一行的 Destination。第一行的网关为 0.0.0.0，代表不需要通过网关，可以直接通过 eth0 发送数据包；
如果服务端为 baidu，ip 地址 220.181.38.149。那么它与掩码 0.0.0.0 进行计算后的结果为 0.0.0.0，即路由表中第三行的 Destination。第三行的网关为 192.168.150.2，因此需要将数据包发送到此网关。当网关完成“下一跳”后，数据包才会到达服务端。</p><p><strong>思考一个问题</strong>: 上述第二个例子中，如果传输控制层发出的数据包上只写一个 ip 地址，那么应该写 192.168.150.2 还是 220.181.38.149 呢？</p><ul><li>如果写 192.168.150.2，网关可以接收到数据包，但是它却不知道这个数据包后续应该交给谁；</li><li>如果写 220.181.38.149，网络层就不知道该把这个数据包交给哪个网关了，因此需要链路层为我们完成这项任务。</li></ul><h2 id=链路层>链路层<a href=#链路层 class=anchor aria-hidden=true>#</a></h2><p>使用命令 <strong>arp -n</strong>，查看本机的 arp 协议，即 ip 地址与网卡物理地址之间的映射关系：</p><p><img src=https://cdn.jsdelivr.net/gh/koktlzz/NoteImg@main/20201210142721.png alt=20201210142721></p><p>而当我们使用命令 <strong>ping www.baidu.com</strong>，建立一个连接后，再次查看 arp 协议，会发现增加了一对映射关系：</p><p><img src=https://cdn.jsdelivr.net/gh/koktlzz/NoteImg@main/20201210142319.png alt=20201210142319></p><p>同一网段的主机可以通过 arp 广播获取目的主机 MAC 地址后完成通信，但经计算发现 baidu.com 的 IP 地址与自身处于不同网段后，主机便只能通过 arp 协议发送广播请求网关的 MAC 地址。我们再次使用 <strong>tcpdump -nn -i eth0 port 80 or arp</strong> 命令进行抓包，这次还包括了 arp 广播发出的数据包：</p><p><img src=https://cdn.jsdelivr.net/gh/koktlzz/NoteImg@main/20201210145003.png alt=20201210145003></p><p>可以发现在 TCP 发出握手请求之前，arp 就会发起广播请求<code>who-has 192.168.150.2 tell 192.168.150.11</code>，此处的 192.168.150.2 便是网关的 ip 地址，192.168.150.11 则是主机的 ip 地址。当得到回复<code>Reply 192.168.150.2 is-at 00:50:56:f7:53:2b</code>后，链路层便得到了指定网关的物理地址。</p><p>如果把数据包比作一个三层包装的邮政包裹，为了能够准确地将它送往服务端，<strong>链路层</strong>给它的最外层写上了网关 192.168.150.2 的 MAC 地址 00:50:56:f7:53:2b，<strong>网络层</strong>给中间层写上了服务端的 IP 地址 220.181.38.149，<strong>传输控制层</strong>则在最内层写上了服务端监听的端口号 PORT:80。</p><p><img src=https://cdn.jsdelivr.net/gh/koktlzz/NoteImg@main/%E6%9C%AA%E5%91%BD%E5%90%8D%E6%96%87%E4%BB%B6%E3%80%82jpg alt=未命名文件></p><p>在每一跳中遵循类似的路由查找过程，直到数据包到达目标服务器。数据包的传输过程中，ip 地址和端口号始终不变。类似于数据结构中的链表，MAC 地址永远指向下一个目标。</p><p class=edit-page><a href=https://github.com/koktlzz/koktlzz.github.io/blob/master/content/Infrastructure/%e8%ae%a1%e7%ae%97%e6%9c%ba%e7%bd%91%e7%bb%9c/TCPIP%e7%bd%91%e7%bb%9c%e6%a8%a1%e5%9e%8b.md><svg xmlns="http://www.w3.org/2000/svg" width="16" height="16" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="feather feather-edit-2"><path d="M17 3a2.828 2.828.0 114 4L7.5 20.5 2 22l1.5-5.5L17 3z"/></svg>Edit this page on GitHub</a></p><div class="docs-navigation d-flex justify-content-between"><a class=ms-auto href=https://koktlzz.github.io/infrastructure/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/dnshttps/><div class="card my-1"><div class="card-body py-2">DNS、UDP 与 HTTPS &rarr;</div></div></a></div><script src=https://utteranc.es/client.js repo=koktlzz/koktlzz.github.io issue-term=pathname theme=photon-dark crossorigin=anonymous async></script></main><nav class="docs-toc d-none d-xl-block col-lg-3 col-xl-2" aria-label="Secondary navigation"><div class=page-links><h3>On this page</h3><nav id=TableOfContents><ul><li><a href=#应用层>应用层</a><ul><li><a href=#http10>HTTP1.0</a></li><li><a href=#http11-和-http20>HTTP1.1 和 HTTP2.0</a></li><li><a href=#其他应用层协议>其他应用层协议</a></li></ul></li><li><a href=#传输控制层>传输控制层</a></li><li><a href=#网络层>网络层</a><ul><li><a href=#ip>IP</a></li><li><a href=#route路由表>Route（路由表）</a></li></ul></li><li><a href=#链路层>链路层</a></li></ul></nav></div></nav></div></div></div><script src=https://koktlzz.github.io/js/bootstrap.min.d67050adf5d370668aede4201f82af781b16970934804995a1ca37c1ee9222c2fc530972aa6d5d2b6124caf1fe318f139aac99df2c1e89af65504fc1185c7972.js integrity="sha512-1nBQrfXTcGaK7eQgH4KveBsWlwk0gEmVoco3we6SIsL8Uwlyqm1dK2EkyvH+MY8TmqyZ3yweia9lUE/BGFx5cg==" crossorigin=anonymous defer></script><script src=https://koktlzz.github.io/js/vendor/katex/dist/katex.min.b334e5b00c45f572e7f38a543046f36854bf4cbb543880480c09271a0efedc694d6905f719934f6ede2f26f52e80411c05b90121d722cbf8be2fa8fc51bc6b81.js integrity="sha512-szTlsAxF9XLn84pUMEbzaFS/TLtUOIBIDAknGg7+3GlNaQX3GZNPbt4vJvUugEEcBbkBIdciy/i+L6j8UbxrgQ==" crossorigin=anonymous defer></script><script src=https://koktlzz.github.io/js/vendor/katex/dist/contrib/auto-render.min.916823ec103cf367b71e28a6f01513cb9c3ac6708ccb5229402ec46b8e30a8b25003db694df35d80e9dd666a371f327c6152790617b6256390c164109a90bd4c.js integrity="sha512-kWgj7BA882e3Hiim8BUTy5w6xnCMy1IpQC7Ea44wqLJQA9tpTfNdgOndZmo3HzJ8YVJ5Bhe2JWOQwWQQmpC9TA==" crossorigin=anonymous defer></script><script src=https://koktlzz.github.io/main.min.1febbf2f6fd6a36fc2f57dd50d7935fbb640743329baeb4ef7cefcf2e7630e413371fbba976e103656b82808ee227dc4a84237edb0f8433648bef3a56900661a.js integrity="sha512-H+u/L2/Wo2/C9X3VDXk1+7ZAdDMpuutO98788udjDkEzcfu6l24QNla4KAjuIn3EqEI37bD4QzZIvvOlaQBmGg==" crossorigin=anonymous defer></script></body></html>