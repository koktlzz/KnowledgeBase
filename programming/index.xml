<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>Programmings on</title><link>https://koktlzz.github.io/programming/</link><description>Recent content in Programmings on</description><generator>Hugo -- gohugo.io</generator><language>en-US</language><lastBuildDate>Wed, 04 Nov 2020 09:19:42 +0100</lastBuildDate><atom:link href="https://koktlzz.github.io/programming/index.xml" rel="self" type="application/rss+xml"/><item><title>Getting Started</title><link>https://koktlzz.github.io/programming/go/intro/</link><pubDate>Wed, 04 Nov 2020 09:19:42 +0100</pubDate><guid>https://koktlzz.github.io/programming/go/intro/</guid><description>官方网站 https://golang.org/
推荐阅读 Go 语言标准库文档中文版
Go 语言之旅
实效 Go 编程
Go by Example
Go 语言设计与实现</description></item><item><title>Request &amp; Response</title><link>https://koktlzz.github.io/programming/go/requestresponse/</link><pubDate>Wed, 04 Nov 2020 09:19:42 +0100</pubDate><guid>https://koktlzz.github.io/programming/go/requestresponse/</guid><description>http.Request 结构 请求行（请求方法/URL/协议） 0 个或多个 Header 空行 可选的消息体 (Body) 例如：
GET www.baidu.com HTTP/1.1 Host: www.w3.org User-Agent: Mozilla/5.0 （空行） （无消息体） 读取查询参数 常见的 URL 的结构为：
scheme://[userinfo@]host/path[?query][#fragment] 使用 Request.URL 的 Query 方法即可得到 URL 中的查询参数：
fmt.Println(r.URL.Query()) 若请求的 URL 为：http://localhost:8080?name=kokt&amp;amp;age=3 , 则控制台输出：
map[age:[3] name:[kokt]] 读取请求头 type Header map[string][]string 可以使用 Request.Header[key] 或 Request.Header.Get(key) 获取请求头中的值。前者返回值类型是 []string，后者返回值类型为 string（不同值以逗号分隔）。
读取消息体 func obtainBody(w http.ResponseWriter, r *http.Request) { length := r.ContentLength body := make([]byte, length) // r.Body 是一个 io.ReadCloser 类型 r.</description></item><item><title>搭建 Web 服务器</title><link>https://koktlzz.github.io/programming/go/%E6%90%AD%E5%BB%BAweb%E6%9C%8D%E5%8A%A1%E5%99%A8/</link><pubDate>Wed, 04 Nov 2020 09:19:42 +0100</pubDate><guid>https://koktlzz.github.io/programming/go/%E6%90%AD%E5%BB%BAweb%E6%9C%8D%E5%8A%A1%E5%99%A8/</guid><description>搭建一个简单的 web 服务 package main import ( &amp;#34;fmt&amp;#34; &amp;#34;net/http&amp;#34; &amp;#34;strings&amp;#34; &amp;#34;log&amp;#34; ) func sayhelloName(w http.ResponseWriter, r *http.Request) { r.ParseForm() // 解析参数，默认是不会解析的 fmt.Println(r.Form) // 这些信息是输出到服务器端的打印信息 fmt.Println(&amp;#34;path&amp;#34;, r.URL.Path) fmt.Println(&amp;#34;scheme&amp;#34;, r.URL.Scheme) fmt.Println(r.Form[&amp;#34;num&amp;#34;]) for k, v := range r.Form { fmt.Println(&amp;#34;key:&amp;#34;, k) fmt.Println(&amp;#34;val:&amp;#34;, strings.Join(v, &amp;#34;&amp;#34;)) } fmt.Fprintf(w, &amp;#34;Hello World&amp;#34;) // 这个写入到 w 的是输出到客户端的 } func main() { http.HandleFunc(&amp;#34;/&amp;#34;, sayhelloName) // 注册了请求/的路由规则，当请求 uri 为&amp;#34;/&amp;#34;，路由就会转到函数 sayhelloName err := http.ListenAndServe(&amp;#34;:9090&amp;#34;, nil) // 设置监听的端口 if err !</description></item><item><title>使用 MySQL 数据库</title><link>https://koktlzz.github.io/programming/go/%E4%BD%BF%E7%94%A8mysql%E6%95%B0%E6%8D%AE%E5%BA%93/</link><pubDate>Wed, 04 Nov 2020 09:19:42 +0100</pubDate><guid>https://koktlzz.github.io/programming/go/%E4%BD%BF%E7%94%A8mysql%E6%95%B0%E6%8D%AE%E5%BA%93/</guid><description>连接数据库 package main import ( &amp;#34;context&amp;#34; &amp;#34;database/sql&amp;#34; &amp;#34;fmt&amp;#34; &amp;#34;log&amp;#34; _ &amp;#34;github.com/mikespook/mymysql&amp;#34; ) func main() { var db *sql.DB // 第二个参数的格式为：user:password@tcp(ip: port)/dbname db, _ = sql.Open(&amp;#34;mysql&amp;#34;, &amp;#34;******&amp;#34;) err := db.Ping() if err != nil { log.Fatalln(err.Error()) } fmt.Println(&amp;#34;CONNECTION SUCCESSFUL&amp;#34;) } 数据库驱动 想要连接到 SQL 数据库，那么首先需要加载目标数据库的驱动，驱动中包含了与数据库交互的逻辑。正常获取数据库驱动的方法是调用 sql.Register() 函数进行注册：
var ( driversMu sync.RWMutex // 使用一个 map 来储存用户定义的数据库驱动 drivers = make(map[string]driver.Driver) ) func Register(name string, driver driver.Driver) { driversMu.Lock() defer driversMu.Unlock() if driver == nil { panic(&amp;#34;sql: Register driver is nil&amp;#34;) } if _, dup := drivers[name]; dup { panic(&amp;#34;sql: Register called twice for driver &amp;#34; + name) } // 将用户定义的数据库驱动添加到 map 中 drivers[name] = driver } 它的第一个参数是数据库驱动的名称，在本例中为 mysql。第二个参数是一个结构体，类型为 driver.</description></item></channel></rss>