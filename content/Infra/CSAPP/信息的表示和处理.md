---
title: "信息的表示和处理"
description: ""
date: 2021-02-24T22:05:45+08:00
lastmod: 2021-02-24T22:05:45+08:00
draft: false
images: []
menu:
  infra:
    parent: "CSAPP"
weight: 600
---

## 信息的存储

大多数机器使用字节（8 位的块）作为存储器中的最小寻址单元，而非访问单独的位。内存中的每一个字节都对应一个唯一的数字，即它的地址，所有可能的地址集合构成了 [虚拟内存](/infra/csapp/计算机系统之旅/#虚拟内存）。它是由 DRAM、闪存（flash memory) 和磁盘存储共同实现的，而在程序看来则只是一个统一的字节数组。

编译器和运行时系统负责将这个内存空间划分为更加可管理的单元，来存储不同的程序对象。例如，C 中指针的值代表存储块中第一个字节的虚拟地址。C 编译器还将每个指针与其类型信息联系起来，这样就可以根据指针值的类型生成不同的机器级代码来访问指针所指向的值。不过机器级代码中并没有任何有关类型的信息，而是简单的把每个程序对象都视为一个字节块。

### 十六进制表示法

使用二进制表示位模式（bit pattern）会非常冗长，因为一个字节就包含了 8 位。而如果使用十进制，则不方便与位模式进行互相转化，因此我们采用十六进制（Hexadecimal）来书写位模式。一个十六进制数占 4 位，因此一个字节的取值范围就是 $00_{16}$ ~ $FF_{16}$ 。

将一个二进制数字转化为十六进制数字，需要首先将其分为多个 4 位的组，然后再将每组数转化为十六进制。如果总位数不为 4 的倍数，那么最左边的一组可以少于四位，然后在首位补 0。如 $111100_2$ 可以分成 $0011_2$ 和 $1100_2$，转化结果为 $3C_{16}$ 。在 C 中，若一个常数以 0x 或 0X 作为前缀，则代表它是一个十六进制数字。

### 数据大小

每台计算机都有一个字长（word size），它指定了指针数据的标准大小。如果一台机器的字长为 $w$ 位，那么虚拟地址的范围为 $ 0～2^w -1 $，程序最多访问 $2^w$ 字节。32 位机器的虚拟地址大小约为 4GB，而 64 位机器则能达到 16EB。

C 中几个基本数据类型的大小如下表所示：

| Signed        | Unsigned       | 32-bit | 64-bit |
| ------------- | -------------- | ------ | ------ |
| \[signed\] char | unsigned char  | 1      | 1      |
| short         | unsigned short | 2      | 2      |
| int           | unsigned       | 4      | 4      |
| long          | unsigned long  | 4      | 8      |
| int32_t       | uint_32t       | 4      | 4      |
| int64_t       | uint_64t       | 8      | 8      |
| char *        |                | 4      | 8      |
| float         |                | 4      | 4      |
| double        |                | 8      | 8      |

除 char 外，若不添加前缀 unsigned，则默认使用有符号类型。指针类型的数据使用机器的全字长，如 char *。由于某些数据类型的大小在不同机器上有所不同，因此开发人员应使程序对不同数据类型的确切大小不敏感，从而保证程序的可移植性（portable）。

### 寻址和字节顺序

对于多字节的程序对象，我们必须建立两个准则：这个对象的地址是什么和这些字节在内存中的排列顺序是怎样的。某些机器选择按照从最低有效字节到最高有效字节的顺序存储对象，称为小端法（little endian）；而某些则与之相反，称为大端法（big endian）。如一个 int 类型的变量 x 地址为 0x100，其值为十六进制的 0x1234567，那么上述两种机器存储该变量的方式分别如下：

little endian

|      | 0x100 | 0x101 | 0x102 | 0x103 |      |
| :--: | :---: | :---: | :---: | :---: | :--: |
| ...  |  67   |  45   |  23   |  01   | ...  |

big endian

|      | 0x100 | 0x101 | 0x102 | 0x103 |      |
| :--: | :---: | :---: | :---: | :---: | :--: |
| ...  |  01   |  23   |  45   |  67   | ...  |

有些时候不同的存储顺序可能导致一些问题：

- 不同类型的机器通过网络传递二进制数据，如小端法机器产生的数据发送到大端机器上，得到的字节序列是反的。这就要求发送方的机器需要将代码转换为网络标准，接收方再将其转化为其内部的表达方式；
- 对于小端法机器，书写字节序列与书写数字的顺序相反；
- 某些使用强制类型转换（cast）的程序，在不同类型的机器上编译运行的结果不同。

对于上述第三种情况，我们以一个程序为例：

```c
#include <stdio.h>

typedef unsigned char *byte_pointer;

void show_bytes(byte_pointer start, size_t len)
{
    size_t i;
    for (i = 0; i < len; i++)
    {
        // %.2x 代表整数会被打印为至少两位（digits）的十六进制数字
        printf("%.2x", start[i]);
    }
    printf("\n");
}

void show_int(int x)
{
    show_bytes((byte_pointer)&x, sizeof(int));
}

void show_float(float x)
{
    show_bytes((byte_pointer)&x, sizeof(float));
}

void show_pointer(void *x)
{
    show_bytes((byte_pointer)&x, sizeof(void *));
}

int main()
{
    int val = 12345;
    float fval = (float) val;
    int *pval = &val;
    show_int(val);
    show_float(fval);
    show_pointer(pval);
}
```

不同类型机器的输出结果如下：

| Machine   | val        | fval       | pval               |
| --------- | ---------- | ---------- | ------------------ |
| Linux32   | 0x39300000 | 0x00e44046 | 0xe4f9ffbf         |
| Windows32 | 0x39300000 | 0x00e44046 | 0xb4cc2200         |
| Sun       | 0x00003039 | 0x4640e400 | 0xeffffa0c         |
| Linux64   | 0x39300000 | 0x00e44046 | 0xb811e5ffff7f0000 |

这是因为 Sun 系统采用大端法，其他三者采用小端法。对于指针类型的变量，不同操作系统在存储分配上有着不同的准则。同时，64 位系统使用 8 字节地址，32 位系统使用 4 字节地址，这导致了指针类型的变量 pval 输出结果的不同。

### 字符串

字符串在 C 中被编码为一个以 null 字符结尾（其值为 0）的字符数组，每个字符都由某种标准编码组成，如 ASCII 码。因此，如果我们执行上面的程序`show_bytes("12345", 6)`，将得到 31 32 33 34 35 00。

由于字符串中各字符的排列顺序是由字符串本身决定的，因此字符串不会受到大端法/小端法的影响，除非字符使用 16 位两字节的 Unicode 进行编码。

### 代码

不同类型的机器使用不同且不兼容的指令和编码方式，因此二进制代码很少能在不同机器和操作系统组合之间移植。

### 布尔代数简介

几种布尔运算符的定义如下：

- ～：非，相当于逻辑运算的 NOT；
- &：与，相当于逻辑运算的 AND；
- ｜：或，相当于逻辑运算的 OR；
- ^：异或，相当于逻辑运算的 EXCLUSIVE-OR。若 $p = 0$，$q = 1$ 或 $p = 1$，$q = 0$ 时，$p \text{\textasciicircum} q = 1$。

布尔运算符可以应用于位向量，即固定长度的 0、1 序列。举例来说，若 a 为 [0110]，b 为 [0101]，那么：

| Operation | Result |
| --------- | ------ |
| ~a        | [1001] |
| a & b     | [0100] |
| a \| b    | [0111] |
| a ^ b     | [0011] |

### C 中的位级运算

C 中支持按位布尔运算，上面提到的布尔运算符其实就是在 C 中使用的。一个使用布尔运算符的经典程序如下：

```c
#include <stdio.h>

void inplace_swap(int *x, int *y)
{
    *y = *x ^ *y;
    *x = *x ^ *y;
    *y = *x ^ *y;
}
```

利用对于任意数 $a$ ，$a \text{\textasciicircum} a$ = 0 以及 $0 \text{\textasciicircum} a = a$ 这一性质，该程序不使用中间变量便完成了变量值的交换。另外，上述方法的实现还建立在异或运算满足交换律和结合律的基础之上。

### C 中的逻辑运算

C 还提供了逻辑运算符，即 || 、&& 和 !。它们和位级运算的一个区别就是，如果对第一个参数求值就能确定表达式的结果，那么就不会对第二个参数进行求值。如表达式 a && 5 / a 不会导致除数为 0 的异常，而 p && *p++ 也不会导致简介引用空指针。

### C 中的移位运算

C 中的移位运算有左移和右移两种，均不会改变位向量的长度。左移运算 $x << k$ 就是 x 向左移动 k 位，丢弃 k 个高位，并在右端补充 k 个 0。通常可以使用 $x << 1$ 和 $x << 2$ 分别代替 $x \* 2$ 和 $x \* 4$，因为位级运算拥有相比乘法更快的运算速度。

右移运算分为两种形式，逻辑和算术。无符号数据必须使用逻辑右移，$x >> k$ 将 x 的左端补充 k 个 0 ，并丢弃 k 个低位。而大多数机器使用算术右移处理有符号数据，$x >> k$ 将 x 的左端补充 k 个最高有效位的拷贝，并丢弃 k 个低位。

加减乘除运算符的优先级大于移位运算符，因此 $1 << 2 + 3 << 4$ 等效于 $1 << (2 + 3) << 4$。

## 整数的表示

### 无符号编码

一个长度为 $w$ 的位向量 $\vec{x} = [x_{w-1},x_{w-2},...,x_0]$，它从二进制（Binary）转化为无符号编码（Unsigned）的公式为：

$$ B2U_w(\vec{x}) \doteq \displaystyle\sum_{i=0}^{w - 1}x_i2^i $$

其中， $\doteq$ 符号表示等式的左手边被定义为右手边。无符号编码的最小值为位向量 [00...0]，即整数值 0。最大值为位向量 [11...1]，即整数值 $U\max_w \doteq \displaystyle\sum_{i=0}^{w - 1}2^i = 2^w -1$。函数 $B2U_w$ 是一个双射（bijection）：对于每个长度为 $w$ 的位向量，都有唯一的整数值与之对应，反之亦然。

### 二进制补码

二进制补码（Two's-Complement Encoding）将位向量的符号位（即最高有效位）作为负权重（negative weight），符号位为 1 代表值为负，符号位为 0 代表值为正。如一个长度为 $w$ 的位向量 $\vec{x} = [x_{w-1},x_{w-2},...,x_0]$，它从二进制转化为二进制补码的公式为：

$$ B2T_w(\vec{x}) \doteq -x_{w - 1}2^{w - 1} + \displaystyle\sum_{i=0}^{w - 2}x_i2^i $$

二进制补码的最小值为位向量 [10...0]，即整数值 $T\min_w \doteq -2^{w-1}$。最大值为位向量 [01...1]，即整数值 $T\max_w \doteq \displaystyle\sum_{i=0}^{w - 2}2^i = 2^{w-1} -1$。与二进制转化无符号编码类似，函数 $B2T_w$ 也是一个双射。而它们的最值之间有着如下性质：

$$ \|T\min\| =\|T\max\| + 1$$
$$ U\max = 2T\max + 1$$

特别地，整数-1 和 $U\max_w$的位级表示均为全 1：[11...1]，而整数 0 在两种表达方式中均为全 0：[00...0]。虽然 C 的标准并没有限制有符号整数的二进制表达，但大多数机器都采用了二进制补码的方式。

### 有符号数和无符号数的转换

在 C 中，有符号数和无符号数之间的转换是基于位级视角的，而非数字。例如：

```c
short int v = -12345;
unsigned short uv = (unsigned short) v;
printf("v = %d, uv = %u\n", v, uv);
```

输出结果为 v = -12345，uv = 53191。这意味着在类型转换过程中位向量不变，但位向量转换到整数值的方式不同。根据推导，二进制补码转换为无符号数的公式如下：

![20210715215516](https://cdn.jsdelivr.net/gh/koktlzz/ImgBed@master/20210715215516.png)

如图所示，非负数转换前后保持不变，负数则变成了一个较大的正数：

![20210715215945](https://cdn.jsdelivr.net/gh/koktlzz/ImgBed@master/20210715215945.png)

而无符号数转换为二进制补码的公式则为：

![20210715220159](https://cdn.jsdelivr.net/gh/koktlzz/ImgBed@master/20210715220159.png)

如图所示，小于 $2 ^ {w - 1}$ （最高有效位为 0）的数转换前后保持不变，大于等于 $2 ^ {w - 1}$ （最高有效位为 1）的数将被转换为一个负数：

![20210715220509](https://cdn.jsdelivr.net/gh/koktlzz/ImgBed@master/20210715220509.png)

通过上面的讨论我们发现，大于等于 0 且小于 $2 ^ {w - 1}$ 的值有相同的无符号和二进制补码表示。而这个范围之外的数，在转换过程中需要加上或减去 $2 ^ w$。

### C 中的有符号数和无符号数

通常大多数数字默认都是有符号的，除非加上后缀 U 或 u，如 12345U 和 0x1A2Bu 等。除了显式地使用强制类型转换（如上一节中的程序）以外，也可以将一种类型的表达式赋值给另一种变量，即隐式转换：

```c
int tx, ty;
unsigned ux, uy;
tx = ux; /* Cast to signed*/
uy = ty; /* Cast to usigned*/
```

如果参与运算的两个数一个是有符号的，一个是无符号的，那么 C 会隐式地将有符号数转换为无符号数并假定两数均为非负后再进行计算。比如表达式 -1 < 0U 的值为 false，因为 -1 会先转换为无符号数再与 0 进行比较。

### 扩展一个数的位级表示

要将一个无符号数转换为更大的数据类型，只需简单地在头部添加 0，这种运算被称为零扩展（zero extension）。而对于二进制补码，则需要在头部添加最高有效位（符号位），称为符号扩展（sign extension）。

### 截断数字

将一个数转换为更小的数据类型时，截断数字的位数是不可避免的。如一个 $w$ 位的位向量 $\vec{x} = [x_{w-1},x_{w-2},...,x_0]$截断为 $k$ 位时，我们会丢弃 $w-k$ 个高位，得到 ${\vec{x} = [x_{k-1},x_{k-2},...,x_0]}$。截断数字可能会导致值的变化：

$$B2U_k([x_{k-1},x_{k-2},...,x_0]) = B2U_w([x_{w-1},x_{w-2},...,x_0]) \bmod 2^k  $$
$$B2T_k([x_{k-1},x_{k-2},...,x_0])= U2T_k(B2U_w([x_{w-1},x_{w-2},...,x_0]) \bmod 2^k)$$

通过上面几小节的讨论，我们发现无符号数与有符号数之间的隐式转换导致了一些与常识相悖的运算结果，这将导致一些很难发现的程序错误。因此很多编程语言，如 Java，不支持无符号数的使用。

## 整数的运算

### 无符号加法

### 二进制补码加法

### 二进制补码的非

### 无符号乘法

### 二进制补码乘法

### 乘以 2 的幂

### 除以 2 的幂

## 浮点
