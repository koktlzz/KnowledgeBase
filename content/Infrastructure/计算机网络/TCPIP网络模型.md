---
title: "TCP/IP 网络模型"
description: ""
date: 2021-02-24T22:05:45+08:00
lastmod: 2021-02-24T22:05:45+08:00
draft: false
images: []
menu:
  infrastructure:
    parent: "计算机网络"
weight: 100
---

![layer](https://cdn.jsdelivr.net/gh/koktlzz/ImgBed@master/layer.PNG)

## 应用层

### HTTP1.0

在 Linux 系统中输入命令 **nc www.baidu.com 80**，与 baidu.com 的 80 端口建立一个连接。此时再打开一个终端，输入命令 **netstat -natp**：

![20201223170157](https://cdn.jsdelivr.net/gh/koktlzz/NoteImg@main/20201223170157.png)

发现本地与百度已经建立起一个连接，进程号 50603。此时如果本地向和百度进行通讯，则请求必须遵循 HTTP 协议。在第一个终端中继续输入命令 **GET / HTTP/1.0** 并两次回车：

![20201223165806](https://cdn.jsdelivr.net/gh/koktlzz/NoteImg@main/20201223165806.png)

百度则返回给主机响应头和响应体（HTML），依然遵循应用层的 HTTP1.0 协议。

### HTTP1.1 和 HTTP2.0

输入命令 **curl baidu.com -v**：

![20201223153643](https://cdn.jsdelivr.net/gh/koktlzz/NoteImg@main/20201223153643.png)

上述连接采用了 HTTP1.1 协议，那么它和 1.0 协议的区别是什么呢？我们使用 **telnet** 命令新建一个连接，如果使用 HTTP1.1 协议，即输入 **GET / HTTP/1.1** 后两次回车，我们可以看到 baidu.com 的响应且连接依然存在；然而如果输入的是 **GET / HTTP/1.0**，那么我们接收到响应后连接就中断了：

![20201223160159](https://cdn.jsdelivr.net/gh/koktlzz/NoteImg@main/20201223160159.png)

![20201223160034](https://cdn.jsdelivr.net/gh/koktlzz/NoteImg@main/20201223160034.png)

因此在 HTTP1.0 中，连接将在响应后立即关闭，这意味着必须为每个查询打开新的连接。 HTTP1.1 在同一个连接中只能有一个正在处理的请求，但是可以依次处理多个请求（当一个网页打开完成后，客户端和服务器之间用于传输 HTTP 数据的 TCP 连接不会关闭，如果客户端再次访问这个服务器上的网页，会继续使用这一条已经建立的 TCP 连接）。而 HTTP2.0 优于 HTTP1.1 的好处之一是，我们可以在同一连接上有多个处理中的请求。

### 其他应用层协议

而如果主机想要和其他的服务器，如 Tomcat，Redis 等，则要遵循相应的应用层协议。
例如连接 Redis 服务器，输入相关命令：
![20201223163117](https://cdn.jsdelivr.net/gh/koktlzz/NoteImg@main/20201223163117.png)

上述通讯便遵循了 Redis 的应用层协议。而主机输入的请求是怎么传输到服务端的呢？主机是如何与服务端建立连接呢？这便是内核层的工作。

## 传输控制层

应用层与传输控制层之间通过套接字（Socket）传递数据，套接字是传输控制层与应用层的一个中间媒介，位于两层之间。

![tcp](https://cdn.jsdelivr.net/gh/koktlzz/ImgBed@master/tcp.PNG)

- SYN：Synchronous 建立连接
- ACK：Acknowledge 确认
- FIN：Finish 结束连接

使用抓包工具 **tcpdump**：

```bash
# -nn : 数字的方式显示 IP 和端口，一个 n 是 ip
# -i : 网卡
# port : 端口号
tcpdump -nn -i eth0 port 80  
```

当 tcpdump 开始监听 eth0 后，使用 **curl** 命令连接到百度服务器：

![20201210102906](https://cdn.jsdelivr.net/gh/koktlzz/NoteImg@main/20201210102906.png)

命令行参数说明：

- 192.168.150.11 : 本机 ip 地址
- 220.181.38.149 : 服务端 ip 地址
- [S] : SYN
- [P] : PUSH（发送方通知接收方传输层应该尽快的将这个报文段交给应用层）
- [.] : ACK
- [F] : FIN
- length 168 : 客户端发出的请求头
- length 1460/1321 : 服务端发出的响应头和响应体，分两个包传输。
- win : 大小表示内核中可用的 TCP 缓冲区长度，可用来缓冲接收到的数据包。大小为 0 意味着接收端有很多滞后要从其套接字缓冲区中捕获，发送端必须暂停发送数据包，以便接收端能够应付。这种流量控制防止了接收端慢和发送端快的问题。

## 网络层

### IP

IPv4 点分字节：四个字节，一个字节 8 个二进制位（0~255），如 192.168.150.1。

查看`/etc/sysconfig/network-scripts/ifcfg-eth0`路径下的网卡配置文件信息：

![20201210132006](https://cdn.jsdelivr.net/gh/koktlzz/NoteImg@main/20201210132006.png)

- #HWADDR : 物理地址（MAC 地址）
- IPADDR : 主机 IP 地址
- NETMASK : 子网掩码
- GATEWAY : 网关
- DNS : DNS 服务器（将域名转换为 IP 地址）
- 网络号（网段）

通过 ip 地址与子网掩码进行**二进制按位与**运算得到，例如：
主机 ip：192.168.150.11
子网掩码：255.255.255.0
则该局域网网段为 192.168.150.0，该主机的主机号为 11。在此局域网下的其他主机 ip 可能为 192.168.150.1, 192.168.150.2, 192.168.150.3……等。

### Route（路由表）

使用命令 **route -n**：

得到本机路由表信息如下：

![1607578833(1)](https://cdn.jsdelivr.net/gh/koktlzz/NoteImg@main/1607578833(1).png)

- Destination : 可以连接的网络地址
- Gateway : 网关
- Genmask : 掩码
- Iface : 网络连接走的接口为 eth0

路由表的每一行代表一个路由规则：将服务端 ip 与掩码进行二进制按位与运算。如果计算得到的地址存在于本机路由表中的 Destination 中，则传输控制层可以向该服务端发送数据包，从而建立连接。
例如：服务端为同一局域网的另一台主机，ip 地址 192.168.150.n。那么它与掩码 255.255.255.0 二进制按位与运算后的结果为 192.168.150.0，即路由表中第一行的 Destination。第一行的网关为 0.0.0.0，代表不需要通过网关，可以直接通过 eth0 发送数据包；
如果服务端为 baidu，ip 地址 220.181.38.149。那么它与掩码 0.0.0.0 进行计算后的结果为 0.0.0.0，即路由表中第三行的 Destination。第三行的网关为 192.168.150.2，因此需要将数据包发送到此网关。当网关完成“下一跳”后，数据包才会到达服务端。

**思考一个问题**: 上述第二个例子中，如果传输控制层发出的数据包上只写一个 ip 地址，那么应该写 192.168.150.2 还是 220.181.38.149 呢？

- 如果写 192.168.150.2，网关可以接收到数据包，但是它却不知道这个数据包后续应该交给谁；
- 如果写 220.181.38.149，网络层就不知道该把这个数据包交给哪个网关了，因此需要链路层为我们完成这项任务。

## 链路层

使用命令 **arp -n**，查看本机的 arp 协议，即 ip 地址与网卡物理地址之间的映射关系：

![20201210142721](https://cdn.jsdelivr.net/gh/koktlzz/NoteImg@main/20201210142721.png)

而当我们使用命令 **ping www.baidu.com**，建立一个连接后，再次查看 arp 协议，会发现增加了一对映射关系：

![20201210142319](https://cdn.jsdelivr.net/gh/koktlzz/NoteImg@main/20201210142319.png)

同一网段的主机可以通过 arp 广播获取目的主机 MAC 地址后完成通信，但经计算发现 baidu.com 的 IP 地址与自身处于不同网段后，主机便只能通过 arp 协议发送广播请求网关的 MAC 地址。我们再次使用 **tcpdump -nn -i eth0 port 80 or arp** 命令进行抓包，这次还包括了 arp 广播发出的数据包：

![20201210145003](https://cdn.jsdelivr.net/gh/koktlzz/NoteImg@main/20201210145003.png)

可以发现在 TCP 发出握手请求之前，arp 就会发起广播请求`who-has 192.168.150.2 tell 192.168.150.11`，此处的 192.168.150.2 便是网关的 ip 地址，192.168.150.11 则是主机的 ip 地址。当得到回复`Reply 192.168.150.2 is-at 00:50:56:f7:53:2b`后，链路层便得到了指定网关的物理地址。

如果把数据包比作一个三层包装的邮政包裹，为了能够准确地将它送往服务端，**链路层**给它的最外层写上了网关 192.168.150.2 的 MAC 地址 00:50:56:f7:53:2b，**网络层**给中间层写上了服务端的 IP 地址 220.181.38.149，**传输控制层**则在最内层写上了服务端监听的端口号 PORT:80。

![未命名文件](https://cdn.jsdelivr.net/gh/koktlzz/NoteImg@main/未命名文件。jpg)

在每一跳中遵循类似的路由查找过程，直到数据包到达目标服务器。数据包的传输过程中，ip 地址和端口号始终不变。类似于数据结构中的链表，MAC 地址永远指向下一个目标。
