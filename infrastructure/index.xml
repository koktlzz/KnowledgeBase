<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>Infrastructures on</title><link>https://koktlzz.github.io/infrastructure/</link><description>Recent content in Infrastructures on</description><generator>Hugo -- gohugo.io</generator><language>en-US</language><lastBuildDate>Wed, 24 Feb 2021 22:05:45 +0800</lastBuildDate><atom:link href="https://koktlzz.github.io/infrastructure/index.xml" rel="self" type="application/rss+xml"/><item><title>TCP/IP 网络模型</title><link>https://koktlzz.github.io/infrastructure/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/tcpip%E7%BD%91%E7%BB%9C%E6%A8%A1%E5%9E%8B/</link><pubDate>Wed, 24 Feb 2021 22:05:45 +0800</pubDate><guid>https://koktlzz.github.io/infrastructure/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/tcpip%E7%BD%91%E7%BB%9C%E6%A8%A1%E5%9E%8B/</guid><description>应用层 HTTP1.0 在 Linux 系统中输入命令 nc www.baidu.com 80，与 baidu.com 的 80 端口建立一个连接。此时再打开一个终端，输入命令 netstat -natp：
发现本地与百度已经建立起一个连接，进程号 50603。此时如果本地向和百度进行通讯，则请求必须遵循 HTTP 协议。在第一个终端中继续输入命令 GET / HTTP/1.0 并两次回车：
百度则返回给主机响应头和响应体（HTML），依然遵循应用层的 HTTP1.0 协议。
HTTP1.1 和 HTTP2.0 输入命令 curl baidu.com -v：
上述连接采用了 HTTP1.1 协议，那么它和 1.0 协议的区别是什么呢？我们使用 telnet 命令新建一个连接，如果使用 HTTP1.1 协议，即输入 GET / HTTP/1.1 后两次回车，我们可以看到 baidu.com 的响应且连接依然存在；然而如果输入的是 GET / HTTP/1.0，那么我们接收到响应后连接就中断了：
因此在 HTTP1.0 中，连接将在响应后立即关闭，这意味着必须为每个查询打开新的连接。 HTTP1.1 在同一个连接中只能有一个正在处理的请求，但是可以依次处理多个请求（当一个网页打开完成后，客户端和服务器之间用于传输 HTTP 数据的 TCP 连接不会关闭，如果客户端再次访问这个服务器上的网页，会继续使用这一条已经建立的 TCP 连接）。而 HTTP2.0 优于 HTTP1.1 的好处之一是，我们可以在同一连接上有多个处理中的请求。
其他应用层协议 而如果主机想要和其他的服务器，如 Tomcat，Redis 等，则要遵循相应的应用层协议。 例如连接 Redis 服务器，输入相关命令： 上述通讯便遵循了 Redis 的应用层协议。而主机输入的请求是怎么传输到服务端的呢？主机是如何与服务端建立连接呢？这便是内核层的工作。</description></item><item><title>DNS、UDP 与 HTTPS</title><link>https://koktlzz.github.io/infrastructure/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/dnshttps/</link><pubDate>Wed, 24 Feb 2021 22:05:45 +0800</pubDate><guid>https://koktlzz.github.io/infrastructure/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/dnshttps/</guid><description>DNS 概述 DNS(Domain Name System) 是“域名系统”的英文缩写，是一种组织成域层次结构的计算机和网络服务命名系统。它在大多数情况下运行在 UDP 协议之上，从事将主机名或域名转换为实际 IP 地址的工作。
当你访问本网站的域名koktlzz.github.io，操作系统会先检查自己本地的 hosts 文件是否有这个网址映射关系，如果有，就先调用这个 IP 地址映射，完成域名解析。
[root@koktlzz ~]# cat /etc/hosts ::1 localhost localhost.localdomain localhost6 localhost6.localdomain6 127.0.0.1 localhost localhost.localdomain localhost4 localhost4.localdomain4 172.30.33.166 koktlzz.github.io koktlzz [root@koktlzz ~]# ping koktlzz PING koktlzz.github.io (172.30.33.166) 56(84) bytes of data. 如果本地配置里没有这个域名的映射，则查找本地 DNS 解析器缓存中是否有这个网址映射关系，若有则直接返回目标 IP 地址。而如果 hosts 文件与本地 DNS 解析器缓存都没有相应的网址映射关系，操作系统会向首选 DNS 服务器（在此我们叫它本地 DNS 服务器）发起请求。DNS 配置保存在 resolv.conf 文件中，其中的nameserver字段对应的便是本地 DNS 服务器地址：
[root@koktlzz ~]# cat /etc/resolv.conf # Generated by NetworkManager nameserver 100.</description></item><item><title>虚拟机网络</title><link>https://koktlzz.github.io/infrastructure/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/%E8%99%9A%E6%8B%9F%E6%9C%BA%E7%BD%91%E7%BB%9C/</link><pubDate>Wed, 24 Feb 2021 22:05:45 +0800</pubDate><guid>https://koktlzz.github.io/infrastructure/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/%E8%99%9A%E6%8B%9F%E6%9C%BA%E7%BD%91%E7%BB%9C/</guid><description>理论 桥接模式 使用桥接模式网络连接时，虚拟机将具有直接访问外部以太网网络的权限。虚拟机在外部网络中具有自己的 IP 地址； 如果主机联网，而且拥有可用于虚拟机的单独 IP 地址（或者可以从 DHCP 服务器获得 IP 地址），请选择此设置。网络中的其他计算机将能够与该虚拟机直接通信； 简单来说，桥接模式直接连接到路由器（交换机），和宿主机是平级。 NAT 利用 NAT, 虚拟机和主机系统将共享一个网络标识，此标识在网络以外不可见，同一网段内的其他主机无法与虚拟机连通； 如果没有可用于虚拟机的单独 IP 地址，但又希望能够连接到 Internet, 请选择 NAT。 简单来说，NAT 模式需连接到宿主机，宿主机为它传递网络数据。 Host-only 虚拟机仅可以和宿主机进行通信，而不能连接到外部网络。
实验 本机的 IP 地址为 192.168.0.104：
桥接模式 虚拟机的 IP 地址为 192.168.0.107（虚拟机与宿主机位于同一网段内）：
连入同一局域网的其他设备（以我的手机为例）可以 ping 通虚拟机的 IP 地址：
NAT 虚拟机的 IP 地址为 172.16.60.129（虚拟 IP）：
连入同一局域网的其他设备（以我的手机为例）无法 ping 通虚拟机的 IP 地址，只有宿主机可以：</description></item><item><title>VLAN</title><link>https://koktlzz.github.io/infrastructure/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/vlan/</link><pubDate>Wed, 24 Feb 2021 22:05:45 +0800</pubDate><guid>https://koktlzz.github.io/infrastructure/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/vlan/</guid><description>交换的基本概念 共享式以太网：当一台主机发送数据的时候，其他主机只能接收此数据，此时其他网上主机都不能发送数据； 冲突域：域内的不同设备同时发出的以太网帧会互相冲突，连接在同一集线器（Hub）的设备构成一个冲突域； 广播域：当广播域中的一台主机发出一个广播时，所有其他的设备都能接收到这个广播帧。未配置 VLAN 的二层交换机的每个端口构成一个冲突域，但同属于一个广播域。 VLAN 的特点 每个 VLAN 都是一个逻辑上的子网，相同 VLAN 中的主机可以跨越多个交换机进行通信，而不同 VLAN 间的主机则需要通过路由器或三层交换机； 每个 VLAN 中的所有设备都处于同一广播域内。广播无法跨 VLAN 传播，因此抑制了广播风暴的产生； 划分 VLAN 通常就是对交换机的端口进行划分，每个端口对应一个 VLAN ID； VLAN 工作于 OSI 参考模型的第二层。 实现方式 VLAN 的实现方式有静态和动态两种：
静态 VLAN：我们已经知道每个 VLAN 就是一个逻辑子网，那么每个 VLAN ID 自然就拥有其对应的子网号。管理员配置交换机端口和 VLAN ID 的对应关系后，主机便只能通过其所在子网对应的交换机端口加入 VLAN 中； 动态 VLAN（基于 MAC 地址）：将所有主机的 MAC 地址都加入到 VLAN 的管理数据库中。当主机连接到交换机的一个端口时，管理数据库将根据主机的 MAC 地址查询其要加入的 VLAN ID。随后自动设置该端口对应主机的 VLAN ID，主机便可以通过该端口加入到 VLAN 中。 端口分类 VLAN 交换机拥有两种端口，分别为 Access 端口和 Trunk 端口。其中，每个 Access 端口都会被分配一个 VLAN ID，标识它所连接的设备属于哪一个 VLAN。当数据帧通过 Access 端口进入交换机时，它将为数据帧打上 tag（tag 中包含 VLAN ID）；当数据帧从交换机内部通过 Access 端口向外发送时，若数据帧的 VLAN ID 和 Access 端口一致，则会被其接收。随后 Access 端口将数据帧中的 tag 信息去掉，再发送出去。</description></item><item><title>计算机系统之旅</title><link>https://koktlzz.github.io/infrastructure/csapp/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9F%E4%B9%8B%E6%97%85/</link><pubDate>Wed, 24 Feb 2021 22:05:45 +0800</pubDate><guid>https://koktlzz.github.io/infrastructure/csapp/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9F%E4%B9%8B%E6%97%85/</guid><description>信息就是 Bits + Context 一堆 bit 可以表示系统中的所有信息，包括磁盘中的文件、内存中的程序和用户数据以及网络中传输的数据，区分它们的唯一方式便是我们查看这些数据对象时所处的上下文（Context）。例如，相同的一串 bit 在不同的 Context 中可能代表一个整数，也可能代表一个浮点数，甚至字符串。
程序的转化过程 一个简单的 C 程序 hello.c 如下：
#include &amp;lt;stdio.h&amp;gt; int main() { printf(&amp;#34;hello world\n&amp;#34;); return 0; } 高级的 C 程序文件 hello.c 被转化为一系列低级的机器语言指令，最后以二进制可执行文件存储在磁盘中。
预处理阶段（Preprocessor）：预处理器修改 C 程序文件中以#号开头的命令。如 hello.c 中的#include &amp;lt;stdio.h&amp;gt;命令将会告诉预处理器系统头文件 stdiio.h 的内容，然后将其直接插入到程序文本中。生成的新程序文件为 hello.i； 编译阶段（Compilation）：编译器将 hello.i 文件转化为由汇编语言组成的 hello.s 文件。每条汇编语句都描述了一条低级的机器语言指令，不同高级语言编译后的汇编语句是通用的； 汇编阶段（Assembly）：汇编器将 hello.s 文件转化为由二进制机器语言指令的 hello.o 文件。如果我们用文本编辑器打开该文件，将会展现出一堆乱码； 链接阶段（Linking）：由于我们的程序调用了printf函数，而它存在于一个名为 printf.o 的预编译文件中。链接器负责将该文件并入，得到最终的可执行文件 hello。 系统的硬件组成 总线（Buses）：贯穿整个系统的一组电子管道，负责在各个组件之间传递给定大小的字节块（称为word）。word的大小是系统的基本参数，一般有 4 字节（32 位）或 8 字节（64 位）两种； I/O 设备：系统与外部世界连接的桥梁。图中的 I/O 设备有用于用户输入的键盘⌨️和鼠标🖱️、用于展示的用户输出以及用于长期存储数据和程序的磁盘驱动，每个 I/O 设备都通过控制器（Controller）或适配器（Adapter）与 I/O 总线相连。其中，控制器是设备自身或系统主板（Motherboard）上的芯片组，而适配器则是插在主板插槽上的卡； 主存储器（Main Memory）：处理器执行程序时存放程序和数据的临时存储。物理上来说，内存是由动态随机存取存储器（DRAM, Dynamic Random Access Memory）芯片组成的集合。而逻辑上则是一个线性的字节数组，每个字节都有其唯一地址（从 0 开始的数组索引）； CPU（Central Processing Unit ）: 解释或执行主存储器中指令的引擎。 PC：CPU 的核心是一个大小与word相同的存储设备（或寄存器），称为程序计数器（Program Counter）。PC 始终指向主存储器中某条机器语言指令，即内含其地址。CPU 会不断地重复执行 PC 指向的机器指令，并更新 PC 使其指向下一条指令； Register file：寄存器文件是一个小型存储设备，由一组word大小的寄存器组成，而每个寄存器都有自己的唯一名称； ALU： 算术/逻辑单元（Arithmetic/Logic Unit），能够计算新的数据和地址值。 程序的运行过程 从键盘上读取命令：当我们在终端中输入命令.</description></item><item><title>信息的表示和处理</title><link>https://koktlzz.github.io/infrastructure/csapp/%E4%BF%A1%E6%81%AF%E7%9A%84%E8%A1%A8%E7%A4%BA%E5%92%8C%E5%A4%84%E7%90%86/</link><pubDate>Wed, 24 Feb 2021 22:05:45 +0800</pubDate><guid>https://koktlzz.github.io/infrastructure/csapp/%E4%BF%A1%E6%81%AF%E7%9A%84%E8%A1%A8%E7%A4%BA%E5%92%8C%E5%A4%84%E7%90%86/</guid><description>信息的存储 大多数机器使用字节（8 位的块）作为存储器中的最小寻址单元，而非访问单独的位。内存中的每一个字节都对应一个唯一的数字，即它的地址，所有可能的地址集合构成了 虚拟内存。它是由 DRAM、闪存（flash memory) 和磁盘存储共同实现的，而在程序看来则只是一个统一的字节数组。
编译器和运行时系统负责将这个内存空间划分为更加可管理的单元，来存储不同的程序对象。例如，C 中指针的值代表存储块中第一个字节的虚拟地址。C 编译器还将每个指针与其类型信息联系起来，这样就可以根据指针值的类型生成不同的机器级代码来访问指针所指向的值。不过机器级代码中并没有任何有关类型的信息，而是简单的把每个程序对象都视为一个字节块。
十六进制表示法 使用二进制表示位模式（bit pattern）会非常冗长，因为一个字节就包含了 8 位。而如果使用十进制，则不方便与位模式进行互相转化，因此我们采用十六进制（Hexadecimal）来书写位模式。一个十六进制数占 4 位，因此一个字节的取值范围就是 $00_{16}$ ~ $FF_{16}$ 。
将一个二进制数字转化为十六进制数字，需要首先将其分为多个 4 位的组，然后再将每组数转化为十六进制。如果总位数不为 4 的倍数，那么最左边的一组可以少于四位，然后在首位补 0。如 $111100_2$ 可以分成 $0011_2$ 和 $1100_2$，转化结果为 $3C_{16}$ 。在 C 中，若一个常数以 0x 或 0X 作为前缀，则代表它是一个十六进制数字。
数据大小 每台计算机都有一个字长（word size），它指定了指针数据的标准大小。如果一台机器的字长为 $w$ 位，那么虚拟地址的范围为 $ 0～2^w -1 $，程序最多访问 $2^w$ 字节。32 位机器的虚拟地址大小约为 4GB，而 64 位机器则能达到 16EB。
C 中几个基本数据类型的大小如下表所示：
Signed Unsigned 32-bit 64-bit [signed] char unsigned char 1 1 short unsigned short 2 2 int unsigned 4 4 long unsigned long 4 8 int32_t uint_32t 4 4 int64_t uint_64t 8 8 char * 4 8 float 4 4 double 8 8 除 char 外，若不添加前缀 unsigned，则默认使用有符号类型。指针类型的数据使用机器的全字长，如 char *。由于某些数据类型的大小在不同机器上有所不同，因此开发人员应使程序对不同数据类型的确切大小不敏感，从而保证程序的可移植性（portable）。</description></item><item><title>程序的机器级表示</title><link>https://koktlzz.github.io/infrastructure/csapp/%E7%A8%8B%E5%BA%8F%E7%9A%84%E6%9C%BA%E5%99%A8%E7%BA%A7%E8%A1%A8%E7%A4%BA/</link><pubDate>Wed, 24 Feb 2021 22:05:45 +0800</pubDate><guid>https://koktlzz.github.io/infrastructure/csapp/%E7%A8%8B%E5%BA%8F%E7%9A%84%E6%9C%BA%E5%99%A8%E7%BA%A7%E8%A1%A8%E7%A4%BA/</guid><description>在使用高级语言，如 C、Java 编程时，我们无法了解程序具体的机器级实现。相比之下，使用汇编语言编写程序时，程序员必须指定程序使用的低级指令来执行计算。编译器提供的类型检查有助于检测许多程序错误，确保我们以一致的方式来引用和操作数据。最重要的是，用高级语言编写的程序可以在多种不同的机器上编译运行，而汇编语言则与机器特性高度相关。
尽管编译器完成了生成汇编代码的大部分工作，但阅读和理解汇编语言对于程序员来说是一项重要的技能：
Those who say “I understand the general principles, I don’t want to bother learning the details” are deluding themselves.
Intel 处理器历史 程序编码 机器级代码 首先，机器级程序的格式和行为是由指令集架构（instruction set architecture，ISA）定义的，包括处理器状态、指令格式以及每条指令对状态的影响。大多数 ISA，包括 x86-64，都将程序的行为描述为每条指令按顺序执行，且一条指令在下一条指令开始之前完成。虽然处理器硬件要复杂得多，可以同时执行许多指令，但它采用了安全措施来确保其整体行为与 ISA 规定的操作顺序相匹配。其次，机器级程序使用的内存地址是虚拟地址，提供了一个看似非常大的字节数组的内存模型。
汇编代码表示非常接近机器代码，与机器代码的二进制格式相比，它采用更具可读性的文本格式。一些对程序员隐藏的处理器状态在汇编代码中是可见的：
程序计数器（PC）：在 x86-64 中称为 %rip，代表即将执行的下一条指令在存储器中的地址； 包含 16 个位置（location）的整数寄存器文件（register file）：这些位置均被命名，每个都能存储 64 位的值。该寄存器可以保存地址（与 C 中的指针对应）和整数数据。一些寄存器用于记录程序状态的关键部分，而其他寄存器则用于保存临时数据，例如过程中的参数、局部变量和函数返回值； 条件码寄存器（condition code registers）：保存了最新执行的算术或逻辑指令的状态信息，用于实现控制流或数据流中条件的改变，例如 if 语句和 while 语句； 一组向量寄存器（vector registers）：每个都可以保存一个或多个整数或浮点数值。 虽然 C 提供了一个模型，让我们可以在内存中声明和分配不同数据类型的对象。但机器级代码只会简单地将内存视为一个按字节寻址的数组，因此 C 中的聚合数据类型（如数组和结构体）在机器级代码中会表示为连续的字节集合。甚至对于标量数据类型（如 int、char、float 和 bool 等），汇编代码也不会区分有符号和无符号整数、不同类型的指针以及指针和整数。
程序的可执行机器级代码、操作系统所需的一些信息、用于管理过程调用和返回（procedure calls and returns）的运行时栈以及用户分配的内存块（如使用 malloc 库函数）共同构成了程序内存，它使用虚拟地址寻址，不过只有部分虚拟地址的范围有效。例如，x86-64 机器的虚拟地址必须将前 16 位设置为 0，因此其有效范围包含 $2^{48}$ （64 TB）字节。操作系统负责管理该虚拟地址空间，并将其转换为实际处理器内存（processer memory）中的物理地址。</description></item><item><title>Linux 启动流程</title><link>https://koktlzz.github.io/infrastructure/linux/boot/</link><pubDate>Wed, 24 Feb 2021 22:05:45 +0800</pubDate><guid>https://koktlzz.github.io/infrastructure/linux/boot/</guid><description>前言 OpenShift 4.X 版本要求安装在操作系统为 CoreOS 的机器上，因此 官方文档 给出了使用 PXE 或 IPXE 引导 CoreOS 系统的方法。我们可以参考其操作流程，将一台 CentOS 7.X 的机器改写为 CoreOS 系统，步骤如下：
从 镜像下载页 下载安装所需版本的 kernel、initramfs 和 rootfs 文件，并将 rootfs 和点火文件（*.ign）上传到自建的 HTTP 服务器上；
将 kernel 和 initramfs 文件拷贝到 CentOS 7.X 机器的 /boot 目录下；
根据需求修改 /boot/grub2 目录下的 grub.cfg 文件；
重启机器。
对于操作系统初学者（比如我）来说，很难想象仅依靠添加和修改文件就能改变一台计算机的操作系统。为了解其实现原理，我们将对 Linux 的启动流程进行讨论，并从中说明上述操作是如何影响操作系统的。
Linux 启动流程 启动一台 Linux 机器的过程可以分为两个部分：Boot 和 Startup。其中，Boot 起始于计算机启动，在内核初始化完成且 systemd 进程开始加载后结束。紧接着， Startup 接管任务，使计算机达到一个用户可操作的状态。</description></item><item><title>文件权限</title><link>https://koktlzz.github.io/infrastructure/linux/filepermission/</link><pubDate>Wed, 24 Feb 2021 22:05:45 +0800</pubDate><guid>https://koktlzz.github.io/infrastructure/linux/filepermission/</guid><description>默认权限 [root@koktlzz ~]# mkdir test [root@koktlzz ~]# ll -d test/ drwxr-xr-x 2 root root 6 4 月 8 10:06 test/ [root@koktlzz ~]# umask 0022 新创建目录的默认权限并非 777，这是因为一些权限被 umask 清除了。由于当前 umask 值为 022，因此 test 目录默认被取消了所属组和其他用户的写权限（777-022=755）。
特殊权限 除了常见的读、写和执行权限 rwx 外，目录/文件还可能会被赋予一些特殊权限。比如 passwd 命令执行的二进制文件：
[root@koktlzz ~]# ls -l /usr/bin/passwd -rwsr-xr-x. 1 root root 33600 4 月 7 2020 /usr/bin/passwd 该可执行文件所属用户的权限为 rws，s 即 setuid/setgid，意为该文件会以其所属的用户/组的身份执行，而非运行命令的用户/组。即使普通用户无法修改 /etc/shadow 文件，但 passwd 命令依然会以 root 用户的身份执行，因此普通用户可以使用该命令修改其密码：
[root@koktlzz ~]# su kokt [kokt@koktlzz root]$ passwd Changing password for user kokt.</description></item></channel></rss>