<!doctype html><html lang=en-us><head><script async src="https://www.googletagmanager.com/gtag/js?id=G-D022F6NT2P"></script><script>window.dataLayer=window.dataLayer||[];function gtag(){dataLayer.push(arguments)}gtag('js',new Date),gtag('config','G-D022F6NT2P')</script><script>(function(b,d,e,a,g){b[a]=b[a]||[],b[a].push({'gtm.start':(new Date).getTime(),event:'gtm.js'});var f=d.getElementsByTagName(e)[0],c=d.createElement(e),h=a!='dataLayer'?'&l='+a:'';c.async=!0,c.src='https://www.googletagmanager.com/gtm.js?id='+g+h,f.parentNode.insertBefore(c,f)})(window,document,'script','dataLayer','GTM-P72R45W')</script><meta charset=utf-8><meta http-equiv=x-ua-compatible content="ie=edge"><meta name=viewport content="width=device-width,initial-scale=1,shrink-to-fit=no"><link rel=preload as=font href=https://koktlzz.github.io/fonts/vendor/jost/jost-v4-latin-regular.woff2 type=font/woff2 crossorigin><link rel=preload as=font href=https://koktlzz.github.io/fonts/vendor/jost/jost-v4-latin-700.woff2 type=font/woff2 crossorigin><link rel=preload as=font href=https://koktlzz.github.io/fonts/KaTeX_Main-Regular.woff2 type=font/woff2 crossorigin><link rel=preload as=font href=https://koktlzz.github.io/fonts/KaTeX_Math-Italic.woff2 type=font/woff2 crossorigin><link rel=stylesheet href=https://koktlzz.github.io/main.6fd70af9369bef8ad98be8ac549b09d4cc31a7751f59f66dd296a20fd0fa4ae07ec51aee16a7e125439572da86f49095224d7d27d5f3dab10a0fa43783ecd2e2.css integrity="sha512-b9cK+Tab74rZi+isVJsJ1Mwxp3UfWfZt0paiD9D6SuB+xRruFqfhJUOVctqG9JCVIk19J9Xz2rEKD6Q3g+zS4g==" crossorigin=anonymous><noscript><style>img.lazyload{display:none}</style></noscript><meta name=robots content="index, follow"><meta name=googlebot content="index, follow, max-snippet:-1, max-image-preview:large, max-video-preview:-1"><meta name=bingbot content="index, follow, max-snippet:-1, max-image-preview:large, max-video-preview:-1"><title>Service | Inspire Hub</title><meta name=description content><link rel=canonical href=https://koktlzz.github.io/kubernetes/kubernetes%E5%9F%BA%E7%A1%80/service/><meta property="og:locale" content="en_US"><meta property="og:type" content="article"><meta property="og:title" content="Service"><meta property="og:description" content="概述  Kubernetes 使用 Service 解决服务发现问题：每个 Pod 在创建后都会被分配一个 IP 地址，然而它会随着 Pod 的重启而改变； Service 可以通过标签选择器选择一组 Pod，然后作为它们共同的对外访问接口。这样我们的应用便可以在不知道 Pod 的 IP 地址的情况下，与其通信； 当 Service 的标签选择器选择了多个 Pod 时，还可以在它们之间做负载均衡； 众所周知，Service 的中文意为“服务”。但就其功能而言，更像是一个 Proxy（代理）或 Router（路由）。  配置 一个典型的 Service 对象配置如下：
kind: Service apiVersion: v1 metadata: name: nginx-server spec: clusterIP: 192.168.1.0 selector: app: nginx ports: - name: http protocol: TCP port: 80 targetPort: 9376 - name: https protocol: TCP port: 443 targetPort: 9377  每个 Service 都会由系统分配一个虚拟 IP 作为访问 Service 的入口 IP 地址，然后监听spec."><meta property="og:url" content="https://koktlzz.github.io/kubernetes/kubernetes%E5%9F%BA%E7%A1%80/service/"><meta property="og:site_name" content="Inspire Hub"><meta property="article:published_time" content="2020-11-04T09:19:42+01:00"><meta property="article:modified_time" content="2020-11-04T09:19:42+01:00"><meta property="og:image" content="https://koktlzz.github.io/doks.png"><meta property="og:image:alt" content="Inspire Hub"><meta name=twitter:card content="summary_large_image"><meta name=twitter:site content="@getdoks"><meta name=twitter:creator content="@henkverlinde"><meta name=twitter:title content="Service"><meta name=twitter:description content><meta name=twitter:image content="https://koktlzz.github.io/doks.png"><meta name=twitter:image:alt content="Service"><script type=application/ld+json>{"@context":"https://schema.org","@graph":[{"@type":"Organization","@id":"https://koktlzz.github.io/#/schema/organization/1","name":"Doks","url":"https://koktlzz.github.io/","sameAs":["https://twitter.com/getdoks","https://github.com/h-enk/doks"],"logo":{"@type":"ImageObject","@id":"https://koktlzz.github.io/#/schema/image/1","url":"https://koktlzz.github.io/logo-doks.png","width":512,"height":512,"caption":"Doks"},"image":{"@id":"https://koktlzz.github.io/#/schema/image/1"}},{"@type":"WebSite","@id":"https://koktlzz.github.io/#/schema/website/1","url":"https://koktlzz.github.io/","name":"Inspire Hub","description":"","publisher":{"@id":"https://koktlzz.github.io/#/schema/organization/1"}},{"@type":"WebPage","@id":"https://koktlzz.github.io/kubernetes/kubernetes%E5%9F%BA%E7%A1%80/service/","url":"https://koktlzz.github.io/kubernetes/kubernetes%E5%9F%BA%E7%A1%80/service/","name":"Service","description":"","isPartOf":{"@id":"https://koktlzz.github.io/#/schema/website/1"},"about":{"@id":"https://koktlzz.github.io/#/schema/organization/1"},"datePublished":"2020-11-04T09:19:42CET","dateModified":"2020-11-04T09:19:42CET","breadcrumb":{"@id":"https://koktlzz.github.io/kubernetes/kubernetes%E5%9F%BA%E7%A1%80/service/#/schema/breadcrumb/1"},"primaryImageOfPage":{"@id":"https://koktlzz.github.io/kubernetes/kubernetes%E5%9F%BA%E7%A1%80/service/#/schema/image/2"},"inLanguage":"en-US","potentialAction":[{"@type":"ReadAction","target":["https://koktlzz.github.io/kubernetes/kubernetes%E5%9F%BA%E7%A1%80/service/"]}]},{"@type":"BreadcrumbList","@id":"https://koktlzz.github.io/kubernetes/kubernetes%E5%9F%BA%E7%A1%80/service/#/schema/breadcrumb/1","name":"Breadcrumbs","itemListElement":[{"@type":"ListItem","position":1,"item":{"@type":"WebPage","@id":"https://koktlzz.github.io/","url":"https://koktlzz.github.io/","name":"Home"}},{"@type":"ListItem","position":2,"item":{"@type":"WebPage","@id":"https://koktlzz.github.io/kubernetes/","url":"https://koktlzz.github.io/kubernetes/","name":"Kubernetes"}},{"@type":"ListItem","position":3,"item":{"@type":"WebPage","@id":"https://koktlzz.github.io/kubernetes/kubernetes%E5%9F%BA%E7%A1%80/","url":"https://koktlzz.github.io/kubernetes/kubernetes%E5%9F%BA%E7%A1%80/","name":"Kubernetes% E5%9 F% Ba% E7% A1%80"}},{"@type":"ListItem","position":4,"item":{"@id":"https://koktlzz.github.io/kubernetes/kubernetes%E5%9F%BA%E7%A1%80/service/"}}]},{"@context":"https://schema.org","@graph":[{"@type":"ImageObject","@id":"https://koktlzz.github.io/kubernetes/kubernetes%E5%9F%BA%E7%A1%80/service/#/schema/image/2","url":"https://koktlzz.github.io/doks.png","contentUrl":"https://koktlzz.github.io/doks.png","caption":"Service"}]}]}</script><meta name=theme-color content="#fff"><link rel=apple-touch-icon sizes=180x180 href=https://koktlzz.github.io/apple-touch-icon.png><link rel=icon type=image/png sizes=32x32 href=https://koktlzz.github.io/favicon-32x32.ico><link rel=icon type=image/png sizes=16x16 href=https://koktlzz.github.io/favicon-16x16.ico><link rel=manifest crossorigin=use-credentials href=https://koktlzz.github.io/site.webmanifest></head><body class="Kubernetes single dark"><noscript><iframe src="https://www.googletagmanager.com/ns.html?id=GTM-P72R45W" height=0 width=0 style=display:none;visibility:hidden></iframe></noscript><div class="header-bar fixed-top"></div><header class="navbar fixed-top navbar-expand-md navbar-light"><div class=container-fluid><input class="menu-btn order-0" type=checkbox id=menu-btn>
<label class="menu-icon d-md-none" for=menu-btn><span class=navicon></span></label><a class="navbar-brand order-1 order-md-0 me-auto" href=https://koktlzz.github.io/>Inspire Hub</a>
<button id=mode class="btn btn-link order-2 order-md-4" type=button aria-label="Toggle mode">
<span class=toggle-dark><svg xmlns="http://www.w3.org/2000/svg" width="20" height="20" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="feather feather-moon"><path d="M21 12.79A9 9 0 1111.21 3 7 7 0 0021 12.79z"/></svg></span><span class=toggle-light><svg xmlns="http://www.w3.org/2000/svg" width="20" height="20" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="feather feather-sun"><circle cx="12" cy="12" r="5"/><line x1="12" y1="1" x2="12" y2="3"/><line x1="12" y1="21" x2="12" y2="23"/><line x1="4.22" y1="4.22" x2="5.64" y2="5.64"/><line x1="18.36" y1="18.36" x2="19.78" y2="19.78"/><line x1="1" y1="12" x2="3" y2="12"/><line x1="21" y1="12" x2="23" y2="12"/><line x1="4.22" y1="19.78" x2="5.64" y2="18.36"/><line x1="18.36" y1="5.64" x2="19.78" y2="4.22"/></svg></span></button><ul class="navbar-nav social-nav order-3 order-md-5"><li class=nav-item><a class=nav-link href=https://github.com/koktlzz><svg xmlns="http://www.w3.org/2000/svg" width="20" height="20" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="feather feather-github"><path d="M9 19c-5 1.5-5-2.5-7-3m14 6v-3.87a3.37 3.37.0 00-.94-2.61c3.14-.35 6.44-1.54 6.44-7A5.44 5.44.0 0020 4.77 5.07 5.07.0 0019.91 1S18.73.65 16 2.48a13.38 13.38.0 00-7 0C6.27.65 5.09 1 5.09 1A5.07 5.07.0 005 4.77 5.44 5.44.0 003.5 8.55c0 5.42 3.3 6.61 6.44 7A3.37 3.37.0 009 18.13V22"/></svg><span class="ms-2 visually-hidden">GitHub</span></a></li></ul><div class="collapse navbar-collapse order-4 order-md-1"><ul class="navbar-nav main-nav me-auto order-5 order-md-2"><li class=nav-item><a class=nav-link href=https://koktlzz.github.io/docker/docker%E5%9F%BA%E7%A1%80/intro>Docker</a></li><li class=nav-item><a class=nav-link href=https://koktlzz.github.io/kubernetes/kubernetes%E5%9F%BA%E7%A1%80/intro>Kubernetes</a></li><li class=nav-item><a class=nav-link href=https://koktlzz.github.io/elastic/elasticstack/intro>Elastic</a></li><li class=nav-item><a class=nav-link href=https://koktlzz.github.io/go/go%E5%9F%BA%E7%A1%80/intro>Go</a></li><li class=nav-item><a class=nav-link href=https://koktlzz.github.io/infra/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E5%9F%BA%E7%A1%80/tcpip%E7%BD%91%E7%BB%9C%E6%A8%A1%E5%9E%8B>Infra</a></li></ul><div class="break order-6 d-md-none"></div></div></div></header><div class="wrap container-fluid" role=document><div class=content><div class="row flex-xl-nowrap"><div class="col-lg-3 col-xl-2 d-none d-xl-block"><nav class=docs-links aria-label="Main navigation"><h3>Kubernetes 基础</h3><ul class=list-unstyled><li><a class=docs-link href=https://koktlzz.github.io/kubernetes/kubernetes%E5%9F%BA%E7%A1%80/intro/>Get Started</a></li><li><a class=docs-link href=https://koktlzz.github.io/kubernetes/kubernetes%E5%9F%BA%E7%A1%80/infrastructure/>Infrastructure</a></li><li><a class=docs-link href=https://koktlzz.github.io/kubernetes/kubernetes%E5%9F%BA%E7%A1%80/pod%E4%B8%8Enamespace/>Pod 与 Namespace</a></li><li><a class=docs-link href=https://koktlzz.github.io/kubernetes/kubernetes%E5%9F%BA%E7%A1%80/service/>Service</a></li><li><a class=docs-link href=https://koktlzz.github.io/kubernetes/kubernetes%E5%9F%BA%E7%A1%80/volume/>Volume</a></li><li><a class=docs-link href=https://koktlzz.github.io/kubernetes/kubernetes%E5%9F%BA%E7%A1%80/workloads/>Workloads</a></li></ul><h3>Kubernetes 进阶</h3><ul class=list-unstyled><li><a class=docs-link href=https://koktlzz.github.io/kubernetes/kubernetes%E8%BF%9B%E9%98%B6/networkpolicy/>Network Policy</a></li><li><a class=docs-link href=https://koktlzz.github.io/kubernetes/kubernetes%E8%BF%9B%E9%98%B6/ingress/>Ingress</a></li><li><a class=docs-link href=https://koktlzz.github.io/kubernetes/kubernetes%E8%BF%9B%E9%98%B6/sdn/>SDN</a></li><li><a class=docs-link href=https://koktlzz.github.io/kubernetes/kubernetes%E8%BF%9B%E9%98%B6/openvswitch/>Open vSwitch</a></li></ul></nav></div><main class="docs-content col-lg-13 col-xl-11"><h1>Service</h1><p class=lead></p><h2 id=概述>概述<a href=#概述 class=anchor aria-hidden=true>#</a></h2><ul><li>Kubernetes 使用 Service 解决服务发现问题：每个 Pod 在创建后都会被分配一个 IP 地址，然而它会随着 Pod 的重启而改变；</li><li>Service 可以通过标签选择器选择一组 Pod，然后作为它们共同的对外访问接口。这样我们的应用便可以在不知道 Pod 的 IP 地址的情况下，与其通信；</li><li>当 Service 的标签选择器选择了多个 Pod 时，还可以在它们之间做负载均衡；</li><li>众所周知，Service 的中文意为“服务”。但就其功能而言，更像是一个 Proxy（代理）或 Router（路由）。</li></ul><h2 id=配置>配置<a href=#配置 class=anchor aria-hidden=true>#</a></h2><p>一个典型的 Service 对象配置如下：</p><div class=highlight><pre style=color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yaml data-lang=yaml><span style=color:#ff79c6>kind</span>: Service
<span style=color:#ff79c6>apiVersion</span>: v1
<span style=color:#ff79c6>metadata</span>:
  <span style=color:#ff79c6>name</span>: nginx-server
<span style=color:#ff79c6>spec</span>:
  <span style=color:#ff79c6>clusterIP</span>: <span style=color:#bd93f9>192.168.1.0</span>
  <span style=color:#ff79c6>selector</span>:
    <span style=color:#ff79c6>app</span>: nginx
  <span style=color:#ff79c6>ports</span>:
    - <span style=color:#ff79c6>name</span>: http
      <span style=color:#ff79c6>protocol</span>: TCP
      <span style=color:#ff79c6>port</span>: <span style=color:#bd93f9>80</span>
      <span style=color:#ff79c6>targetPort</span>: <span style=color:#bd93f9>9376</span>
    - <span style=color:#ff79c6>name</span>: https
      <span style=color:#ff79c6>protocol</span>: TCP
      <span style=color:#ff79c6>port</span>: <span style=color:#bd93f9>443</span>
      <span style=color:#ff79c6>targetPort</span>: <span style=color:#bd93f9>9377</span>
</code></pre></div><ul><li>每个 Service 都会由系统分配一个虚拟 IP 作为访问 Service 的入口 IP 地址，然后监听<code>spec.ports.port</code>字段指定的端口；</li><li>Service 的 IP 也可以通过<code>spec.clusterIP</code>字段指定，且必须是 APIServer 中的配置字段<code>service-cluster-ip-range</code> CIDR 范围内的合法地址；</li><li>标签选择器<code>spec.selector</code>能够根据 labels 选择目标 Pod，而 Service 会将外部流量转发到目标 Pod 的<code>spec.ports.targetPort</code>端口；</li><li>该 Service 开放了多个端口（80/443），因此必须定义端口的名称<code>spec.ports.name</code>（http/https），以避免歧义；</li><li>当 Service 被创建后，系统随之创建一个同名的 Endpoints 对象，它保存了所有匹配标签选择器的 Pod 的 IP 地址和端口；</li><li>若单个 Endpoints 对象过大，则当其发生变化时需要处理大量的网络流量，从而影响集群中主控件的性能。因此，Kubernetes 引入
Endpoint Slice 资源解决这一问题。该资源建立在 Endpoint 的基础上，并为其提供了可伸缩扩展的替代方案。当集群中的 Service 关联有大量（>100）Endpoints 对象时，它们将被分成多个较小的 Endpoint Slice 对象。</li></ul><h3 id=无标签选择器的-service>无标签选择器的 Service<a href=#无标签选择器的-service class=anchor aria-hidden=true>#</a></h3><p>上文提到，Service 常用于对 Pod 的流量调度，但也可以用于访问：</p><ul><li>同一集群不同 namespace 中的或其他集群中的 Service</li><li>其他的一些后端程序或数据库</li></ul><p>此时需要定义一个没有标签选择器的 Service，如：</p><div class=highlight><pre style=color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yaml data-lang=yaml><span style=color:#ff79c6>apiVersion</span>: v1
<span style=color:#ff79c6>kind</span>: Service
<span style=color:#ff79c6>metadata</span>:
  <span style=color:#ff79c6>name</span>: my-service
<span style=color:#ff79c6>spec</span>:
  <span style=color:#ff79c6>ports</span>:
    - <span style=color:#ff79c6>protocol</span>: TCP
      <span style=color:#ff79c6>port</span>: <span style=color:#bd93f9>80</span>
      <span style=color:#ff79c6>targetPort</span>: <span style=color:#bd93f9>9376</span>
</code></pre></div><p>因为该 Service 没有标签选择器，相应的 Endpoint 对象便无法自动创建。因此我们需要手动创建一个 Endpoint 对象，以便将到达该 Service 监听的端口的请求映射到后端程序或其他 Service 的 IP 地址和端口：</p><div class=highlight><pre style=color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yaml data-lang=yaml><span style=color:#ff79c6>apiVersion</span>: v1
<span style=color:#ff79c6>kind</span>: Endpoints
<span style=color:#ff79c6>metadata</span>:
  <span style=color:#ff79c6>name</span>: my-service
<span style=color:#ff79c6>subsets</span>:
  - <span style=color:#ff79c6>addresses</span>:
      - <span style=color:#ff79c6>ip</span>: <span style=color:#bd93f9>192.0.2.42</span>
    <span style=color:#ff79c6>ports</span>:
      - <span style=color:#ff79c6>port</span>: <span style=color:#bd93f9>9376</span>
</code></pre></div><p>在上述例子中，Service 将请求路由到 Endpoint：192.0.2.42:9376 (TCP)。另外，目标 IP 不能是本机回环地址或虚拟 IP 地址。</p><h3 id=headless-services>Headless Services<a href=#headless-services class=anchor aria-hidden=true>#</a></h3><p>Headless Service 不提供负载均衡的特性，也没有自己的 IP 地址，kube-proxy 并不会处理这类 Service。只需要指定<code>spec.clusterIP</code>字段值为"None"，便可以创建一个 Headless Service 对象。</p><h2 id=代理模式>代理模式<a href=#代理模式 class=anchor aria-hidden=true>#</a></h2><ul><li><a href=https://www.digitalocean.com/community/tutorials/a-deep-dive-into-iptables-and-netfilter-architecture><strong>iptables</strong></a>：由 kube-proxy 负责为每一个 Service 创建和维护 iptables 的路由规则，其余工作由内核的 iptables 完成。当数据包发往 Service 时，iptables 承担了从 Service 的 IP 地址到 Pod 的 IP 地址的目的地址转换（DNAT）和负载均衡工作。在默认情况下，iptables 会将请求随机重定向到由 Service 代理的一组 Pod 中的某个 Pod 上。另外，iptables 还使用 Netfilter 的 conntrack 工具包记录选择的目标 Pod 的 IP 地址。这样当数据包返回时，iptables 便可以根据该记录，将返回数据包的源地址由 Pod 的 IP 地址转换为 Service 的 IP 的地址（SNAT）。</li></ul><p><img src=https://cdn.jsdelivr.net/gh/koktlzz/ImgBed@master/demo.002.png alt=demo.002></p><ul><li><strong>IPVS</strong>：kube-proxy 监视 Service 和 Endpoint 对象的改变，调用 netlink 接口相应地创建 IPVS 规则，并定期地将 IPVS 规则与 Service 和 Endpoint 对象同步。IPVS 可以转发 TCP/UDP 请求到实际的服务器上，使得一组实际的服务器（Pod）看起来像是只通过一个单一 IP 地址（Service）访问的服务一样。</li></ul><p><img src=https://cdn.jsdelivr.net/gh/koktlzz/NoteImg@main/234259911661134760.jpg alt=234259911661134760></p><h2 id=服务发现模式>服务发现模式<a href=#服务发现模式 class=anchor aria-hidden=true>#</a></h2><p>Kubernetes 支持两种基本的服务发现模式 —— 环境变量和 DNS。</p><h3 id=环境变量>环境变量<a href=#环境变量 class=anchor aria-hidden=true>#</a></h3><p>kubelet 会为节点上活跃的 Service 对象创建一组环境变量（包括 Service 的 ClusterIP、监听的端口等），并在创建 Pod 时这些环境它们注入其中。使用这种服务发现模式要求 Service 先于 Pod 创建，因此有一定的局限性。</p><p>举例来说，一个名称为 redis-master 的 Service 暴露了 TCP 端口 6379，同时为它分配了 ClusterIP 地址 10.0.0.11。Pod 中的环境变量如下：</p><div class=highlight><pre style=color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-json data-lang=json>REDIS_MASTER_SERVICE_HOST=<span style=color:#bd93f9>10.0</span>.<span style=color:#bd93f9>0.11</span>
REDIS_MASTER_SERVICE_PORT=<span style=color:#bd93f9>6379</span>
REDIS_MASTER_PORT=tcp://<span style=color:#bd93f9>10.0</span>.<span style=color:#bd93f9>0.11</span>:<span style=color:#bd93f9>6379</span>
REDIS_MASTER_PORT_<span style=color:#bd93f9>6379</span>_TCP=tcp://<span style=color:#bd93f9>10.0</span>.<span style=color:#bd93f9>0.11</span>:<span style=color:#bd93f9>6379</span>
REDIS_MASTER_PORT_<span style=color:#bd93f9>6379</span>_TCP_PROTO=tcp
REDIS_MASTER_PORT_<span style=color:#bd93f9>6379</span>_TCP_PORT=<span style=color:#bd93f9>6379</span>
REDIS_MASTER_PORT_<span style=color:#bd93f9>6379</span>_TCP_ADDR=<span style=color:#bd93f9>10.0</span>.<span style=color:#bd93f9>0.11</span>
</code></pre></div><h3 id=dns>DNS<a href=#dns class=anchor aria-hidden=true>#</a></h3><p>集群中的 DNS 服务器（例如 CoreDNS）使用 Kubernetes 的 watch api 不断监测 Service 的创建并为每一个 Service 创建一条 DNS 记录，从而使 Pod 可以通过解析该记录而得到 Service 的 Cluster IP。对于不同类型的 Service，其 DNS 记录的分配方式有所不同：</p><h4 id=headless-service-以外的-service>Headless Service 以外的 Service<a href=#headless-service-以外的-service class=anchor aria-hidden=true>#</a></h4><ul><li><p>Service 将被分配一个 A 记录，格式为：</p><p>&lt;service-name>.&lt;namespace-name>.svc.cluster.local</p><p>其中，cluster.local 为默认的集群域名，该 DNS 记录解析到 Service 的 ClusterIP。</p></li><li><p>若 Servic 存在一个已被命名的端口（<code>spec.ports.name</code>字段不为空），则该端口将被分配一个 SRV 记录，其格式为：
&lt;_port-name>.&lt;_port-protocol>.&lt;service-name>.&lt;namespace-name>.svc.cluster.local</p><p>则可根据该 SRV 记录发现该 Service 的命名端口及 IP 地址。</p></li></ul><h4 id=headless-service>Headless Service<a href=#headless-service class=anchor aria-hidden=true>#</a></h4><ul><li><p>已定义标签选择器的 Headless Service：Endpoints Controller 在 Kubernetes API 中创建 Endpoints 对象，并修改 DNS 配置返回一个 A 记录（格式与普通的 Service 相同），指向该 Service 选取的一组 Pod 的 IP 地址。</p></li><li><p>无标签选择器的 Headless Service：Endpoints Controller 不再创建 Endpoints 对象。若 Service 类型为 ExternalName，DNS 服务返回其 CNAME 记录；若 Service 为其他类型，返回与该 Service 同名的 Endpoints 对象的 A 记录。Service 的类型将在下一节中进行介绍。</p></li></ul><h2 id=外部访问>外部访问<a href=#外部访问 class=anchor aria-hidden=true>#</a></h2><p>集群中的节点（虚拟机）可以通过网关访问互联网，但 Pod 的 IP 地址与其所在节点的 IP 地址显然不同。由于网关的 NAT 功能只能转换节点（虚拟机）的 IP 地址，而无法转换 Pod 的 IP 地址。毕竟网关根本无法知晓节点上运行了什么样的 Pod，因此 Pod 是无法访问外网的。而我们常希望将集群中的一些运行前端应用的 Pod 暴露给集群外部的 IP 地址，这时便需要改变<code>spec.type</code>字段定义特殊类型的 Service 了。</p><h3 id=clusterip>ClusterIP<a href=#clusterip class=anchor aria-hidden=true>#</a></h3><p>默认的 Service 类型，通过集群中的内部 IP 暴露 Service，这种方式的 Service 只能在集群内部访问。</p><h3 id=nodeport>NodePort<a href=#nodeport class=anchor aria-hidden=true>#</a></h3><p>通过每个节点上的 IP 和静态端口（<code>spec.ports.nodePort</code>）暴露 Service，其配置如下：</p><div class=highlight><pre style=color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yaml data-lang=yaml><span style=color:#ff79c6>apiVersion</span>: v1
<span style=color:#ff79c6>kind</span>: Service
<span style=color:#ff79c6>metadata</span>:
  <span style=color:#ff79c6>name</span>: my-service
<span style=color:#ff79c6>spec</span>:
  <span style=color:#ff79c6>type</span>: NodePort
  <span style=color:#ff79c6>selector</span>:
    <span style=color:#ff79c6>app</span>: MyApp
  <span style=color:#ff79c6>ports</span>:
    - <span style=color:#ff79c6>port</span>: <span style=color:#bd93f9>80</span>               
      <span style=color:#ff79c6>targetPort</span>: <span style=color:#bd93f9>80</span>
      <span style=color:#ff79c6>nodePort</span>: <span style=color:#bd93f9>30007</span>        <span style=color:#6272a4># 如不指定，则会从 30000-32767 范围内分配一个端口号</span>
</code></pre></div><p>通过、&lt;NodeIP>:<code>spec.ports.nodePort</code>向集群外部暴露 Service，同时也会在集群内部暴露 ClusterIP 类型的访问方式。当集群外部向节点的外网 IP 地址发送请求时，流量将会被路由到<code>spec.clusterIp:spec.ports.port</code>，最后再被转发到后端 Pod 的<code>spec.ports.targetPort</code>端口上。使用 NodePort 类型的 Service 来实现外部访问有以下缺陷：</p><ul><li>当集群中有多个该类型的 Service 时，每个 Service 都要绑定一个节点端口。节点需要暴露外围端口调用 Service，可能造成管理混乱；</li><li>实现该类型的 Service 需为节点配置外网 IP，因此可能无法应用于很多公司要求的防火墙规则。</li></ul><h3 id=loadbalancer>LoadBalancer<a href=#loadbalancer class=anchor aria-hidden=true>#</a></h3><p>使用云提供商的负载均衡器向集群外部暴露 Service，同时也会 <a href=https://stackoverflow.com/questions/41509439/whats-the-difference-between-clusterip-nodeport-and-loadbalancer-service-types>暴露 ClusterIP 和 NodePort 类型的访问方式</a>：</p><ul><li><code>spec.clusterIp</code>:<code>spec.ports.port</code>；</li><li>&lt;NodeIP>:<code>spec.ports.nodePort</code>；</li><li>负载均衡器的 IP 和 port。</li></ul><p>负载均衡器是异步创建的。当 LoadBalancer 类型的 Service 创建完成后，负载均衡器的信息将被回写到 Service 的<code>status.loadBalancer</code>字段中，例如：</p><div class=highlight><pre style=color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yaml data-lang=yaml>  <span style=color:#ff79c6>apiVersion</span>: v1
  <span style=color:#ff79c6>kind</span>: Service
  <span style=color:#ff79c6>metadata</span>:
    <span style=color:#ff79c6>name</span>: example-service
  <span style=color:#ff79c6>spec</span>:
    <span style=color:#ff79c6>selector</span>:
      <span style=color:#ff79c6>app</span>: example
    <span style=color:#ff79c6>clusterIP</span>: <span style=color:#bd93f9>10.84.206.2</span>
    <span style=color:#ff79c6>externalIPs</span>:              <span style=color:#6272a4># 某些云服务商允许直接设置 loadBalancerIP 字段来指定 loadBalancer 的 IP 地址</span>
    - <span style=color:#bd93f9>172.29.245.25</span>             
    <span style=color:#ff79c6>ports</span>:
    - <span style=color:#ff79c6>nodePort</span>: <span style=color:#bd93f9>31688</span>
      <span style=color:#ff79c6>port</span>: <span style=color:#bd93f9>8765</span>
      <span style=color:#ff79c6>protocol</span>: TCP
      <span style=color:#ff79c6>targetPort</span>: <span style=color:#bd93f9>9376</span>
    <span style=color:#ff79c6>type</span>: LoadBalancer
  <span style=color:#ff79c6>status</span>:
    <span style=color:#ff79c6>loadBalancer</span>:
      <span style=color:#ff79c6>ingress</span>:
      - <span style=color:#ff79c6>ip</span>: <span style=color:#bd93f9>172.29.245.25</span>    
</code></pre></div><p>Loadbalancer 类型的 Service 处理外网入方向流量的流程如下：</p><ul><li>Loadbalancer 类型的 Service 创建后，Cloud Controller（云服务商提供）将为其创建一个负载均衡器；</li><li>负载均衡器只能直接和节点（虚拟机）沟通，并不知晓 Service 和 Pod 的存在。当数据包从请求方（互联网）到达负载均衡器之后，将被转发到集群中的某一节点的<code>spec.ports.nodePort</code>端口上；</li><li>与 NodePort 类型的 Service 相同，数据包再次被转发到<code>spec.clusterIp</code>:<code>spec.ports.port</code>，最后通过 iptables 发送到后端 Pod。</li></ul><h3 id=externalname>ExternalName<a href=#externalname class=anchor aria-hidden=true>#</a></h3><p>ExternalName 类型的 Service 将 Service 映射到 DNS 名称，而非标签选择器选取的一组 Pod 上，其配置如下：</p><div class=highlight><pre style=color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yaml data-lang=yaml><span style=color:#ff79c6>apiVersion</span>: v1
<span style=color:#ff79c6>kind</span>: Service
<span style=color:#ff79c6>metadata</span>:
  <span style=color:#ff79c6>name</span>: my-service
  <span style=color:#ff79c6>namespace</span>: prod
<span style=color:#ff79c6>spec</span>:
  <span style=color:#ff79c6>type</span>: ExternalName
  <span style=color:#ff79c6>externalName</span>: my.database.example.com
</code></pre></div><p>当查找域名：my-service.prod.svc.cluster.local 时，集群内的 DNS 服务将返回一条 CNAME 记录，即<code>spec.externalName</code>字段的值 my.database.example.com。访问该 Service 的方式与其他类型的 Service 相同，但主要区别在于重定向发生在 DNS 级别，而不是通过代理或转发。</p><h3 id=external-ip>External IP<a href=#external-ip class=anchor aria-hidden=true>#</a></h3><p>如果有外部 IP 路由到 Kubernetes 集群的一个或多个节点，任意类型的 Service 可以通过、&lt;<code>spec.externalIPs</code>>:&lt;<code>spec.ports.port</code>>进行访问。</p><div class=highlight><pre style=color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yaml data-lang=yaml><span style=color:#ff79c6>apiVersion</span>: v1
<span style=color:#ff79c6>kind</span>: Service
<span style=color:#ff79c6>metadata</span>:
  <span style=color:#ff79c6>name</span>: my-service
<span style=color:#ff79c6>spec</span>:
  <span style=color:#ff79c6>selector</span>:
    <span style=color:#ff79c6>app</span>: MyApp
  <span style=color:#ff79c6>ports</span>:
    - <span style=color:#ff79c6>name</span>: http
      <span style=color:#ff79c6>protocol</span>: TCP
      <span style=color:#ff79c6>port</span>: <span style=color:#bd93f9>80</span>
      <span style=color:#ff79c6>targetPort</span>: <span style=color:#bd93f9>9376</span>
  <span style=color:#ff79c6>externalIPs</span>:
    - <span style=color:#bd93f9>80.11.12.10</span>
</code></pre></div><p>在上面的例子中，客户端即可通过 80.11.12.10:80 访问名为 my-service 的 Service 对象。</p><h2 id=参考文献>参考文献<a href=#参考文献 class=anchor aria-hidden=true>#</a></h2><p><a href=https://www.digitalocean.com/community/tutorials/a-deep-dive-into-iptables-and-netfilter-architecture>A Deep Dive into Iptables and Netfilter Architecture</a></p><p><a href=https://sookocheff.com/post/kubernetes/understanding-kubernetes-networking-model/>A Guide to the Kubernetes Networking Model</a></p><p><a href=https://stackoverflow.com/questions/41509439/whats-the-difference-between-clusterip-nodeport-and-loadbalancer-service-types>What&rsquo;s the difference between ClusterIP, NodePort and LoadBalancer service types in Kubernetes?</a></p><p class=edit-page><a href=https://github.com/koktlzz/koktlzz.github.io/blob/master/content/Kubernetes/Kubernetes%e5%9f%ba%e7%a1%80/Service.md><svg xmlns="http://www.w3.org/2000/svg" width="16" height="16" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="feather feather-edit-2"><path d="M17 3a2.828 2.828.0 114 4L7.5 20.5 2 22l1.5-5.5L17 3z"/></svg>Edit this page on GitHub</a></p><div class="docs-navigation d-flex justify-content-between"><a href=https://koktlzz.github.io/kubernetes/kubernetes%E5%9F%BA%E7%A1%80/pod%E4%B8%8Enamespace/><div class="card my-1"><div class="card-body py-2">&larr; Pod 与 Namespace</div></div></a><a class=ms-auto href=https://koktlzz.github.io/kubernetes/kubernetes%E5%9F%BA%E7%A1%80/volume/><div class="card my-1"><div class="card-body py-2">Volume &rarr;</div></div></a></div><script src=https://utteranc.es/client.js repo=koktlzz/koktlzz.github.io issue-term=pathname theme=photon-dark crossorigin=anonymous async></script></main><nav class="docs-toc d-none d-xl-block col-lg-3 col-xl-2" aria-label="Secondary navigation"><div class=page-links><h3>On this page</h3><nav id=TableOfContents><ul><li><a href=#概述>概述</a></li><li><a href=#配置>配置</a><ul><li><a href=#无标签选择器的-service>无标签选择器的 Service</a></li><li><a href=#headless-services>Headless Services</a></li></ul></li><li><a href=#代理模式>代理模式</a></li><li><a href=#服务发现模式>服务发现模式</a><ul><li><a href=#环境变量>环境变量</a></li><li><a href=#dns>DNS</a></li></ul></li><li><a href=#外部访问>外部访问</a><ul><li><a href=#clusterip>ClusterIP</a></li><li><a href=#nodeport>NodePort</a></li><li><a href=#loadbalancer>LoadBalancer</a></li><li><a href=#externalname>ExternalName</a></li><li><a href=#external-ip>External IP</a></li></ul></li><li><a href=#参考文献>参考文献</a></li></ul></nav></div></nav></div></div></div><footer class="footer text-muted"><div class=container><div class=row><div class="col-lg-8 order-last order-lg-first"><ul class=list-inline><li class=list-inline-item></li></ul></div><div class="col-lg-8 order-first order-lg-last text-lg-end"><ul class=list-inline></ul></div></div></div></footer><script src=https://koktlzz.github.io/js/bootstrap.min.d67050adf5d370668aede4201f82af781b16970934804995a1ca37c1ee9222c2fc530972aa6d5d2b6124caf1fe318f139aac99df2c1e89af65504fc1185c7972.js integrity="sha512-1nBQrfXTcGaK7eQgH4KveBsWlwk0gEmVoco3we6SIsL8Uwlyqm1dK2EkyvH+MY8TmqyZ3yweia9lUE/BGFx5cg==" crossorigin=anonymous defer></script><script src=https://koktlzz.github.io/js/vendor/katex/dist/katex.min.b334e5b00c45f572e7f38a543046f36854bf4cbb543880480c09271a0efedc694d6905f719934f6ede2f26f52e80411c05b90121d722cbf8be2fa8fc51bc6b81.js integrity="sha512-szTlsAxF9XLn84pUMEbzaFS/TLtUOIBIDAknGg7+3GlNaQX3GZNPbt4vJvUugEEcBbkBIdciy/i+L6j8UbxrgQ==" crossorigin=anonymous defer></script><script src=https://koktlzz.github.io/js/vendor/katex/dist/contrib/auto-render.min.916823ec103cf367b71e28a6f01513cb9c3ac6708ccb5229402ec46b8e30a8b25003db694df35d80e9dd666a371f327c6152790617b6256390c164109a90bd4c.js integrity="sha512-kWgj7BA882e3Hiim8BUTy5w6xnCMy1IpQC7Ea44wqLJQA9tpTfNdgOndZmo3HzJ8YVJ5Bhe2JWOQwWQQmpC9TA==" crossorigin=anonymous defer></script><script src=https://koktlzz.github.io/main.min.1febbf2f6fd6a36fc2f57dd50d7935fbb640743329baeb4ef7cefcf2e7630e413371fbba976e103656b82808ee227dc4a84237edb0f8433648bef3a56900661a.js integrity="sha512-H+u/L2/Wo2/C9X3VDXk1+7ZAdDMpuutO98788udjDkEzcfu6l24QNla4KAjuIn3EqEI37bD4QzZIvvOlaQBmGg==" crossorigin=anonymous defer></script></body></html>