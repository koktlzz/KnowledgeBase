<!doctype html><html lang=en-us><head><script async src="https://www.googletagmanager.com/gtag/js?id=G-D022F6NT2P"></script><script>window.dataLayer=window.dataLayer||[];function gtag(){dataLayer.push(arguments)}gtag('js',new Date),gtag('config','G-D022F6NT2P')</script><script>(function(b,d,e,a,g){b[a]=b[a]||[],b[a].push({'gtm.start':(new Date).getTime(),event:'gtm.js'});var f=d.getElementsByTagName(e)[0],c=d.createElement(e),h=a!='dataLayer'?'&l='+a:'';c.async=!0,c.src='https://www.googletagmanager.com/gtm.js?id='+g+h,f.parentNode.insertBefore(c,f)})(window,document,'script','dataLayer','GTM-P72R45W')</script><meta charset=utf-8><meta http-equiv=x-ua-compatible content="ie=edge"><meta name=viewport content="width=device-width,initial-scale=1,shrink-to-fit=no"><link rel=preload as=font href=https://koktlzz.github.io/fonts/vendor/jost/jost-v4-latin-regular.woff2 type=font/woff2 crossorigin><link rel=preload as=font href=https://koktlzz.github.io/fonts/vendor/jost/jost-v4-latin-700.woff2 type=font/woff2 crossorigin><link rel=preload as=font href=https://koktlzz.github.io/fonts/KaTeX_Main-Regular.woff2 type=font/woff2 crossorigin><link rel=preload as=font href=https://koktlzz.github.io/fonts/KaTeX_Math-Italic.woff2 type=font/woff2 crossorigin><link rel=stylesheet href=https://koktlzz.github.io/main.0ae7165cfeda76c765ab05aa408a696be65779f1e277afd078efecc543cc00bb72be873f087e148ccf7ac1016b22c2d2586f058c7ee5d92dcca60206eae2dd99.css integrity="sha512-CucWXP7adsdlqwWqQIppa+ZXefHid6/QeO/sxUPMALtyvoc/CH4UjM96wQFrIsLSWG8FjH7l2S3MpgIG6uLdmQ==" crossorigin=anonymous><noscript><style>img.lazyload{display:none}</style></noscript><meta name=robots content="index, follow"><meta name=googlebot content="index, follow, max-snippet:-1, max-image-preview:large, max-video-preview:-1"><meta name=bingbot content="index, follow, max-snippet:-1, max-image-preview:large, max-video-preview:-1"><title>Namespace 隔离 | Inspire Hub</title><meta name=description content><link rel=canonical href=https://koktlzz.github.io/container/docker/namespace%E9%9A%94%E7%A6%BB/><meta property="og:locale" content="en_US"><meta property="og:type" content="article"><meta property="og:title" content="Namespace 隔离"><meta property="og:description" content="简介 在 Linux 中可以使用 lsns 命令查看系统中的所有 namespace：
[root@koktlzz ~]# lsns NS TYPE NPROCS PID USER COMMAND 4026531835 cgroup 94 1 root /usr/lib/systemd/systemd --switched-root --system --deserialize 17 4026531836 pid 94 1 root /usr/lib/systemd/systemd --switched-root --system --deserialize 17 4026531837 user 94 1 root /usr/lib/systemd/systemd --switched-root --system --deserialize 17 4026531838 uts 94 1 root /usr/lib/systemd/systemd --switched-root --system --deserialize 17 4026531839 ipc 94 1 root /usr/lib/systemd/systemd --switched-root --system --deserialize 17 4026531840 mnt 88 1 root /usr/lib/systemd/systemd --switched-root --system --deserialize 17 4026531860 mnt 1 16 root kdevtmpfs 4026531992 net 94 1 root /usr/lib/systemd/systemd --switched-root --system --deserialize 17 4026532193 mnt 1 599 root /usr/lib/systemd/systemd-udevd 4026532195 mnt 2 693 root /sbin/auditd 4026532196 mnt 1 782 chrony /usr/sbin/chronyd 4026532197 mnt 1 893 root /usr/sbin/NetworkManager --no-daemon    Namespace 系统调用参数 隔离内容 应用意义     UTS CLONE_NEWUTS 主机与域名 每个容器在网络中可以被视作一个独立的节点，而非宿主机的一个进程   IPC CLONE_NEWIPC 信号量、消息队列和共享内存 隔离容器间、容器与宿主机之间的进程间通信   PID CLONE_NEWPID 进程编号 隔离容器间、容器与宿主机之间的进程 PID   Network CLONE_NEWNET 网络设备、网络栈、端口等 避免产生容器间、容器与宿主机之间产生端口已占用的问题   Mount CLONE_NEWNS 挂载点（文件系统） 容器间、容器与宿主机之间的文件系统互不影响   User CLONE_NEWUSER 用户和用户组 普通用户（组）在容器内部也可以成为超级用户（组），从而进行权限管理    进行 Namespace API 操作的方式 clone() clone() 可以在创建新进程（子进程）的同时创建 namespace，是 Docker 使用 namespace 最基本的方法。"><meta property="og:url" content="https://koktlzz.github.io/container/docker/namespace%E9%9A%94%E7%A6%BB/"><meta property="og:site_name" content="Inspire Hub"><meta property="article:published_time" content="2021-02-24T22:05:45+08:00"><meta property="article:modified_time" content="2021-02-24T22:05:45+08:00"><meta property="og:image" content="https://koktlzz.github.io/doks.png"><meta property="og:image:alt" content="Inspire Hub"><meta name=twitter:card content="summary_large_image"><meta name=twitter:site content="@getdoks"><meta name=twitter:creator content="@henkverlinde"><meta name=twitter:title content="Namespace 隔离"><meta name=twitter:description content><meta name=twitter:image content="https://koktlzz.github.io/doks.png"><meta name=twitter:image:alt content="Namespace 隔离"><script type=application/ld+json>{"@context":"https://schema.org","@graph":[{"@type":"Organization","@id":"https://koktlzz.github.io/#/schema/organization/1","name":"Doks","url":"https://koktlzz.github.io/","sameAs":["https://twitter.com/getdoks","https://github.com/h-enk/doks"],"logo":{"@type":"ImageObject","@id":"https://koktlzz.github.io/#/schema/image/1","url":"https://koktlzz.github.io/logo-doks.png","width":512,"height":512,"caption":"Doks"},"image":{"@id":"https://koktlzz.github.io/#/schema/image/1"}},{"@type":"WebSite","@id":"https://koktlzz.github.io/#/schema/website/1","url":"https://koktlzz.github.io/","name":"Inspire Hub","description":"","publisher":{"@id":"https://koktlzz.github.io/#/schema/organization/1"}},{"@type":"WebPage","@id":"https://koktlzz.github.io/container/docker/namespace%E9%9A%94%E7%A6%BB/","url":"https://koktlzz.github.io/container/docker/namespace%E9%9A%94%E7%A6%BB/","name":"Namespace 隔离","description":"","isPartOf":{"@id":"https://koktlzz.github.io/#/schema/website/1"},"about":{"@id":"https://koktlzz.github.io/#/schema/organization/1"},"datePublished":"2021-02-24T22:05:45CET","dateModified":"2021-02-24T22:05:45CET","breadcrumb":{"@id":"https://koktlzz.github.io/container/docker/namespace%E9%9A%94%E7%A6%BB/#/schema/breadcrumb/1"},"primaryImageOfPage":{"@id":"https://koktlzz.github.io/container/docker/namespace%E9%9A%94%E7%A6%BB/#/schema/image/2"},"inLanguage":"en-US","potentialAction":[{"@type":"ReadAction","target":["https://koktlzz.github.io/container/docker/namespace%E9%9A%94%E7%A6%BB/"]}]},{"@type":"BreadcrumbList","@id":"https://koktlzz.github.io/container/docker/namespace%E9%9A%94%E7%A6%BB/#/schema/breadcrumb/1","name":"Breadcrumbs","itemListElement":[{"@type":"ListItem","position":1,"item":{"@type":"WebPage","@id":"https://koktlzz.github.io/","url":"https://koktlzz.github.io/","name":"Home"}},{"@type":"ListItem","position":2,"item":{"@type":"WebPage","@id":"https://koktlzz.github.io/container/","url":"https://koktlzz.github.io/container/","name":"Container"}},{"@type":"ListItem","position":3,"item":{"@type":"WebPage","@id":"https://koktlzz.github.io/container/docker/","url":"https://koktlzz.github.io/container/docker/","name":"Docker"}},{"@type":"ListItem","position":4,"item":{"@id":"https://koktlzz.github.io/container/docker/namespace%E9%9A%94%E7%A6%BB/"}}]},{"@context":"https://schema.org","@graph":[{"@type":"ImageObject","@id":"https://koktlzz.github.io/container/docker/namespace%E9%9A%94%E7%A6%BB/#/schema/image/2","url":"https://koktlzz.github.io/doks.png","contentUrl":"https://koktlzz.github.io/doks.png","caption":"Namespace 隔离"}]}]}</script><meta name=theme-color content="#fff"><link rel=apple-touch-icon sizes=180x180 href=https://koktlzz.github.io/apple-touch-icon.png><link rel=icon type=image/png sizes=32x32 href=https://koktlzz.github.io/favicon-32x32.ico><link rel=icon type=image/png sizes=16x16 href=https://koktlzz.github.io/favicon-16x16.ico><link rel=manifest crossorigin=use-credentials href=https://koktlzz.github.io/site.webmanifest></head><body class="Container single dark"><noscript><iframe src="https://www.googletagmanager.com/ns.html?id=GTM-P72R45W" height=0 width=0 style=display:none;visibility:hidden></iframe></noscript><div class="header-bar fixed-top"></div><header class="navbar fixed-top navbar-expand-md navbar-light"><div class=container-fluid><input class="menu-btn order-0" type=checkbox id=menu-btn>
<label class="menu-icon d-md-none" for=menu-btn><span class=navicon></span></label><a class="navbar-brand order-1 order-md-0 me-auto" href=https://koktlzz.github.io/>Inspire Hub</a>
<button id=mode class="btn btn-link order-2 order-md-4" type=button aria-label="Toggle mode">
<span class=toggle-dark><svg xmlns="http://www.w3.org/2000/svg" width="20" height="20" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="feather feather-moon"><path d="M21 12.79A9 9 0 1111.21 3 7 7 0 0021 12.79z"/></svg></span><span class=toggle-light><svg xmlns="http://www.w3.org/2000/svg" width="20" height="20" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="feather feather-sun"><circle cx="12" cy="12" r="5"/><line x1="12" y1="1" x2="12" y2="3"/><line x1="12" y1="21" x2="12" y2="23"/><line x1="4.22" y1="4.22" x2="5.64" y2="5.64"/><line x1="18.36" y1="18.36" x2="19.78" y2="19.78"/><line x1="1" y1="12" x2="3" y2="12"/><line x1="21" y1="12" x2="23" y2="12"/><line x1="4.22" y1="19.78" x2="5.64" y2="18.36"/><line x1="18.36" y1="5.64" x2="19.78" y2="4.22"/></svg></span></button><ul class="navbar-nav social-nav order-3 order-md-5"><li class=nav-item><a class=nav-link href=https://github.com/koktlzz><svg xmlns="http://www.w3.org/2000/svg" width="20" height="20" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="feather feather-github"><path d="M9 19c-5 1.5-5-2.5-7-3m14 6v-3.87a3.37 3.37.0 00-.94-2.61c3.14-.35 6.44-1.54 6.44-7A5.44 5.44.0 0020 4.77 5.07 5.07.0 0019.91 1S18.73.65 16 2.48a13.38 13.38.0 00-7 0C6.27.65 5.09 1 5.09 1A5.07 5.07.0 005 4.77 5.44 5.44.0 003.5 8.55c0 5.42 3.3 6.61 6.44 7A3.37 3.37.0 009 18.13V22"/></svg><span class="ms-2 visually-hidden">GitHub</span></a></li></ul><div class="collapse navbar-collapse order-4 order-md-1"><ul class="navbar-nav main-nav me-auto order-5 order-md-2"><li class=nav-item><a class=nav-link href=https://koktlzz.github.io/container/docker/intro>Container</a></li><li class=nav-item><a class=nav-link href=https://koktlzz.github.io/observability/elasticstack/intro>Observability</a></li><li class=nav-item><a class=nav-link href=https://koktlzz.github.io/programming/go/intro>Programming</a></li><li class=nav-item><a class=nav-link href=https://koktlzz.github.io/infrastructure/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E5%9F%BA%E7%A1%80/tcpip%E7%BD%91%E7%BB%9C%E6%A8%A1%E5%9E%8B>Infrastructure</a></li></ul><div class="break order-6 d-md-none"></div></div></div></header><div class="wrap container-fluid" role=document><div class=content><div class="row flex-xl-nowrap"><div class="col-lg-3 col-xl-2 d-none d-xl-block"><nav class=docs-links aria-label="Main navigation"><h3>Docker</h3><ul class=list-unstyled><li><a class=docs-link href=https://koktlzz.github.io/container/docker/intro/>Getting Started</a></li><li><a class=docs-link href=https://koktlzz.github.io/container/docker/%E7%8B%82%E7%A5%9Edocker%E8%AF%BE%E7%A8%8B%E7%AC%94%E8%AE%B0/>狂神 Docker 课程笔记</a></li><li><a class=docs-link href=https://koktlzz.github.io/container/docker/dockercompose/>Docker Compose</a></li><li><a class=docs-link href=https://koktlzz.github.io/container/docker/namespace%E9%9A%94%E7%A6%BB/>Namespace 隔离</a></li><li><a class=docs-link href=https://koktlzz.github.io/container/docker/cgroups%E9%9A%94%E7%A6%BB/>CGroups 隔离</a></li><li><a class=docs-link href=https://koktlzz.github.io/container/docker/%E9%95%9C%E5%83%8F%E4%B8%8E%E5%AE%B9%E5%99%A8/>镜像与容器</a></li></ul><h3>Kubernetes</h3><ul class=list-unstyled><li><a class=docs-link href=https://koktlzz.github.io/container/kubernetes/intro/>Getting Started</a></li><li><a class=docs-link href=https://koktlzz.github.io/container/kubernetes/infrastructure/>Infrastructure</a></li><li><a class=docs-link href=https://koktlzz.github.io/container/kubernetes/pod%E4%B8%8Enamespace/>Pod 与 Namespace</a></li><li><a class=docs-link href=https://koktlzz.github.io/container/kubernetes/service/>Service</a></li><li><a class=docs-link href=https://koktlzz.github.io/container/kubernetes/volume/>Volume</a></li><li><a class=docs-link href=https://koktlzz.github.io/container/kubernetes/workloads/>Workloads</a></li><li><a class=docs-link href=https://koktlzz.github.io/container/kubernetes/ingress/>Ingress</a></li><li><a class=docs-link href=https://koktlzz.github.io/container/kubernetes/networkpolicy/>Network Policy</a></li><li><a class=docs-link href=https://koktlzz.github.io/container/kubernetes/sdn/>SDN</a></li><li><a class=docs-link href=https://koktlzz.github.io/container/kubernetes/openvswitch/>Open vSwitch</a></li></ul></nav></div><main class="docs-content col-lg-13 col-xl-11"><h1>Namespace 隔离</h1><p class=lead></p><h2 id=简介>简介<a href=#简介 class=anchor aria-hidden=true>#</a></h2><p>在 Linux 中可以使用 <strong>lsns</strong> 命令查看系统中的所有 namespace：</p><div class=highlight><pre style=color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-bash data-lang=bash><span style=color:#ff79c6>[</span>root@koktlzz ~<span style=color:#ff79c6>]</span><span style=color:#6272a4># lsns</span>
        NS TYPE   NPROCS   PID USER   COMMAND
<span style=color:#bd93f9>4026531835</span> cgroup     <span style=color:#bd93f9>94</span>     <span style=color:#bd93f9>1</span> root   /usr/lib/systemd/systemd --switched-root --system --deserialize <span style=color:#bd93f9>17</span>
<span style=color:#bd93f9>4026531836</span> pid        <span style=color:#bd93f9>94</span>     <span style=color:#bd93f9>1</span> root   /usr/lib/systemd/systemd --switched-root --system --deserialize <span style=color:#bd93f9>17</span>
<span style=color:#bd93f9>4026531837</span> user       <span style=color:#bd93f9>94</span>     <span style=color:#bd93f9>1</span> root   /usr/lib/systemd/systemd --switched-root --system --deserialize <span style=color:#bd93f9>17</span>
<span style=color:#bd93f9>4026531838</span> uts        <span style=color:#bd93f9>94</span>     <span style=color:#bd93f9>1</span> root   /usr/lib/systemd/systemd --switched-root --system --deserialize <span style=color:#bd93f9>17</span>
<span style=color:#bd93f9>4026531839</span> ipc        <span style=color:#bd93f9>94</span>     <span style=color:#bd93f9>1</span> root   /usr/lib/systemd/systemd --switched-root --system --deserialize <span style=color:#bd93f9>17</span>
<span style=color:#bd93f9>4026531840</span> mnt        <span style=color:#bd93f9>88</span>     <span style=color:#bd93f9>1</span> root   /usr/lib/systemd/systemd --switched-root --system --deserialize <span style=color:#bd93f9>17</span>
<span style=color:#bd93f9>4026531860</span> mnt         <span style=color:#bd93f9>1</span>    <span style=color:#bd93f9>16</span> root   kdevtmpfs
<span style=color:#bd93f9>4026531992</span> net        <span style=color:#bd93f9>94</span>     <span style=color:#bd93f9>1</span> root   /usr/lib/systemd/systemd --switched-root --system --deserialize <span style=color:#bd93f9>17</span>
<span style=color:#bd93f9>4026532193</span> mnt         <span style=color:#bd93f9>1</span>   <span style=color:#bd93f9>599</span> root   /usr/lib/systemd/systemd-udevd
<span style=color:#bd93f9>4026532195</span> mnt         <span style=color:#bd93f9>2</span>   <span style=color:#bd93f9>693</span> root   /sbin/auditd
<span style=color:#bd93f9>4026532196</span> mnt         <span style=color:#bd93f9>1</span>   <span style=color:#bd93f9>782</span> chrony /usr/sbin/chronyd
<span style=color:#bd93f9>4026532197</span> mnt         <span style=color:#bd93f9>1</span>   <span style=color:#bd93f9>893</span> root   /usr/sbin/NetworkManager --no-daemon
</code></pre></div><table><thead><tr><th>Namespace</th><th>系统调用参数</th><th>隔离内容</th><th>应用意义</th></tr></thead><tbody><tr><td>UTS</td><td>CLONE_NEWUTS</td><td>主机与域名</td><td>每个容器在网络中可以被视作一个独立的节点，而非宿主机的一个进程</td></tr><tr><td>IPC</td><td>CLONE_NEWIPC</td><td>信号量、消息队列和共享内存</td><td>隔离容器间、容器与宿主机之间的进程间通信</td></tr><tr><td>PID</td><td>CLONE_NEWPID</td><td>进程编号</td><td>隔离容器间、容器与宿主机之间的进程 PID</td></tr><tr><td>Network</td><td>CLONE_NEWNET</td><td>网络设备、网络栈、端口等</td><td>避免产生容器间、容器与宿主机之间产生端口已占用的问题</td></tr><tr><td>Mount</td><td>CLONE_NEWNS</td><td>挂载点（文件系统）</td><td>容器间、容器与宿主机之间的文件系统互不影响</td></tr><tr><td>User</td><td>CLONE_NEWUSER</td><td>用户和用户组</td><td>普通用户（组）在容器内部也可以成为超级用户（组），从而进行权限管理</td></tr></tbody></table><h2 id=进行-namespace-api-操作的方式>进行 Namespace API 操作的方式<a href=#进行-namespace-api-操作的方式 class=anchor aria-hidden=true>#</a></h2><h3 id=clone>clone()<a href=#clone class=anchor aria-hidden=true>#</a></h3><p>clone() 可以在创建新进程（子进程）的同时创建 namespace，是 Docker 使用 namespace 最基本的方法。</p><div class=highlight><pre style=color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-c data-lang=c><span style=color:#6272a4>// child_func: 子进程运行的程序主函数
</span><span style=color:#6272a4>// child_stack: 子进程所使用的堆栈的位置，通常指向为子堆栈设置的内存空间的最高地址
</span><span style=color:#6272a4>// flags: 使用的 CLONE_*标志位
</span><span style=color:#6272a4>// args: 传入子进程的参数
</span><span style=color:#6272a4>// 在父进程中返回创建的子进程 pid
</span><span style=color:#6272a4></span><span style=color:#8be9fd>int</span> <span style=color:#50fa7b>clone</span>(<span style=color:#8be9fd>int</span> (<span style=color:#ff79c6>*</span>child_func)(<span style=color:#8be9fd>void</span> <span style=color:#ff79c6>*</span>), <span style=color:#8be9fd>void</span> <span style=color:#ff79c6>*</span>child_stack, <span style=color:#8be9fd>int</span> flags, <span style=color:#8be9fd>void</span> <span style=color:#ff79c6>*</span>arg);
</code></pre></div><p>相比于调用 fork() 创建新进程，clone() 更加灵活，因为它可以通过改变 flags 参数来控制其实现的功能，后续将详细介绍各种 flags 的用法。</p><h3 id=setns>setns()<a href=#setns class=anchor aria-hidden=true>#</a></h3><p>setns() 可以加入一个已经存在的 namespace，Docker 中的 exec 命令便调用了该方法：</p><div class=highlight><pre style=color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-c data-lang=c><span style=color:#6272a4>// fd: 加入的 namespace 的文件描述符
</span><span style=color:#6272a4>// nstype: 检查 fd 指向的 namespace 类型是否符合实际要求，为 0 表示不检查
</span><span style=color:#6272a4></span><span style=color:#8be9fd>int</span> <span style=color:#50fa7b>setns</span>(<span style=color:#8be9fd>int</span> fd, <span style=color:#8be9fd>int</span> nstype);
</code></pre></div><p>参数 fd 表示要加入的 namespace 的文件描述符，它指向 <strong>/proc/[pid]/ns</strong> 文件夹下中的软链接文件。而这些软连接文件又指向不同的 namespace, 如&rsquo;cgroup:[4026531835]&lsquo;中的数字即为其指向的 namespace 号 ($$是 bash 中表示当前运行的进程 PID)。</p><div class=highlight><pre style=color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-bash data-lang=bash><span style=color:#ff79c6>[</span>root@koktlzz proc<span style=color:#ff79c6>]</span><span style=color:#6272a4># ls -l /proc/$$/ns</span>
总用量 <span style=color:#bd93f9>0</span>
lrwxrwxrwx <span style=color:#bd93f9>1</span> root root <span style=color:#bd93f9>0</span> <span style=color:#bd93f9>1</span> 月  <span style=color:#bd93f9>29</span> 10:57 cgroup -&gt; <span style=color:#f1fa8c>&#39;cgroup:[4026531835]&#39;</span>
lrwxrwxrwx <span style=color:#bd93f9>1</span> root root <span style=color:#bd93f9>0</span> <span style=color:#bd93f9>1</span> 月  <span style=color:#bd93f9>29</span> 10:57 ipc -&gt; <span style=color:#f1fa8c>&#39;ipc:[4026531839]&#39;</span>
lrwxrwxrwx <span style=color:#bd93f9>1</span> root root <span style=color:#bd93f9>0</span> <span style=color:#bd93f9>1</span> 月  <span style=color:#bd93f9>29</span> 10:57 mnt -&gt; <span style=color:#f1fa8c>&#39;mnt:[4026531840]&#39;</span>
lrwxrwxrwx <span style=color:#bd93f9>1</span> root root <span style=color:#bd93f9>0</span> <span style=color:#bd93f9>1</span> 月  <span style=color:#bd93f9>29</span> 10:57 net -&gt; <span style=color:#f1fa8c>&#39;net:[4026531992]&#39;</span>
lrwxrwxrwx <span style=color:#bd93f9>1</span> root root <span style=color:#bd93f9>0</span> <span style=color:#bd93f9>1</span> 月  <span style=color:#bd93f9>29</span> 10:57 pid -&gt; <span style=color:#f1fa8c>&#39;pid:[4026531836]&#39;</span>
lrwxrwxrwx <span style=color:#bd93f9>1</span> root root <span style=color:#bd93f9>0</span> <span style=color:#bd93f9>1</span> 月  <span style=color:#bd93f9>29</span> 10:57 pid_for_children -&gt; <span style=color:#f1fa8c>&#39;pid:[4026531836]&#39;</span>
lrwxrwxrwx <span style=color:#bd93f9>1</span> root root <span style=color:#bd93f9>0</span> <span style=color:#bd93f9>1</span> 月  <span style=color:#bd93f9>29</span> 10:57 user -&gt; <span style=color:#f1fa8c>&#39;user:[4026531837]&#39;</span>
lrwxrwxrwx <span style=color:#bd93f9>1</span> root root <span style=color:#bd93f9>0</span> <span style=color:#bd93f9>1</span> 月  <span style=color:#bd93f9>29</span> 10:57 uts -&gt; <span style=color:#f1fa8c>&#39;uts:[4026531838]&#39;</span>
</code></pre></div><p>参数 fd 是通过打开这些软链接文件得到的，其中参数 O_RDONLY 代表以只读的方式打开文件。</p><div class=highlight><pre style=color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-c data-lang=c>fd <span style=color:#ff79c6>=</span> open(link_file, O_RDONLY);
</code></pre></div><p>即使一个 namespace 下的所有进程全部结束，我们也可以通过指向该 namespace 的文件描述符 fd 定位并加入其中，这也是 Docker 实现加入已存在 namespace 的最基本方式。</p><h3 id=unshare>unshare()<a href=#unshare class=anchor aria-hidden=true>#</a></h3><p>相比于 clone()，unshare() 不会启动一个新进程，因此可以在原进程中进行一些需要隔离 namespace 的操作。目前 Docker 没有调用这个 api，其原因在下文中将会介绍。</p><h2 id=namespace-隔离的实现方法>Namespace 隔离的实现方法<a href=#namespace-隔离的实现方法 class=anchor aria-hidden=true>#</a></h2><h3 id=utsunix-time-sharing-system>UTS(UNIX Time-sharing System)<a href=#utsunix-time-sharing-system class=anchor aria-hidden=true>#</a></h3><p>Docker 中，每个镜像基本都以自身提供的服务来命名镜像的 hostname，其不会对宿主机产生任何影响，其原理就是利用了 UTS namespace：</p><div class=highlight><pre style=color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-c data-lang=c><span style=color:#ff79c6>#define _GNU_SOURCE
</span><span style=color:#ff79c6>#include</span> <span style=color:#ff79c6>&lt;sys/types.h&gt;</span><span style=color:#ff79c6>
</span><span style=color:#ff79c6>#include</span> <span style=color:#ff79c6>&lt;sys/wait.h&gt;</span><span style=color:#ff79c6>
</span><span style=color:#ff79c6>#include</span> <span style=color:#ff79c6>&lt;stdio.h&gt;</span><span style=color:#ff79c6>
</span><span style=color:#ff79c6>#include</span> <span style=color:#ff79c6>&lt;sched.h&gt;</span><span style=color:#ff79c6>
</span><span style=color:#ff79c6>#include</span> <span style=color:#ff79c6>&lt;signal.h&gt;</span><span style=color:#ff79c6>
</span><span style=color:#ff79c6>#include</span> <span style=color:#ff79c6>&lt;unistd.h&gt;</span><span style=color:#ff79c6>
</span><span style=color:#ff79c6></span>
<span style=color:#ff79c6>#define STACK_SIZE (1024 * 1024)
</span><span style=color:#ff79c6></span><span style=color:#ff79c6>static</span> <span style=color:#8be9fd>char</span> child_stack[STACK_SIZE];
<span style=color:#8be9fd>char</span> <span style=color:#ff79c6>*</span><span style=color:#ff79c6>const</span> child_args[] <span style=color:#ff79c6>=</span> {<span style=color:#f1fa8c>&#34;/bin/bash&#34;</span>, <span style=color:#8be9fd;font-style:italic>NULL</span>};
<span style=color:#6272a4>// 子进程
</span><span style=color:#6272a4></span><span style=color:#8be9fd>int</span> <span style=color:#50fa7b>child_main</span>(<span style=color:#8be9fd>void</span> <span style=color:#ff79c6>*</span>args)
{
    printf(<span style=color:#f1fa8c>&#34;在子进程中、n&#34;</span>);
    <span style=color:#6272a4>// sethostname 将主机名设置为参数 1 的值，参数 2 代表名字的字节数
</span><span style=color:#6272a4></span>    sethostname(<span style=color:#f1fa8c>&#34;NewNamespace&#34;</span>, <span style=color:#bd93f9>12</span>);
    <span style=color:#6272a4>// exec 可以执行用户命令，常使用&#34;/bin/bash&#34;并接受参数，运行起一个 bash
</span><span style=color:#6272a4></span>    execv(child_args[<span style=color:#bd93f9>0</span>], child_args);
    <span style=color:#ff79c6>return</span> <span style=color:#bd93f9>1</span>;
}
<span style=color:#6272a4>// 父进程
</span><span style=color:#6272a4></span><span style=color:#8be9fd>int</span> <span style=color:#50fa7b>main</span>()
{
    printf(<span style=color:#f1fa8c>&#34;程序开始、n&#34;</span>);
    <span style=color:#6272a4>// 创建一个子进程及新的 UTS namespace
</span><span style=color:#6272a4></span>    <span style=color:#6272a4>// 若未指定 SIGCHLD 信号，则在子进程终止时不会通知父进程
</span><span style=color:#6272a4></span>    <span style=color:#8be9fd>int</span> child_pid <span style=color:#ff79c6>=</span> clone(child_main, child_stack <span style=color:#ff79c6>+</span> STACK_SIZE, CLONE_NEWUTS <span style=color:#ff79c6>|</span> SIGCHLD, <span style=color:#8be9fd;font-style:italic>NULL</span>);
    <span style=color:#6272a4>// waitpid 阻塞父进程直到子进程结束
</span><span style=color:#6272a4></span>    waitpid(child_pid, <span style=color:#8be9fd;font-style:italic>NULL</span>, <span style=color:#bd93f9>0</span>);
    printf(<span style=color:#f1fa8c>&#34;已退出、n&#34;</span>);
    <span style=color:#ff79c6>return</span> <span style=color:#bd93f9>0</span>;
}
</code></pre></div><p>编译运行后发现我们在进入子进程的同时，主机名也发生了改变，即进入了一个新创建的 UTS namespace。当我们在子进程中的终端输入 exit 后，子进程便调用 execv() 方法结束进程。于是父进程中的 waitpid() 方法停止阻塞，父进程也随之退出。</p><div class=highlight><pre style=color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-bash data-lang=bash><span style=color:#ff79c6>[</span>root@koktlzz home<span style=color:#ff79c6>]</span><span style=color:#6272a4># ./a.out</span>
程序开始
在子进程中
<span style=color:#ff79c6>[</span>root@NewNamespace home<span style=color:#ff79c6>]</span><span style=color:#6272a4># exit</span>
<span style=color:#8be9fd;font-style:italic>exit</span>
已退出
<span style=color:#ff79c6>[</span>root@koktlzz home<span style=color:#ff79c6>]</span><span style=color:#6272a4># </span>
</code></pre></div><h3 id=ipcinter-process-communication>IPC(Inter-Process Communication)<a href=#ipcinter-process-communication class=anchor aria-hidden=true>#</a></h3><p>两个不同 IPC namespace 下的进程互相不可见，因此也就实现了进程间通信的隔离。其实现方法只需要修改 clone() 方法中的 flag：</p><div class=highlight><pre style=color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-c data-lang=c><span style=color:#8be9fd>int</span> child_pid <span style=color:#ff79c6>=</span> clone(child_main, child_stack <span style=color:#ff79c6>+</span> STACK_SIZE, CLONE_NEWIPC <span style=color:#ff79c6>|</span> SIGCHLD, <span style=color:#8be9fd;font-style:italic>NULL</span>);
</code></pre></div><p>我们可以通过 IPC 资源之一的消息队列来验证 IPC namespace 的隔离，首先创建并查看在当前 namespace 下的所有消息队列：</p><div class=highlight><pre style=color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-c data-lang=c>[root@koktlzz home]# ipcmk <span style=color:#ff79c6>-</span>Q
消息队列 id：<span style=color:#bd93f9>0</span>
[root@koktlzz home]# ipcs <span style=color:#ff79c6>-</span>q

<span style=color:#ff79c6>---------</span> 消息队列 <span style=color:#ff79c6>-----------</span>
键        msqid      拥有者  权限     已用字节数 消息      
<span style=color:#bd93f9>0x3ca3eb5d</span> <span style=color:#bd93f9>0</span>          root       <span style=color:#bd93f9>644</span>        <span style=color:#bd93f9>0</span>            <span style=color:#bd93f9>0</span>           
</code></pre></div><p>然后我们编译运行修改后的程序，再次查看消息队列：</p><div class=highlight><pre style=color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-bash data-lang=bash><span style=color:#ff79c6>[</span>root@koktlzz home<span style=color:#ff79c6>]</span><span style=color:#6272a4># ./a.out</span>
程序开始
在子进程中
<span style=color:#ff79c6>[</span>root@koktlzz home<span style=color:#ff79c6>]</span><span style=color:#6272a4># ipcs -q</span>

--------- 消息队列 -----------
键        msqid      拥有者  权限     已用字节数 消息      

<span style=color:#ff79c6>[</span>root@koktlzz home<span style=color:#ff79c6>]</span><span style=color:#6272a4># exit</span>
<span style=color:#8be9fd;font-style:italic>exit</span>
已退出
</code></pre></div><p>此时可以发现该 IPC namespace 下没有刚刚创建的消息队列，因此也就实现了进程间通信的隔离。</p><h3 id=pid>PID<a href=#pid class=anchor aria-hidden=true>#</a></h3><p>PID namespace 的隔离会将进程的 pid 重新分配，这样两个不同 namespace 下的进程的 pid 即使相同也不会崩溃。内核为所有的 PID namespace 维护了一个进程树，最顶端是系统默认创建的 root namespace。每个被创建的新 PID namespace 成为这个进程树的子节点，而创建者 namespace 就是它的父节点。父节点可以看到子节点中的进程，并且可以通过信号等方式对子节点中的进程产生影响；反之，子节点却无法看到父节点 PID namespace 中的任何内容。其实现方法依然只需要修改 clone() 方法中的 flag：</p><div class=highlight><pre style=color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-c data-lang=c><span style=color:#8be9fd>int</span> child_pid <span style=color:#ff79c6>=</span> clone(child_main, child_stack <span style=color:#ff79c6>+</span> STACK_SIZE, CLONE_NEWPID <span style=color:#ff79c6>|</span> SIGCHLD, <span style=color:#8be9fd;font-style:italic>NULL</span>);
</code></pre></div><p>编译运行后即可看到 PID namespace 隔离的效果：</p><div class=highlight><pre style=color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-bash data-lang=bash><span style=color:#ff79c6>[</span>root@koktlzz home<span style=color:#ff79c6>]</span><span style=color:#6272a4># ./a.out</span>
程序开始
在子进程中
<span style=color:#ff79c6>[</span>root@koktlzz home<span style=color:#ff79c6>]</span><span style=color:#6272a4># echo $$</span>
<span style=color:#bd93f9>1</span>
<span style=color:#ff79c6>[</span>root@koktlzz home<span style=color:#ff79c6>]</span><span style=color:#6272a4># exit</span>
<span style=color:#8be9fd;font-style:italic>exit</span>
已退出
<span style=color:#ff79c6>[</span>root@koktlzz home<span style=color:#ff79c6>]</span><span style=color:#6272a4># echo $$</span>
<span style=color:#bd93f9>2615550</span>
</code></pre></div><p>值得注意的是，即使进入了新的 PID namespace，使用 <strong>ps -ef</strong> 命令依然可以看到所有父进程的 pid。这是因为我们还未实现文件系统挂载点的隔离，而该命令本质调用的是真实系统中的/proc 文件内容，看到的自然是所有的进程。</p><p>调用 unshare() 和 setns() 方法的进程并不会进入新的 PID namespace 中，否则该进程的 PID 发生变化将会导致一些程序（如调用 getpid() 方法）的崩溃。考虑到这一因素，Docker 的 exec 命令不仅调用 setns() 加入已存在的 namespace，还是会调用 clone() 方法创建一个新的进程。</p><h3 id=mount>Mount<a href=#mount class=anchor aria-hidden=true>#</a></h3><p>进程在创建 Mount namespace 时，会把当前文件结构复制给新的 namespace。新 namespace 中所有的 mount 操作都只影响自身的文件系统，对外界不会产生任何影响。而挂载传播则定义了挂载对象之间的关系，包括共享关系和从属关系：</p><ul><li>共享关系：一个挂载对象中的挂载事件会传播到另一个挂载对象，反之亦然；</li><li>从属关系：一个挂载对象中的挂载事件会传播到另一个挂载对象，反之不行。</li></ul><p>其实现方法依然只需要修改 clone() 方法中的 flag，这里加入 CLONE_NEWPID 参数的目的是方便进行验证：</p><div class=highlight><pre style=color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-c data-lang=c><span style=color:#8be9fd>int</span> child_pid <span style=color:#ff79c6>=</span> clone(child_main, child_stack <span style=color:#ff79c6>+</span> STACK_SIZE, CLONE_NEWPID <span style=color:#ff79c6>|</span> CLONE_NEWNS <span style=color:#ff79c6>|</span> SIGCHLD, <span style=color:#8be9fd;font-style:italic>NULL</span>);
</code></pre></div><p>编译并运行程序后，我们发现在重新挂载了/proc 文件 (<strong>mount -t proc proc /proc</strong>) 后的 namespace 中使用 <strong>ps -ef</strong> 命令后就只能看到子进程的 pid 了，并且没有影响到父进程中的/proc 文件挂载。</p><div class=highlight><pre style=color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-bash data-lang=bash><span style=color:#ff79c6>[</span>root@koktlzz home<span style=color:#ff79c6>]</span><span style=color:#6272a4># ./a.out</span>
程序开始
在子进程中
<span style=color:#ff79c6>[</span>root@koktlzz home<span style=color:#ff79c6>]</span><span style=color:#6272a4># mount -t proc proc /proc</span>
<span style=color:#ff79c6>[</span>root@koktlzz home<span style=color:#ff79c6>]</span><span style=color:#6272a4># ps -ef</span>
UID          PID    PPID  C STIME TTY          TIME CMD
root           <span style=color:#bd93f9>1</span>       <span style=color:#bd93f9>0</span>  <span style=color:#bd93f9>0</span> 12:39 pts/1    00:00:00 /bin/bash
root          <span style=color:#bd93f9>17</span>       <span style=color:#bd93f9>1</span>  <span style=color:#bd93f9>0</span> 12:40 pts/1    00:00:00 ps -ef
<span style=color:#ff79c6>[</span>root@koktlzz home<span style=color:#ff79c6>]</span><span style=color:#6272a4># exit</span>
<span style=color:#8be9fd;font-style:italic>exit</span>
已退出
</code></pre></div><h3 id=network>Network<a href=#network class=anchor aria-hidden=true>#</a></h3><p>Network namespace 提供了网络资源的隔离，包括网络设备、IPv4 和 IPv6 协议栈、IP 路由表、防火墙、socket 等。
修改 clone() 方法中的 flag 参数：</p><div class=highlight><pre style=color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-c data-lang=c><span style=color:#8be9fd>int</span> child_pid <span style=color:#ff79c6>=</span> clone(child_main, child_stack <span style=color:#ff79c6>+</span> STACK_SIZE, CLONE_NEWNET <span style=color:#ff79c6>|</span> SIGCHLD, <span style=color:#8be9fd;font-style:italic>NULL</span>);
</code></pre></div><p>编译运行程序后我们发现：在新创建的 Network namespace 中，无法通过 DNS 解析域名，甚至连网卡 eth0 都没有了。这说明网络资源已经完全隔离。</p><div class=highlight><pre style=color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-bash data-lang=bash><span style=color:#ff79c6>[</span>root@koktlzz home<span style=color:#ff79c6>]</span><span style=color:#6272a4># gcc hello.c &amp;&amp; ./a.out</span>
程序开始
在子进程中
<span style=color:#ff79c6>[</span>root@koktlzz home<span style=color:#ff79c6>]</span><span style=color:#6272a4># ping www.baidu.com</span>
ping: www.baidu.com: 未知的名称或服务
<span style=color:#ff79c6>[</span>root@koktlzz home<span style=color:#ff79c6>]</span><span style=color:#6272a4># ip addr</span>
1: lo: &lt;LOOPBACK&gt; mtu <span style=color:#bd93f9>65536</span> qdisc noop state DOWN group default qlen <span style=color:#bd93f9>1000</span>
    link/loopback 00:00:00:00:00:00 brd 00:00:00:00:00:00
<span style=color:#ff79c6>[</span>root@koktlzz home<span style=color:#ff79c6>]</span><span style=color:#6272a4># exit</span>
<span style=color:#8be9fd;font-style:italic>exit</span>
已退出
<span style=color:#ff79c6>[</span>root@koktlzz home<span style=color:#ff79c6>]</span><span style=color:#6272a4># ping www.baidu.com</span>
PING www.a.shifen.com <span style=color:#ff79c6>(</span>180.101.49.12<span style=color:#ff79c6>)</span> 56<span style=color:#ff79c6>(</span>84<span style=color:#ff79c6>)</span> bytes of data.
<span style=color:#bd93f9>64</span> bytes from 180.101.49.12 <span style=color:#ff79c6>(</span>180.101.49.12<span style=color:#ff79c6>)</span>: <span style=color:#8be9fd;font-style:italic>icmp_seq</span><span style=color:#ff79c6>=</span><span style=color:#bd93f9>1</span> <span style=color:#8be9fd;font-style:italic>ttl</span><span style=color:#ff79c6>=</span><span style=color:#bd93f9>49</span> <span style=color:#8be9fd;font-style:italic>time</span><span style=color:#ff79c6>=</span>9.96 ms
<span style=color:#bd93f9>64</span> bytes from 180.101.49.12 <span style=color:#ff79c6>(</span>180.101.49.12<span style=color:#ff79c6>)</span>: <span style=color:#8be9fd;font-style:italic>icmp_seq</span><span style=color:#ff79c6>=</span><span style=color:#bd93f9>2</span> <span style=color:#8be9fd;font-style:italic>ttl</span><span style=color:#ff79c6>=</span><span style=color:#bd93f9>49</span> <span style=color:#8be9fd;font-style:italic>time</span><span style=color:#ff79c6>=</span>9.93 ms
</code></pre></div><p>Docker 采用 CNM(Container Network Model) 实现 network namespace 隔离，CNM 主要由三个部分构成：</p><ul><li>沙盒（sanbox）：network namespace</li><li>端点（endpoint）：veth-pair</li><li>网络（network）：linux bridge 或 vlan</li></ul><p>对于 Docker 来说，linux bridge 便是 docker0。veth 相当于网桥上的端口，它工作在链路层不需要配置 IP。而 docker0 自身的 IP 默认为 172.17.0.1/16，即容器的默认网关地址。所有容器都会在 docker0 的子网范围内选取一个未占用的 ip 使用，并通过 veth-pair 连接到 docker0。</p><p><img src=https://cdn.jsdelivr.net/gh/koktlzz/ImgBed@master/20210131140833.png alt=20210131140833></p><p>Docker daemon 创建容器网络的过程如下：</p><ul><li>首先由 Docker daemon 负责创建一个虚拟网络对 veth-pair。一端绑定到 docker0 网桥上，另一端接入容器中。</li><li>容器内部的初始化进程（即 init 进程）在管道一端循环等待，直到 Docker daemon 从管道另一端向其传输关于 veth-pair 设备的信息，随后关闭管道。</li><li>最后，init 进程结束等待，启动它的虚拟网卡"eth0"。</li></ul><h3 id=user>User<a href=#user class=anchor aria-hidden=true>#</a></h3><p>一个普通用户的进程通过 clone() 方法创建的子进程可以在这个新的 User namespace 中拥有不同的用户和用户组，这意味着容器内部的 root 用户可能在宿主机上只是一个普通用户，从而为容器提高了极大的自由。User namespace 与 PID namespace 类似，同样是一个层层嵌套的树状结构。</p><p>其实现方法依然是在 flag 参数中加入 CLONE_NEWUSER 创建一个新的 User namespace（）:</p><div class=highlight><pre style=color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-c data-lang=c><span style=color:#8be9fd>int</span> child_pid <span style=color:#ff79c6>=</span> clone(child_main, child_stack <span style=color:#ff79c6>+</span> STACK_SIZE, CLONE_NEWUSER <span style=color:#ff79c6>|</span> SIGCHLD, <span style=color:#8be9fd;font-style:italic>NULL</span>);
</code></pre></div><p>编译运行后我们可以发现，在创建的新 User namespace 中，user 和 group 变成了 nobody，uid 和 gid 也随之改变。</p><div class=highlight><pre style=color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-bash data-lang=bash><span style=color:#ff79c6>[</span>root@koktlzz home<span style=color:#ff79c6>]</span><span style=color:#6272a4># ./a.out</span>
程序开始
在子进程中
<span style=color:#ff79c6>[</span>nobody@koktlzz home<span style=color:#ff79c6>]</span>$ id
<span style=color:#8be9fd;font-style:italic>uid</span><span style=color:#ff79c6>=</span>65534<span style=color:#ff79c6>(</span>nobody<span style=color:#ff79c6>)</span> <span style=color:#8be9fd;font-style:italic>gid</span><span style=color:#ff79c6>=</span>65534<span style=color:#ff79c6>(</span>nobody<span style=color:#ff79c6>)</span> <span style=color:#8be9fd;font-style:italic>组</span><span style=color:#ff79c6>=</span>65534<span style=color:#ff79c6>(</span>nobody<span style=color:#ff79c6>)</span>
<span style=color:#ff79c6>[</span>nobody@koktlzz home<span style=color:#ff79c6>]</span>$ <span style=color:#8be9fd;font-style:italic>exit</span>
<span style=color:#8be9fd;font-style:italic>exit</span>
已退出
<span style=color:#ff79c6>[</span>root@koktlzz home<span style=color:#ff79c6>]</span><span style=color:#6272a4># id</span>
<span style=color:#8be9fd;font-style:italic>uid</span><span style=color:#ff79c6>=</span>0<span style=color:#ff79c6>(</span>root<span style=color:#ff79c6>)</span> <span style=color:#8be9fd;font-style:italic>gid</span><span style=color:#ff79c6>=</span>0<span style=color:#ff79c6>(</span>root<span style=color:#ff79c6>)</span> <span style=color:#8be9fd;font-style:italic>组</span><span style=color:#ff79c6>=</span>0<span style=color:#ff79c6>(</span>root<span style=color:#ff79c6>)</span>
</code></pre></div><p>除此之外，我们还要把子节点 namespace 中的初始 user 与其父节点 namespace 中的某个用户建立映射关系。这样子节点 User namespace 想要给父节点 User namespace 发送一个信号或操作某一个文件时，系统就会判断子节点中的用户在父节点中是否有对应的权限。这是通过在 <strong>/proc/[pid]/uid_map</strong>和 <strong>/proc/[pid]/gid_map</strong>文件中写入对应的映射信息实现的，以 uid_map 为例：</p><div class=highlight><pre style=color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-c data-lang=c><span style=color:#8be9fd>void</span> <span style=color:#50fa7b>set_uid_map</span>(pid_t pid, <span style=color:#8be9fd>int</span> inside_id, <span style=color:#8be9fd>int</span> outside_id, <span style=color:#8be9fd>int</span> length)
{
    <span style=color:#8be9fd>char</span> path[<span style=color:#bd93f9>256</span>];
    sprintf(path, <span style=color:#f1fa8c>&#34;/proc/%d/uid_map&#34;</span>, getpid());
    FILE <span style=color:#ff79c6>*</span>uid_map <span style=color:#ff79c6>=</span> fopen(path, <span style=color:#f1fa8c>&#34;w&#34;</span>);
    <span style=color:#6272a4>// inside_id 表示新建的 User namespace 中对应的 uid/gid
</span><span style=color:#6272a4></span>    <span style=color:#6272a4>// outside_id 表示 namespace 外部映射的 uid/gid
</span><span style=color:#6272a4></span>    <span style=color:#6272a4>// length 表示映射范围，通常为 1，表示只映射一个
</span><span style=color:#6272a4></span>    fprintf(uid_map, <span style=color:#f1fa8c>&#34;%d %d %d&#34;</span>, inside_id, outside_id, length);
    fclose(uid_map);
}
</code></pre></div><p class=edit-page><a href=https://github.com/koktlzz/koktlzz.github.io/blob/master/content/Container/Docker/Namespace%e9%9a%94%e7%a6%bb.md><svg xmlns="http://www.w3.org/2000/svg" width="16" height="16" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="feather feather-edit-2"><path d="M17 3a2.828 2.828.0 114 4L7.5 20.5 2 22l1.5-5.5L17 3z"/></svg>Edit this page on GitHub</a></p><div class="docs-navigation d-flex justify-content-between"><a href=https://koktlzz.github.io/container/docker/dockercompose/><div class="card my-1"><div class="card-body py-2">&larr; Docker Compose</div></div></a><a class=ms-auto href=https://koktlzz.github.io/container/docker/cgroups%E9%9A%94%E7%A6%BB/><div class="card my-1"><div class="card-body py-2">CGroups 隔离 &rarr;</div></div></a></div><script src=https://utteranc.es/client.js repo=koktlzz/koktlzz.github.io issue-term=pathname theme=photon-dark crossorigin=anonymous async></script></main><nav class="docs-toc d-none d-xl-block col-lg-3 col-xl-2" aria-label="Secondary navigation"><div class=page-links><h3>On this page</h3><nav id=TableOfContents><ul><li><a href=#简介>简介</a></li><li><a href=#进行-namespace-api-操作的方式>进行 Namespace API 操作的方式</a><ul><li><a href=#clone>clone()</a></li><li><a href=#setns>setns()</a></li><li><a href=#unshare>unshare()</a></li></ul></li><li><a href=#namespace-隔离的实现方法>Namespace 隔离的实现方法</a><ul><li><a href=#utsunix-time-sharing-system>UTS(UNIX Time-sharing System)</a></li><li><a href=#ipcinter-process-communication>IPC(Inter-Process Communication)</a></li><li><a href=#pid>PID</a></li><li><a href=#mount>Mount</a></li><li><a href=#network>Network</a></li><li><a href=#user>User</a></li></ul></li></ul></nav></div></nav></div></div></div><footer class="footer text-muted"><div class=container><div class=row><div class="col-lg-8 order-last order-lg-first"><ul class=list-inline><li class=list-inline-item></li></ul></div><div class="col-lg-8 order-first order-lg-last text-lg-end"><ul class=list-inline></ul></div></div></div></footer><script src=https://koktlzz.github.io/js/bootstrap.min.d67050adf5d370668aede4201f82af781b16970934804995a1ca37c1ee9222c2fc530972aa6d5d2b6124caf1fe318f139aac99df2c1e89af65504fc1185c7972.js integrity="sha512-1nBQrfXTcGaK7eQgH4KveBsWlwk0gEmVoco3we6SIsL8Uwlyqm1dK2EkyvH+MY8TmqyZ3yweia9lUE/BGFx5cg==" crossorigin=anonymous defer></script><script src=https://koktlzz.github.io/js/vendor/katex/dist/katex.min.b334e5b00c45f572e7f38a543046f36854bf4cbb543880480c09271a0efedc694d6905f719934f6ede2f26f52e80411c05b90121d722cbf8be2fa8fc51bc6b81.js integrity="sha512-szTlsAxF9XLn84pUMEbzaFS/TLtUOIBIDAknGg7+3GlNaQX3GZNPbt4vJvUugEEcBbkBIdciy/i+L6j8UbxrgQ==" crossorigin=anonymous defer></script><script src=https://koktlzz.github.io/js/vendor/katex/dist/contrib/auto-render.min.916823ec103cf367b71e28a6f01513cb9c3ac6708ccb5229402ec46b8e30a8b25003db694df35d80e9dd666a371f327c6152790617b6256390c164109a90bd4c.js integrity="sha512-kWgj7BA882e3Hiim8BUTy5w6xnCMy1IpQC7Ea44wqLJQA9tpTfNdgOndZmo3HzJ8YVJ5Bhe2JWOQwWQQmpC9TA==" crossorigin=anonymous defer></script><script src=https://koktlzz.github.io/main.min.1febbf2f6fd6a36fc2f57dd50d7935fbb640743329baeb4ef7cefcf2e7630e413371fbba976e103656b82808ee227dc4a84237edb0f8433648bef3a56900661a.js integrity="sha512-H+u/L2/Wo2/C9X3VDXk1+7ZAdDMpuutO98788udjDkEzcfu6l24QNla4KAjuIn3EqEI37bD4QzZIvvOlaQBmGg==" crossorigin=anonymous defer></script></body></html>