<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>Containers on</title><link>https://koktlzz.github.io/container/</link><description>Recent content in Containers on</description><generator>Hugo -- gohugo.io</generator><language>en-US</language><lastBuildDate>Wed, 24 Feb 2021 22:05:45 +0800</lastBuildDate><atom:link href="https://koktlzz.github.io/container/index.xml" rel="self" type="application/rss+xml"/><item><title>Getting Started</title><link>https://koktlzz.github.io/container/docker/intro/</link><pubDate>Wed, 24 Feb 2021 22:05:45 +0800</pubDate><guid>https://koktlzz.github.io/container/docker/intro/</guid><description>官方网站 https://www.docker.com/
推荐阅读 Docker——容器与容器云（第 2 版）
Docker 核心技术与实现原理</description></item><item><title>狂神 Docker 课程笔记</title><link>https://koktlzz.github.io/container/docker/%E7%8B%82%E7%A5%9Edocker%E8%AF%BE%E7%A8%8B%E7%AC%94%E8%AE%B0/</link><pubDate>Wed, 24 Feb 2021 22:05:45 +0800</pubDate><guid>https://koktlzz.github.io/container/docker/%E7%8B%82%E7%A5%9Edocker%E8%AF%BE%E7%A8%8B%E7%AC%94%E8%AE%B0/</guid><description>课程链接 https://www.bilibili.com/video/BV1og4y1q7M4?from=search&amp;amp;seid=18106350651153543104
Docker 为什么出现？ 开发和运维两套环境，而环境配置十分麻烦。 如在 Windows 上开发，要发布到 Linux 上运行。Docker 给以上问题提出了解决方案： Java &amp;mdash; Jar（环境）&amp;mdash;打包项目带上环境（镜像）&amp;mdash;Docker 仓库（应用商店）&amp;mdash;下载镜像&amp;mdash;直接运行 Docker 的思想来自于集装箱，核心思想：隔离。 即将应用打包装箱，每个箱子是互相隔离的，可以将服务器利用到极致。 官方文档 仓库地址 Docker 能做什么？ 传统虚拟机与 Docker 对比 Docker 的优点 不模拟完整的操作系统，系统内核（kernel）非常小，更少的抽象层（GuestOS：如 Centos） 容器内的应用直接运行在宿主机的内核，容器本身没有自己的内核，也没有虚拟硬件。 每个容器相互隔离，内部都有属于自己的文件系统，互不影响。 Docker 实现 DevOps 应用更快速的交付和部署 打包镜像发布测试，一键运行；不再需要写大量帮助文档，安装程序 更便捷的升级和扩缩容？ 部署应用就和搭积木一样 更简单的系统运维 开发和测试的环境高度一致 更高效的计算资源利用 内核级别的虚拟化，可以在一个物理机上运行很多的容器实例，服务器性能可以被压榨到极致。 Docker 的基本组成 镜像（image）：镜像是一种轻量级、可执行的独立软件包，用来打包软件运行环境和基于运行环境开发的软件。它包含运行某个软件所需的所有内容，包括代码、运行时、库、环境变量和配置文件。相当于一个模板，通过这个模板来创建容器服务，可以通过一个镜像创建多个容器。 容器（container）：独立运行一个或一组应用/基本命令有：启动，停止，删除等。可理解为一个简单的 linux 系统。 仓库（repository）：存放镜像的地方（公有/私有） Docker 运行原理 Docker 是一个 Client-Server 结构的系统，以守护进程运行在主机上。通过 Socket 从客户端进行访问。
Docker 的常用命令 帮助命令 docker --help # 帮助信息 docker info # 系统信息，包括镜像和容器的数量 帮助文档地址：https://docs.</description></item><item><title>Docker Compose</title><link>https://koktlzz.github.io/container/docker/dockercompose/</link><pubDate>Wed, 24 Feb 2021 22:05:45 +0800</pubDate><guid>https://koktlzz.github.io/container/docker/dockercompose/</guid><description>简介 学习了 Docker 基础知识 后，我们已经可以使用 Dockerfile 和 docker build 命令创建一个镜像，并使用 docker run 命令运行一个容器。但如果想要同时运行多个容器，并建立容器之间的依赖关系，仅仅依靠上述的命令就显得十分复杂。因此，我们需要一个新的工具能够高效地对多个容器进行运行管理（批量容器编排），这便是 Docker Compose。
官方文档：
Compose is a tool for defining and running multi-container Docker applications. With Compose, you use a YAML file to configure your application’s services. Then, with a single command, you create and start all the services from your configuration. To learn more about all the features of Compose, see the list of features. Compose works in all environments: production, staging, development, testing, as well as CI workflows.</description></item><item><title>Namespace 隔离</title><link>https://koktlzz.github.io/container/docker/namespace%E9%9A%94%E7%A6%BB/</link><pubDate>Wed, 24 Feb 2021 22:05:45 +0800</pubDate><guid>https://koktlzz.github.io/container/docker/namespace%E9%9A%94%E7%A6%BB/</guid><description>简介 在 Linux 中可以使用 lsns 命令查看系统中的所有 namespace：
[root@koktlzz ~]# lsns NS TYPE NPROCS PID USER COMMAND 4026531835 cgroup 94 1 root /usr/lib/systemd/systemd --switched-root --system --deserialize 17 4026531836 pid 94 1 root /usr/lib/systemd/systemd --switched-root --system --deserialize 17 4026531837 user 94 1 root /usr/lib/systemd/systemd --switched-root --system --deserialize 17 4026531838 uts 94 1 root /usr/lib/systemd/systemd --switched-root --system --deserialize 17 4026531839 ipc 94 1 root /usr/lib/systemd/systemd --switched-root --system --deserialize 17 4026531840 mnt 88 1 root /usr/lib/systemd/systemd --switched-root --system --deserialize 17 4026531860 mnt 1 16 root kdevtmpfs 4026531992 net 94 1 root /usr/lib/systemd/systemd --switched-root --system --deserialize 17 4026532193 mnt 1 599 root /usr/lib/systemd/systemd-udevd 4026532195 mnt 2 693 root /sbin/auditd 4026532196 mnt 1 782 chrony /usr/sbin/chronyd 4026532197 mnt 1 893 root /usr/sbin/NetworkManager --no-daemon Namespace 系统调用参数 隔离内容 应用意义 UTS CLONE_NEWUTS 主机与域名 每个容器在网络中可以被视作一个独立的节点，而非宿主机的一个进程 IPC CLONE_NEWIPC 信号量、消息队列和共享内存 隔离容器间、容器与宿主机之间的进程间通信 PID CLONE_NEWPID 进程编号 隔离容器间、容器与宿主机之间的进程 PID Network CLONE_NEWNET 网络设备、网络栈、端口等 避免产生容器间、容器与宿主机之间产生端口已占用的问题 Mount CLONE_NEWNS 挂载点（文件系统） 容器间、容器与宿主机之间的文件系统互不影响 User CLONE_NEWUSER 用户和用户组 普通用户（组）在容器内部也可以成为超级用户（组），从而进行权限管理 进行 Namespace API 操作的方式 clone() clone() 可以在创建新进程（子进程）的同时创建 namespace，是 Docker 使用 namespace 最基本的方法。</description></item><item><title>CGroups 隔离</title><link>https://koktlzz.github.io/container/docker/cgroups%E9%9A%94%E7%A6%BB/</link><pubDate>Wed, 24 Feb 2021 22:05:45 +0800</pubDate><guid>https://koktlzz.github.io/container/docker/cgroups%E9%9A%94%E7%A6%BB/</guid><description>作用 cgroups(controll groups) 可以把一系列系统任务及其子任务（线程/进程）划分为等级不同的组，从而对任务组使用的物理资源（CPU、内存、IO 等）进行限制和记录。
资源限制：对任务使用的资源总额进行限制，一旦超过这个配额就发出相关提示； 优先级分配：通过分配的 CPU 时间片数量及磁盘 IO 带宽大小，实际上就相当于控制了任务运行的优先级； 资源统计：cgroups 可以统计系统的资源使用量，如 CPU 使用时长，内存用量等； 任务控制：cgroups 可以对任务执行挂起、恢复等操作。 组织结构 cgroups 的组织结构中有以下几种元素：
任务（task）：系统的一个进程或线程；
控制组（cgroup）：按某种资源控制标准划分而成的任务组，一个任务可以加入某个 cgroup，也可以在不同 cgroup 中迁移；
子系统（subsystem）：即资源调度器，如 CPU 子系统可以控制 CPU 时间分配；
层级（hierarchy）：由一系列控制组以一个树状结构排列而成，每个层级通过绑定对应的子系统进行资源控制。
它们之间的关系需要遵循一定的规则：
同一个层级可以绑定多个子系统； 一个已经有层级绑定的子系统，不能附加到其他含有别的子系统的层级之上； 一个任务不能存在于同一层级的不同控制组中； 调用 fork() 或 clone() 方法后，父子任务（进程）的控制组互不影响。 在上图的 cgroups 结构中，左侧的层级同时绑定了 CPU 子系统和 Memory 子系统；由于此时 Memory 子系统已经有层级绑定，因此无法附加到一个已经绑定了 Net_ls 子系统的层级上；如果任务 task1 处于左侧层级下的 cg1 控制组中，那么便无法加入同一层级下的 cg2 控制组，但是可以加入右侧层级的 cg3 控制中。</description></item><item><title>镜像与容器</title><link>https://koktlzz.github.io/container/docker/%E9%95%9C%E5%83%8F%E4%B8%8E%E5%AE%B9%E5%99%A8/</link><pubDate>Wed, 24 Feb 2021 22:05:45 +0800</pubDate><guid>https://koktlzz.github.io/container/docker/%E9%95%9C%E5%83%8F%E4%B8%8E%E5%AE%B9%E5%99%A8/</guid><description>镜像 Docker 镜像是一个只读的容器模板，含有启动 Docker 容器所需的文件系统。Docker 镜像的文件内容和一些运行容器的配置文件组成了 Docker 容器的文件系统运行环境——rootfs。
当我们使用 docker pull 下载一个 nginx 镜像后，可以在 Docker 的工作目录 /var/lib/docker/image/overlay2 下找到它的相关信息（路径中的 overlay2 是 Docker 目前使用的一种存储驱动，我们后面会详细讲解这项技术）：
[root@localhost ~]# docker images REPOSITORY TAG IMAGE ID CREATED SIZE nginx latest f6d0b4767a6c 3 weeks ago 133MB [root@localhost ~]# ls /var/lib/docker/image/overlay2 distribution imagedb layerdb repositories.json Repository 在 Docker 的镜像管理系统中，registry 代表镜像仓库，如官方的 Docker Hub。而 repository 则代表镜像组，即包含了不同版本的镜像集合。repositories.json 文件中描述了宿主机上所有镜像的 repository 元数据，主要包括镜像名、tag 和镜像 ID。而镜像 ID 是 Docker 采用 SHA256 算法，根据镜像元数据配置文件计算得出的。
[root@localhost ~]# cat /var/lib/docker/image/overlay2/repositories.</description></item><item><title>Getting Started</title><link>https://koktlzz.github.io/container/kubernetes/intro/</link><pubDate>Wed, 04 Nov 2020 09:19:42 +0100</pubDate><guid>https://koktlzz.github.io/container/kubernetes/intro/</guid><description>官方网站 https://kubernetes.io/
推荐阅读 官方文档
Kubernetes 教程｜Kuboard
Kubernetes Overview Diagrams
Kubernetes - 面向信仰编程</description></item><item><title>Infrastructure</title><link>https://koktlzz.github.io/container/kubernetes/infrastructure/</link><pubDate>Wed, 04 Nov 2020 09:19:42 +0100</pubDate><guid>https://koktlzz.github.io/container/kubernetes/infrastructure/</guid><description>架构 基本特性 声明式：Kubernetes 中常用 yaml 文件定义服务和资源的拓扑结构和状态，它是一种声明式的编程方式，更加关注状态和结果。其实我们最常接触的是命令式编程，它要求我们描述为了达到某一个效果或者目标所需要完成的指令。常见的编程语言 Go、Ruby、C++ 以及我们使用的 kubectl 工具其实都属于命令式的编程方法； 显式接口：不存在内部的私有接口； 无侵入：每一个应用或者服务一旦被打包成了镜像就可以直接在 Kubernetes 中无缝使用，不需要修改应用程序中的任何代码； 可移植：支持有状态服务的迁移和持久化存储。 组件 Master 组件 etcd：保存了整个集群的状态； Api-server：负责处理来自用户的请求，其主要作用就是对外提供 RESTful 的接口。包括用于查看集群状态的读请求以及改变集群状态的写请求，也是唯一一个与 etcd 集群通信的组件； Controller-manager：运行了一系列的 Controller 进程，它们会按照用户的期望状态在后台不断地调节整个集群中的对象。当服务的状态发生了改变，控制器就会发现这个改变并且开始向目标状态迁移。每种资源都有其对应的 Controller； Scheduler：负责资源的调度，采用预算策略或优选策略将 Pod 调度到合适的节点上。 Node 组件 Kubelet：负责维持容器的生命周期，同时也负责 Volume（CVI）和网络（CNI）的管理。它周期性地从 API Server 获取 Pod 的 Spec，并确保容器处于运行状态且保持健康； Kube-proxy：负责为 Service 提供集群内部的服务发现和负载均衡； Container Runtime：负责运行容器的软件，如 Docker、CRI-O 以及所有实现 Kubernetes CRI（Container Runtime Interface）的应用。 Client 组件 kubeadm：部署工具，提供 kubeadm init 和 kubeadm join，用于快速部署 Kubernetes 集群； kubectl：用户或开发者使用的命令行工具。 插件 Addons CoreDNS：负责为整个集群提供 DNS 服务； Ingress Controller：为 Service 提供从集群外部访问的入口； Heapster：提供资源监控； Dashboard：提供 GUI； Federation：提供跨可用区的集群； Fluentd/Elasticsearch：提供集群日志采集、存储与查询； Prometheus：提供集群的监控能力。 资源与对象 Kubernetes 中的所有内容都被抽象为“资源”，如 Pod、Service、Node 等都是资源。“对象”就是“资源”的实例，是持久化的实体。如某个具体的 Pod、某个具体的 Node。Kubernetes 使用这些实体去表示整个集群的状态。 对象的创建、删除、修改都是通过 Kubernetes API，也就是 Api Server 组件提供的 API 接口，这些是 RESTful 风格的 Api，与 k8s 的万物皆对象理念相符。命令行工具 kubectl，实际上也是调用 kubernetes api。 Kubernetes REST API 中的所有对象都用 Name 和 UID 来明确地标识。</description></item><item><title>Pod 与 Namespace</title><link>https://koktlzz.github.io/container/kubernetes/pod%E4%B8%8Enamespace/</link><pubDate>Wed, 04 Nov 2020 09:19:42 +0100</pubDate><guid>https://koktlzz.github.io/container/kubernetes/pod%E4%B8%8Enamespace/</guid><description>Pod 基本特性 Pod 是 Kubernetes 中的最小单位，由一个或一组容器组成。一个容器中运行一个进程，而一个 Pod 运行多个进程； 为实现亲密性应用，Pod 内部的容器共享网络和挂载卷，因此可以方便地实现多个应用间交互； 每一个 Pod 其实都具有两种不同的容器，一种是 Init 容器：在 Pod 启动时运行，主要用于初始化一些配置。另一种是 Pod 在 Running 状态时内部存活的应用容器，它们的主要作用是对外提供服务或者作为工作节点处理异步任务等； Pod 的生命周期短暂。 Spec 和 Status 以一个名为 busybox 的 Pod 为例：
apiVersion: v1 kind: Pod metadata: name: busybox labels: app: busybox spec: containers: - image: busybox command: - sleep - &amp;#34;3600&amp;#34; resources: requests: cpu: &amp;#34;500m&amp;#34; memory: &amp;#34;512Mi&amp;#34; limits: cpu: &amp;#34;500m&amp;#34; memory: &amp;#34;512Mi&amp;#34; imagePullPolicy: IfNotPresent name: busybox restartPolicy: Always Pod 的 Spec 指定了 Pod 中包含的容器以及容器的镜像、启动命令等信息，上述例子中还包括了镜像拉取策略、容器资源限制以及 Pod 重启策略。 而每一个 Pod 的 Status 包含了生命周期、当前服务状态、宿主机和 Pod 的 IP 地址以及其中内部所有容器的状态信息等：</description></item><item><title>Service</title><link>https://koktlzz.github.io/container/kubernetes/service/</link><pubDate>Wed, 04 Nov 2020 09:19:42 +0100</pubDate><guid>https://koktlzz.github.io/container/kubernetes/service/</guid><description>概述 Kubernetes 使用 Service 解决服务发现问题：每个 Pod 在创建后都会被分配一个 IP 地址，然而它会随着 Pod 的重启而改变； Service 可以通过标签选择器选择一组 Pod，然后作为它们共同的对外访问接口。这样我们的应用便可以在不知道 Pod 的 IP 地址的情况下，与其通信； 当 Service 的标签选择器选择了多个 Pod 时，还可以在它们之间做负载均衡； 众所周知，Service 的中文意为“服务”。但就其功能而言，更像是一个 Proxy（代理）或 Router（路由）。 配置 一个典型的 Service 对象配置如下：
kind: Service apiVersion: v1 metadata: name: nginx-server spec: clusterIP: 192.168.1.0 selector: app: nginx ports: - name: http protocol: TCP port: 80 targetPort: 9376 - name: https protocol: TCP port: 443 targetPort: 9377 每个 Service 都会由系统分配一个虚拟 IP 作为访问 Service 的入口 IP 地址，然后监听spec.</description></item></channel></rss>