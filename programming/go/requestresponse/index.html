<!doctype html><html lang=en-us><head><script async src="https://www.googletagmanager.com/gtag/js?id=G-D022F6NT2P"></script><script>window.dataLayer=window.dataLayer||[];function gtag(){dataLayer.push(arguments)}gtag('js',new Date),gtag('config','G-D022F6NT2P')</script><script>(function(b,d,e,a,g){b[a]=b[a]||[],b[a].push({'gtm.start':(new Date).getTime(),event:'gtm.js'});var f=d.getElementsByTagName(e)[0],c=d.createElement(e),h=a!='dataLayer'?'&l='+a:'';c.async=!0,c.src='https://www.googletagmanager.com/gtm.js?id='+g+h,f.parentNode.insertBefore(c,f)})(window,document,'script','dataLayer','GTM-P72R45W')</script><meta charset=utf-8><meta http-equiv=x-ua-compatible content="ie=edge"><meta name=viewport content="width=device-width,initial-scale=1,shrink-to-fit=no"><link rel=preload as=font href=https://koktlzz.github.io/fonts/vendor/jost/jost-v4-latin-regular.woff2 type=font/woff2 crossorigin><link rel=preload as=font href=https://koktlzz.github.io/fonts/vendor/jost/jost-v4-latin-700.woff2 type=font/woff2 crossorigin><link rel=preload as=font href=https://koktlzz.github.io/fonts/KaTeX_Main-Regular.woff2 type=font/woff2 crossorigin><link rel=preload as=font href=https://koktlzz.github.io/fonts/KaTeX_Math-Italic.woff2 type=font/woff2 crossorigin><link rel=stylesheet href=https://koktlzz.github.io/main.27967119d9bfd1f18848f648c47494cdf9c8666df2bb5d54d01736bacd6e74dc5f8b9b2cbc827df0fc8e4cef4f4bae41b13b93c84017caf5272a107d6f2af5cc.css integrity="sha512-J5ZxGdm/0fGISPZIxHSUzfnIZm3yu11U0Bc2us1udNxfi5ssvIJ98PyOTO9PS65BsTuTyEAXyvUnKhB9byr1zA==" crossorigin=anonymous><noscript><style>img.lazyload{display:none}</style></noscript><meta name=robots content="index, follow"><meta name=googlebot content="index, follow, max-snippet:-1, max-image-preview:large, max-video-preview:-1"><meta name=bingbot content="index, follow, max-snippet:-1, max-image-preview:large, max-video-preview:-1"><title>Request & Response | KnowledgeBase</title><meta name=description content><link rel=canonical href=https://koktlzz.github.io/programming/go/requestresponse/><meta property="og:locale" content="en_US"><meta property="og:type" content="article"><meta property="og:title" content="Request & Response"><meta property="og:description" content="http.Request 结构  请求行（请求方法/URL/协议） 0 个或多个 Header 空行 可选的消息体 (Body)  例如：
GET www.baidu.com HTTP/1.1 Host: www.w3.org User-Agent: Mozilla/5.0 （空行） （无消息体） 读取查询参数 常见的 URL 的结构为：
scheme://[userinfo@]host/path[?query][#fragment] 使用 Request.URL 的 Query 方法即可得到 URL 中的查询参数：
fmt.Println(r.URL.Query()) 若请求的 URL 为：http://localhost:8080?name=kokt&age=3 , 则控制台输出：
map[age:[3] name:[kokt]] 读取请求头 type Header map[string][]string 可以使用 Request.Header[key] 或 Request.Header.Get(key) 获取请求头中的值。前者返回值类型是 []string，后者返回值类型为 string（不同值以逗号分隔）。
读取消息体 func obtainBody(w http.ResponseWriter, r *http.Request) { length := r.ContentLength body := make([]byte, length) // r.Body 是一个 io.ReadCloser 类型  r."><meta property="og:url" content="https://koktlzz.github.io/programming/go/requestresponse/"><meta property="og:site_name" content="KnowledgeBase"><meta property="article:published_time" content="2020-11-04T09:19:42+01:00"><meta property="article:modified_time" content="2020-11-04T09:19:42+01:00"><meta property="og:image" content="https://koktlzz.github.io/doks.png"><meta property="og:image:alt" content="KnowledgeBase"><meta name=twitter:card content="summary_large_image"><meta name=twitter:site content="@getdoks"><meta name=twitter:creator content="@henkverlinde"><meta name=twitter:title content="Request & Response"><meta name=twitter:description content><meta name=twitter:image content="https://koktlzz.github.io/doks.png"><meta name=twitter:image:alt content="Request & Response"><script type=application/ld+json>{"@context":"https://schema.org","@graph":[{"@type":"Organization","@id":"https://koktlzz.github.io/#/schema/organization/1","name":"Doks","url":"https://koktlzz.github.io/","sameAs":["https://twitter.com/getdoks","https://github.com/h-enk/doks"],"logo":{"@type":"ImageObject","@id":"https://koktlzz.github.io/#/schema/image/1","url":"https://koktlzz.github.io/logo-doks.png","width":512,"height":512,"caption":"Doks"},"image":{"@id":"https://koktlzz.github.io/#/schema/image/1"}},{"@type":"WebSite","@id":"https://koktlzz.github.io/#/schema/website/1","url":"https://koktlzz.github.io/","name":"KnowledgeBase","description":"","publisher":{"@id":"https://koktlzz.github.io/#/schema/organization/1"}},{"@type":"WebPage","@id":"https://koktlzz.github.io/programming/go/requestresponse/","url":"https://koktlzz.github.io/programming/go/requestresponse/","name":"Request \u0026 Response","description":"","isPartOf":{"@id":"https://koktlzz.github.io/#/schema/website/1"},"about":{"@id":"https://koktlzz.github.io/#/schema/organization/1"},"datePublished":"2020-11-04T09:19:42CET","dateModified":"2020-11-04T09:19:42CET","breadcrumb":{"@id":"https://koktlzz.github.io/programming/go/requestresponse/#/schema/breadcrumb/1"},"primaryImageOfPage":{"@id":"https://koktlzz.github.io/programming/go/requestresponse/#/schema/image/2"},"inLanguage":"en-US","potentialAction":[{"@type":"ReadAction","target":["https://koktlzz.github.io/programming/go/requestresponse/"]}]},{"@type":"BreadcrumbList","@id":"https://koktlzz.github.io/programming/go/requestresponse/#/schema/breadcrumb/1","name":"Breadcrumbs","itemListElement":[{"@type":"ListItem","position":1,"item":{"@type":"WebPage","@id":"https://koktlzz.github.io/","url":"https://koktlzz.github.io/","name":"Home"}},{"@type":"ListItem","position":2,"item":{"@type":"WebPage","@id":"https://koktlzz.github.io/programming/","url":"https://koktlzz.github.io/programming/","name":"Programming"}},{"@type":"ListItem","position":3,"item":{"@type":"WebPage","@id":"https://koktlzz.github.io/programming/go/","url":"https://koktlzz.github.io/programming/go/","name":"Go"}},{"@type":"ListItem","position":4,"item":{"@id":"https://koktlzz.github.io/programming/go/requestresponse/"}}]},{"@context":"https://schema.org","@graph":[{"@type":"ImageObject","@id":"https://koktlzz.github.io/programming/go/requestresponse/#/schema/image/2","url":"https://koktlzz.github.io/doks.png","contentUrl":"https://koktlzz.github.io/doks.png","caption":"Request \u0026 Response"}]}]}</script><meta name=theme-color content="#fff"><link rel=apple-touch-icon sizes=180x180 href=https://koktlzz.github.io/apple-touch-icon.png><link rel=icon type=image/png sizes=32x32 href=https://koktlzz.github.io/favicon-32x32.ico><link rel=icon type=image/png sizes=16x16 href=https://koktlzz.github.io/favicon-16x16.ico><link rel=manifest crossorigin=use-credentials href=https://koktlzz.github.io/site.webmanifest></head><body class="Programming single dark"><noscript><iframe src="https://www.googletagmanager.com/ns.html?id=GTM-P72R45W" height=0 width=0 style=display:none;visibility:hidden></iframe></noscript><div class="header-bar fixed-top"></div><header class="navbar fixed-top navbar-expand-md navbar-light"><div class=container-fluid><input class="menu-btn order-0" type=checkbox id=menu-btn>
<label class="menu-icon d-md-none" for=menu-btn><span class=navicon></span></label><a class="navbar-brand order-1 order-md-0 me-auto" href=https://koktlzz.github.io/>KnowledgeBase</a>
<button id=mode class="btn btn-link order-2 order-md-4" type=button aria-label="Toggle mode">
<span class=toggle-dark><svg xmlns="http://www.w3.org/2000/svg" width="20" height="20" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="feather feather-moon"><path d="M21 12.79A9 9 0 1111.21 3 7 7 0 0021 12.79z"/></svg></span><span class=toggle-light><svg xmlns="http://www.w3.org/2000/svg" width="20" height="20" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="feather feather-sun"><circle cx="12" cy="12" r="5"/><line x1="12" y1="1" x2="12" y2="3"/><line x1="12" y1="21" x2="12" y2="23"/><line x1="4.22" y1="4.22" x2="5.64" y2="5.64"/><line x1="18.36" y1="18.36" x2="19.78" y2="19.78"/><line x1="1" y1="12" x2="3" y2="12"/><line x1="21" y1="12" x2="23" y2="12"/><line x1="4.22" y1="19.78" x2="5.64" y2="18.36"/><line x1="18.36" y1="5.64" x2="19.78" y2="4.22"/></svg></span></button><ul class="navbar-nav social-nav order-3 order-md-5"><li class=nav-item><a class=nav-link href=https://github.com/koktlzz><svg xmlns="http://www.w3.org/2000/svg" width="20" height="20" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="feather feather-github"><path d="M9 19c-5 1.5-5-2.5-7-3m14 6v-3.87a3.37 3.37.0 00-.94-2.61c3.14-.35 6.44-1.54 6.44-7A5.44 5.44.0 0020 4.77 5.07 5.07.0 0019.91 1S18.73.65 16 2.48a13.38 13.38.0 00-7 0C6.27.65 5.09 1 5.09 1A5.07 5.07.0 005 4.77 5.44 5.44.0 003.5 8.55c0 5.42 3.3 6.61 6.44 7A3.37 3.37.0 009 18.13V22"/></svg><span class="ms-2 visually-hidden">GitHub</span></a></li></ul><div class="collapse navbar-collapse order-4 order-md-1"><ul class="navbar-nav main-nav me-auto order-5 order-md-2"><li class=nav-item><a class=nav-link href=https://koktlzz.github.io/container/docker/intro>Container</a></li><li class=nav-item><a class=nav-link href=https://koktlzz.github.io/observability/elasticstack/intro>Observability</a></li><li class=nav-item><a class=nav-link href=https://koktlzz.github.io/programming/go/intro>Programming</a></li><li class=nav-item><a class=nav-link href=https://koktlzz.github.io/infrastructure/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/tcpip%E7%BD%91%E7%BB%9C%E6%A8%A1%E5%9E%8B>Infrastructure</a></li></ul><div class="break order-6 d-md-none"></div></div></div></header><div class="wrap container-fluid" role=document><div class=content><div class="row flex-xl-nowrap"><div class="col-lg-4 col-xl-3 d-none d-xl-block"><nav class=docs-links aria-label="Main navigation"><h3>Go</h3><ul class=list-unstyled><li><a class=docs-link href=https://koktlzz.github.io/programming/go/intro/>Getting Started</a></li><li><a class=docs-link href=https://koktlzz.github.io/programming/go/requestresponse/>Request & Response</a></li><li><a class=docs-link href=https://koktlzz.github.io/programming/go/%E6%90%AD%E5%BB%BAweb%E6%9C%8D%E5%8A%A1%E5%99%A8/>搭建 Web 服务器</a></li><li><a class=docs-link href=https://koktlzz.github.io/programming/go/%E4%BD%BF%E7%94%A8mysql%E6%95%B0%E6%8D%AE%E5%BA%93/>使用 MySQL 数据库</a></li></ul></nav></div><main class="docs-content col-lg-12 col-xl-10"><h1>Request & Response</h1><p class=lead></p><h2 id=httprequest>http.Request<a href=#httprequest class=anchor aria-hidden=true>#</a></h2><h3 id=结构>结构<a href=#结构 class=anchor aria-hidden=true>#</a></h3><ul><li>请求行（请求方法/URL/协议）</li><li>0 个或多个 Header</li><li>空行</li><li>可选的消息体 (Body)</li></ul><p>例如：</p><div class=highlight><pre style=color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-http data-lang=http><span style=color:#50fa7b>GET</span> www.baidu.com <span style=color:#ff79c6>HTTP</span><span style=color:#ff79c6>/</span><span style=color:#bd93f9>1.1</span>
Host<span style=color:#ff79c6>:</span> www.w3.org
User-Agent<span style=color:#ff79c6>:</span> Mozilla/5.0
（空行）
（无消息体）
</code></pre></div><h3 id=读取查询参数>读取查询参数<a href=#读取查询参数 class=anchor aria-hidden=true>#</a></h3><p>常见的 URL 的结构为：</p><div class=highlight><pre style=color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-http data-lang=http>scheme://[userinfo@]host/path[?query][#fragment]
</code></pre></div><p>使用 Request.URL 的 Query 方法即可得到 URL 中的查询参数：</p><div class=highlight><pre style=color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-go data-lang=go>fmt.<span style=color:#50fa7b>Println</span>(r.URL.<span style=color:#50fa7b>Query</span>())
</code></pre></div><p>若请求的 URL 为：<em>http://localhost:8080?name=kokt&age=3</em> , 则控制台输出：</p><div class=highlight><pre style=color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-go data-lang=go><span style=color:#8be9fd;font-style:italic>map</span>[age:[<span style=color:#bd93f9>3</span>] name:[kokt]]
</code></pre></div><h3 id=读取请求头>读取请求头<a href=#读取请求头 class=anchor aria-hidden=true>#</a></h3><div class=highlight><pre style=color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-go data-lang=go><span style=color:#8be9fd;font-style:italic>type</span> Header <span style=color:#8be9fd;font-style:italic>map</span>[<span style=color:#8be9fd>string</span>][]<span style=color:#8be9fd>string</span>
</code></pre></div><p>可以使用 Request.Header[key] 或 Request.Header.Get(key) 获取请求头中的值。前者返回值类型是 []string，后者返回值类型为 string（不同值以逗号分隔）。</p><h3 id=读取消息体>读取消息体<a href=#读取消息体 class=anchor aria-hidden=true>#</a></h3><div class=highlight><pre style=color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-go data-lang=go><span style=color:#8be9fd;font-style:italic>func</span> <span style=color:#50fa7b>obtainBody</span>(w http.ResponseWriter, r <span style=color:#ff79c6>*</span>http.Request) {
    length <span style=color:#ff79c6>:=</span> r.ContentLength
    body <span style=color:#ff79c6>:=</span> <span style=color:#8be9fd;font-style:italic>make</span>([]<span style=color:#8be9fd>byte</span>, length)
    <span style=color:#6272a4>// r.Body 是一个 io.ReadCloser 类型
</span><span style=color:#6272a4></span>    r.Body.<span style=color:#50fa7b>Read</span>(body)
    fmt.<span style=color:#50fa7b>Fprint</span>(w, <span style=color:#8be9fd;font-style:italic>string</span>(body))
}
</code></pre></div><p>使用 REST Client 向服务端发送带有消息体的 POST 请求：</p><div class=highlight><pre style=color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-http data-lang=http><span style=color:#50fa7b>POST</span> http://localhost:8080/obtainBody  <span style=color:#ff79c6>HTTP</span><span style=color:#ff79c6>/</span><span style=color:#bd93f9>1.1</span>
Content-Type<span style=color:#ff79c6>:</span> application/json

{
    <span style=color:#ff79c6>&#34;name&#34;</span>:kokt,
    <span style=color:#ff79c6>&#34;age&#34;</span>:<span style=color:#bd93f9>3</span>
}
</code></pre></div><p>服务端得到请求的消息体：</p><div class=highlight><pre style=color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-http data-lang=http><span style=color:#ff79c6>HTTP</span><span style=color:#ff79c6>/</span><span style=color:#bd93f9>1.1</span> <span style=color:#bd93f9>200</span> OK
Date<span style=color:#ff79c6>:</span> Wed, 06 Jan 2021 16:25:58 GMT
Content-Length<span style=color:#ff79c6>:</span> 32
Content-Type<span style=color:#ff79c6>:</span> text/plain; charset=utf-8
Connection<span style=color:#ff79c6>:</span> close

{
    &#34;name&#34;:kokt,
    &#34;age&#34;:3
}
</code></pre></div><h3 id=处理来自表单的请求>处理来自表单的请求<a href=#处理来自表单的请求 class=anchor aria-hidden=true>#</a></h3><p>如果页面上有一个表单，其功能为：当用户点击提交按钮后，就会向服务端发起一个 POST 请求，请求的页面跳转至/process。上述页面的 html 代码如下：</p><div class=highlight><pre style=color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-html data-lang=html><span style=color:#ff79c6>&lt;!DOCTYPE html&gt;</span>
&lt;<span style=color:#ff79c6>body</span>&gt;
&lt;<span style=color:#ff79c6>form</span> <span style=color:#50fa7b>method</span><span style=color:#ff79c6>=</span><span style=color:#f1fa8c>&#34;POST&#34;</span> <span style=color:#50fa7b>action</span><span style=color:#ff79c6>=</span><span style=color:#f1fa8c>&#34;/process&#34;</span> <span style=color:#50fa7b>enctype</span><span style=color:#ff79c6>=</span><span style=color:#f1fa8c>&#34;application/x-www-form-urlencoded&#34;</span>&gt;
    &lt;<span style=color:#ff79c6>input</span> <span style=color:#50fa7b>name</span><span style=color:#ff79c6>=</span><span style=color:#f1fa8c>&#34;name&#34;</span> <span style=color:#50fa7b>type</span><span style=color:#ff79c6>=</span><span style=color:#f1fa8c>&#34;text&#34;</span>&gt;
    &lt;<span style=color:#ff79c6>input</span> <span style=color:#50fa7b>name</span><span style=color:#ff79c6>=</span><span style=color:#f1fa8c>&#34;age&#34;</span> <span style=color:#50fa7b>type</span><span style=color:#ff79c6>=</span><span style=color:#f1fa8c>&#34;text&#34;</span>&gt;
    &lt;<span style=color:#ff79c6>input</span> <span style=color:#50fa7b>type</span><span style=color:#ff79c6>=</span><span style=color:#f1fa8c>&#34;submit&#34;</span>&gt;
&lt;/<span style=color:#ff79c6>form</span>&gt;
&lt;/<span style=color:#ff79c6>body</span>&gt;
</code></pre></div><p>其中，表单的 enctype 有"application/x-www-form-urlencoded"和"multipart/form-data"两种。前者会将表单数据编码到查询字符串 (r.URL.Query()) 中，适用于简单文本；后者会将每一个键值对转换为一个 MIME 消息部分，每部分具有独立的 Content-Type 和 Content-Disposition，适用于大量数据和文件的上传。</p><p>可以通过 Request.Form 获取提交的表单数据：</p><div class=highlight><pre style=color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-go data-lang=go><span style=color:#8be9fd;font-style:italic>func</span> <span style=color:#50fa7b>form</span>(w http.ResponseWriter, r <span style=color:#ff79c6>*</span>http.Request) {
    r.<span style=color:#50fa7b>ParseForm</span>() <span style=color:#6272a4>// 解析表单，若不调用则 r.Form 为空
</span><span style=color:#6272a4></span>    fmt.<span style=color:#50fa7b>Println</span>(r.Form)
}
</code></pre></div><p>若在页面填入 kokt 和 3 后点击提交按钮，则控制台将会输出：</p><div class=highlight><pre style=color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-go data-lang=go><span style=color:#8be9fd;font-style:italic>map</span>[name:[kokt] age:[<span style=color:#bd93f9>3</span>]]
</code></pre></div><p>如果表单提交后跳转的 URL 中带有查询字符串，Request.Form 可以把它们连同表单中的数据一同输出，而若使用 Request.PostForm 则只会输出表单中的数据。另外，上述两种方法仅支持表单的 enctype 属性为"application/x-www-form-urlencoded"，若该属性为"multipart/form-data"，则需要使用 Request.MultipartForm 字段：</p><div class=highlight><pre style=color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-go data-lang=go><span style=color:#8be9fd;font-style:italic>func</span> <span style=color:#50fa7b>form</span>(w http.ResponseWriter, r <span style=color:#ff79c6>*</span>http.Request) {
    r.<span style=color:#50fa7b>ParseMultipartForm</span>(<span style=color:#bd93f9>1024</span>) <span style=color:#6272a4>// 作用类似于 r.ParseForm()，其参数为需要读取数据的长度（字节数）
</span><span style=color:#6272a4></span>    fmt.<span style=color:#50fa7b>Println</span>(r.MultipartForm)
}
</code></pre></div><p>它的返回值不同于 Request.Form 的 map，而是一个指向 multipart.Form 的指针：</p><div class=highlight><pre style=color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-go data-lang=go><span style=color:#8be9fd;font-style:italic>type</span> Request <span style=color:#8be9fd;font-style:italic>struct</span> {
<span style=color:#ff79c6>...</span>
    MultipartForm <span style=color:#ff79c6>*</span>multipart.Form
<span style=color:#ff79c6>...</span>
}
<span style=color:#8be9fd;font-style:italic>type</span> Form <span style=color:#8be9fd;font-style:italic>struct</span> {
    Value <span style=color:#8be9fd;font-style:italic>map</span>[<span style=color:#8be9fd>string</span>][]<span style=color:#8be9fd>string</span>
    File  <span style=color:#8be9fd;font-style:italic>map</span>[<span style=color:#8be9fd>string</span>][]<span style=color:#ff79c6>*</span>FileHeader
}
</code></pre></div><p>multipart.Form 中有两个 map，第一个包含了表单中提交的数据，第二个包含了上传的文件。因此若在页面填入 kokt 和 3 后点击提交按钮，则控制台将会输出：</p><div class=highlight><pre style=color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-go data-lang=go><span style=color:#ff79c6>&amp;</span>{<span style=color:#8be9fd;font-style:italic>map</span>[name:[kokt] age:[<span style=color:#bd93f9>3</span>]] <span style=color:#8be9fd;font-style:italic>map</span>[]}
</code></pre></div><h3 id=处理上传的文件>处理上传的文件<a href=#处理上传的文件 class=anchor aria-hidden=true>#</a></h3><p>创建一个可以让用户上传文件的页面，该页面的 html 代码如下：</p><div class=highlight><pre style=color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-html data-lang=html><span style=color:#ff79c6>&lt;!DOCTYPE html&gt;</span>
&lt;<span style=color:#ff79c6>body</span>&gt;
&lt;<span style=color:#ff79c6>form</span> <span style=color:#50fa7b>method</span><span style=color:#ff79c6>=</span><span style=color:#f1fa8c>&#34;POST&#34;</span> <span style=color:#50fa7b>action</span><span style=color:#ff79c6>=</span><span style=color:#f1fa8c>&#34;/process&#34;</span> <span style=color:#50fa7b>enctype</span><span style=color:#ff79c6>=</span><span style=color:#f1fa8c>&#34;multipart/form-data&#34;</span>&gt;
    &lt;<span style=color:#ff79c6>input</span> <span style=color:#50fa7b>name</span><span style=color:#ff79c6>=</span><span style=color:#f1fa8c>&#34;upload&#34;</span> <span style=color:#50fa7b>type</span><span style=color:#ff79c6>=</span><span style=color:#f1fa8c>&#34;file&#34;</span>&gt;
    &lt;<span style=color:#ff79c6>input</span> <span style=color:#50fa7b>type</span><span style=color:#ff79c6>=</span><span style=color:#f1fa8c>&#34;submit&#34;</span>&gt;
&lt;/<span style=color:#ff79c6>form</span>&gt;
&lt;/<span style=color:#ff79c6>body</span>&gt;
</code></pre></div><p>服务端利用 Request.MultipartForm 字段获取文件，随后写入到页面的响应中：</p><div class=highlight><pre style=color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-go data-lang=go><span style=color:#8be9fd;font-style:italic>func</span> <span style=color:#50fa7b>upload</span>(w http.ResponseWriter, r <span style=color:#ff79c6>*</span>http.Request) {
    r.<span style=color:#50fa7b>ParseMultipartForm</span>(<span style=color:#bd93f9>1024</span>)
    <span style=color:#6272a4>// 若上传多个文件，只读取第一个
</span><span style=color:#6272a4></span>    fileHeader <span style=color:#ff79c6>:=</span> r.MultipartForm.File[<span style=color:#f1fa8c>&#34;upload&#34;</span>][<span style=color:#bd93f9>0</span>]
    <span style=color:#6272a4>// 忽略异常处理
</span><span style=color:#6272a4></span>    file, _ <span style=color:#ff79c6>:=</span> fileHeader.<span style=color:#50fa7b>Open</span>()
    <span style=color:#ff79c6>defer</span> file.<span style=color:#50fa7b>Close</span>()
    data, _ <span style=color:#ff79c6>:=</span> ioutil.<span style=color:#50fa7b>ReadAll</span>(file) <span style=color:#6272a4>//data 的类型为 []byte
</span><span style=color:#6272a4></span>    fmt.<span style=color:#50fa7b>Fprintf</span>(w, <span style=color:#8be9fd;font-style:italic>string</span>(data))
}
</code></pre></div><p>其中，fileHeader 的类型为 multipart.FileHeader：</p><div class=highlight><pre style=color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-go data-lang=go><span style=color:#8be9fd;font-style:italic>type</span> FileHeader <span style=color:#8be9fd;font-style:italic>struct</span> {
    Filename <span style=color:#8be9fd>string</span>
    Header   textproto.MIMEHeader
}
</code></pre></div><p>若上传的文件只有一个，则可使用更为简单的 Request.FormFile 字段。另外，下列代码还添加了一个将上传的文件下载到项目目录下的功能：</p><div class=highlight><pre style=color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-go data-lang=go>    <span style=color:#6272a4>// 无需调用 r.ParseMultipartForm() 方法
</span><span style=color:#6272a4></span>    file, fileHeader, err <span style=color:#ff79c6>:=</span> r.<span style=color:#50fa7b>FormFile</span>(<span style=color:#f1fa8c>&#34;upload&#34;</span>)
    <span style=color:#ff79c6>if</span> err <span style=color:#ff79c6>!=</span> <span style=color:#ff79c6>nil</span> {
        log.<span style=color:#50fa7b>Fatal</span>(err)
    }
    <span style=color:#ff79c6>defer</span> file.<span style=color:#50fa7b>Close</span>()
    <span style=color:#6272a4>// 新建一个与上传文件同名的文件
</span><span style=color:#6272a4></span>    newfile, err <span style=color:#ff79c6>:=</span> os.<span style=color:#50fa7b>OpenFile</span>(fileHeader.Filename, os.O_WRONLY|os.O_CREATE, <span style=color:#bd93f9>0666</span>)
    <span style=color:#ff79c6>if</span> err <span style=color:#ff79c6>!=</span> <span style=color:#ff79c6>nil</span> {
        log.<span style=color:#50fa7b>Fatal</span>(err)
    }
    <span style=color:#ff79c6>defer</span> newfile.<span style=color:#50fa7b>Close</span>()
    <span style=color:#6272a4>// 将上传的文件内容拷贝至新建的文件中
</span><span style=color:#6272a4></span>    io.<span style=color:#50fa7b>Copy</span>(newfile, file)
</code></pre></div><p>上述处理表单数据和文件的方法均是将请求的消息体当作一个对象处理，一次性地获得整个或多个 map。而 Request.MultipartReader 字段可以将请求的消息体当作一个流 (stream) 进行处理，它仅适用于 enctype 值为"multipart/form-data"的 POST 请求。</p><div class=highlight><pre style=color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-go data-lang=go><span style=color:#8be9fd;font-style:italic>func</span> (r <span style=color:#ff79c6>*</span>Request) <span style=color:#50fa7b>MultipartReader</span>() (<span style=color:#ff79c6>*</span>multipart.Reader, <span style=color:#8be9fd>error</span>)
</code></pre></div><p>Request.ParseForm 无法解析 application/json。</p><h2 id=httpresponse>http.response<a href=#httpresponse class=anchor aria-hidden=true>#</a></h2><p>http.response 代表对一个 HTTP 请求的响应。由于该结构体首字母小写，因此无法在包外调用。而 *http.response 实现了 http.ResponseWriter 的全部方法。因此我们可以将 *http.response 当作一个 http.ResponseWriter 传入函数，从而通过引用传递的方式操作 http.response。</p><div class=highlight><pre style=color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-go data-lang=go><span style=color:#8be9fd;font-style:italic>type</span> ResponseWriter <span style=color:#8be9fd;font-style:italic>interface</span> {
<span style=color:#6272a4>// Header 返回一个 Header 类型值，该值会被 WriteHeader 方法发送。
</span><span style=color:#6272a4>// 在调用 WriteHeader 或 Write 方法后再改变该对象是没有意义的。
</span><span style=color:#6272a4></span><span style=color:#50fa7b>Header</span>() Header
<span style=color:#6272a4>// WriteHeader 该方法发送 HTTP 回复的头域和状态码。
</span><span style=color:#6272a4>// 如果没有被显式调用，第一次调用 Write 时会触发隐式调用 WriteHeader(http.StatusOK)
</span><span style=color:#6272a4>// WriterHeader 的显式调用主要用于发送错误码。
</span><span style=color:#6272a4></span><span style=color:#50fa7b>WriteHeader</span>(<span style=color:#8be9fd>int</span>) <span style=color:#6272a4>// 参数：HTTP 状态码
</span><span style=color:#6272a4>// Write 向连接中写入作为 HTTP 的一部分回复的数据。
</span><span style=color:#6272a4>// 如果被调用时还未调用 WriteHeader，本方法会先调用 WriteHeader(http.StatusOK)
</span><span style=color:#6272a4>// 如果 Header 中没有&#34;Content-Type&#34;键，本方法会使用包函数 DetectContentType 检查数据的前 512 字节，将返回值作为该键的值。
</span><span style=color:#6272a4></span><span style=color:#50fa7b>Write</span>([]<span style=color:#8be9fd>byte</span>) (<span style=color:#8be9fd>int</span>, <span style=color:#8be9fd>error</span>)
}
</code></pre></div><div class=highlight><pre style=color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-go data-lang=go><span style=color:#8be9fd;font-style:italic>type</span> response <span style=color:#8be9fd;font-style:italic>struct</span> {
    conn             <span style=color:#ff79c6>*</span>conn
    req              <span style=color:#ff79c6>*</span>Request <span style=color:#6272a4>// request for this response
</span><span style=color:#6272a4></span>    <span style=color:#ff79c6>...</span>
}

<span style=color:#8be9fd;font-style:italic>func</span> (w <span style=color:#ff79c6>*</span>response) <span style=color:#50fa7b>Header</span>() Header {
    <span style=color:#ff79c6>if</span> w.cw.header <span style=color:#ff79c6>==</span> <span style=color:#ff79c6>nil</span> <span style=color:#ff79c6>&amp;&amp;</span> w.wroteHeader <span style=color:#ff79c6>&amp;&amp;</span> !w.cw.wroteHeader {
        w.cw.header = w.handlerHeader.<span style=color:#50fa7b>Clone</span>()
    }
    w.calledHeader = <span style=color:#ff79c6>true</span>
    <span style=color:#ff79c6>return</span> w.handlerHeader
}

<span style=color:#8be9fd;font-style:italic>func</span> (w <span style=color:#ff79c6>*</span>response) <span style=color:#50fa7b>WriteHeader</span>(code <span style=color:#8be9fd>int</span>) {
    <span style=color:#ff79c6>if</span> w.conn.<span style=color:#50fa7b>hijacked</span>() {
        caller <span style=color:#ff79c6>:=</span> <span style=color:#50fa7b>relevantCaller</span>()
        w.conn.server.<span style=color:#50fa7b>logf</span>(<span style=color:#f1fa8c>&#34;http: response.WriteHeader on hijacked connection from %s (%s:%d)&#34;</span>, caller.Function, path.<span style=color:#50fa7b>Base</span>(caller.File), caller.Line)
        <span style=color:#ff79c6>return</span>
    }
    <span style=color:#ff79c6>...</span>
}

<span style=color:#8be9fd;font-style:italic>func</span> (w <span style=color:#ff79c6>*</span>response) <span style=color:#50fa7b>Write</span>(data []<span style=color:#8be9fd>byte</span>) (n <span style=color:#8be9fd>int</span>, err <span style=color:#8be9fd>error</span>) {
    <span style=color:#ff79c6>return</span> w.<span style=color:#50fa7b>write</span>(<span style=color:#8be9fd;font-style:italic>len</span>(data), data, <span style=color:#f1fa8c>&#34;&#34;</span>)
}
</code></pre></div><p>这也解释了为什么 ServeHTTP 方法中的两个参数：ResponseWriter 和 *Request，只有 Request 是按引用传递的，因为传入 ResponseWriter 的变量本质是 *response。</p><h3 id=内置响应>内置响应<a href=#内置响应 class=anchor aria-hidden=true>#</a></h3><ul><li>NotFound 函数：包装了一个 404 状态码和额外信息；</li><li>ServeFile 函数：从文件系统提供文件，返回给请求者；</li><li>ServeContent 函数：可以把实现了 io.ReadSeeker 接口的任何东西里面的内容返回给请求者（还可以处理范围请求，即只请求了资源中的一部分内容，ServeFile 或 io.Copy 则无法做到）；</li><li>Redirect 函数：告诉客户端重定向到另一个 URL。</li></ul><p class=edit-page><a href=https://github.com/koktlzz/koktlzz.github.io/blob/master/content/Programming/Go/Request&Response.md><svg xmlns="http://www.w3.org/2000/svg" width="16" height="16" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="feather feather-edit-2"><path d="M17 3a2.828 2.828.0 114 4L7.5 20.5 2 22l1.5-5.5L17 3z"/></svg>Edit this page on GitHub</a></p><div class="docs-navigation d-flex justify-content-between"><a href=https://koktlzz.github.io/programming/go/intro/><div class="card my-1"><div class="card-body py-2">&larr; Getting Started</div></div></a><a class=ms-auto href=https://koktlzz.github.io/programming/go/%E6%90%AD%E5%BB%BAweb%E6%9C%8D%E5%8A%A1%E5%99%A8/><div class="card my-1"><div class="card-body py-2">搭建 Web 服务器 &rarr;</div></div></a></div><script src=https://utteranc.es/client.js repo=koktlzz/koktlzz.github.io issue-term=pathname theme=photon-dark crossorigin=anonymous async></script></main><nav class="docs-toc d-none d-xl-block col-lg-3 col-xl-2" aria-label="Secondary navigation"><div class=page-links><h3>On this page</h3><nav id=TableOfContents><ul><li><a href=#httprequest>http.Request</a><ul><li><a href=#结构>结构</a></li><li><a href=#读取查询参数>读取查询参数</a></li><li><a href=#读取请求头>读取请求头</a></li><li><a href=#读取消息体>读取消息体</a></li><li><a href=#处理来自表单的请求>处理来自表单的请求</a></li><li><a href=#处理上传的文件>处理上传的文件</a></li></ul></li><li><a href=#httpresponse>http.response</a><ul><li><a href=#内置响应>内置响应</a></li></ul></li></ul></nav></div></nav></div></div></div><script src=https://koktlzz.github.io/js/bootstrap.min.d67050adf5d370668aede4201f82af781b16970934804995a1ca37c1ee9222c2fc530972aa6d5d2b6124caf1fe318f139aac99df2c1e89af65504fc1185c7972.js integrity="sha512-1nBQrfXTcGaK7eQgH4KveBsWlwk0gEmVoco3we6SIsL8Uwlyqm1dK2EkyvH+MY8TmqyZ3yweia9lUE/BGFx5cg==" crossorigin=anonymous defer></script><script src=https://koktlzz.github.io/js/vendor/katex/dist/katex.min.b334e5b00c45f572e7f38a543046f36854bf4cbb543880480c09271a0efedc694d6905f719934f6ede2f26f52e80411c05b90121d722cbf8be2fa8fc51bc6b81.js integrity="sha512-szTlsAxF9XLn84pUMEbzaFS/TLtUOIBIDAknGg7+3GlNaQX3GZNPbt4vJvUugEEcBbkBIdciy/i+L6j8UbxrgQ==" crossorigin=anonymous defer></script><script src=https://koktlzz.github.io/js/vendor/katex/dist/contrib/auto-render.min.916823ec103cf367b71e28a6f01513cb9c3ac6708ccb5229402ec46b8e30a8b25003db694df35d80e9dd666a371f327c6152790617b6256390c164109a90bd4c.js integrity="sha512-kWgj7BA882e3Hiim8BUTy5w6xnCMy1IpQC7Ea44wqLJQA9tpTfNdgOndZmo3HzJ8YVJ5Bhe2JWOQwWQQmpC9TA==" crossorigin=anonymous defer></script><script src=https://koktlzz.github.io/main.min.1febbf2f6fd6a36fc2f57dd50d7935fbb640743329baeb4ef7cefcf2e7630e413371fbba976e103656b82808ee227dc4a84237edb0f8433648bef3a56900661a.js integrity="sha512-H+u/L2/Wo2/C9X3VDXk1+7ZAdDMpuutO98788udjDkEzcfu6l24QNla4KAjuIn3EqEI37bD4QzZIvvOlaQBmGg==" crossorigin=anonymous defer></script></body></html>