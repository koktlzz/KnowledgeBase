---
title: "DNS、UDP 与 HTTPS"
description: ""
date: 2021-02-24T22:05:45+08:00
lastmod: 2021-02-24T22:05:45+08:00
draft: false
images: []
menu:
   infrastructure:
    parent: "计算机网络"
weight: 200
---

## DNS

### 概述

DNS(Domain Name System) 是“域名系统”的英文缩写，是一种组织成域层次结构的计算机和网络服务命名系统。它在大多数情况下运行在 UDP 协议之上，从事将**主机名或域名转换为实际 IP 地址**的工作。

当你访问本网站的域名`koktlzz.github.io`，操作系统会先检查自己本地的 hosts 文件是否有这个网址映射关系，如果有，就先调用这个 IP 地址映射，完成域名解析。

```bash
[root@koktlzz ~]# cat /etc/hosts
::1     localhost       localhost.localdomain   localhost6      localhost6.localdomain6
127.0.0.1       localhost       localhost.localdomain   localhost4      localhost4.localdomain4

172.30.33.166   koktlzz.github.io koktlzz
[root@koktlzz ~]# ping koktlzz
PING koktlzz.github.io (172.30.33.166) 56(84) bytes of data.
```

如果本地配置里没有这个域名的映射，则查找本地 DNS 解析器缓存中是否有这个网址映射关系，若有则直接返回目标 IP 地址。而如果 hosts 文件与本地 DNS 解析器缓存都没有相应的网址映射关系，操作系统会向首选 DNS 服务器（在此我们叫它本地 DNS 服务器）发起请求。DNS 配置保存在 resolv.conf 文件中，其中的`nameserver`字段对应的便是本地 DNS 服务器地址：

```bash
[root@koktlzz ~]# cat /etc/resolv.conf 
# Generated by NetworkManager
nameserver 100.100.2.136
nameserver 100.100.2.138
```

由于本站网址的全称域名（FQDN）为`koktlzz.github.io.`，因此本地 DNS 服务器首先将请求转发至根域名服务器（.），根域名服务器返回一个负责管理`.io`域的顶级域名服务器的 IP 地址。本地 DNS 服务器收到信息后，将会再次请求该顶级域名服务器。该服务器收到请求后，如果自己无法解析，它就会返回负责管理`github.io`的次级域名服务器地址给本地 DNS 服务器。本地 DNS 服务器重复上面的步骤，直至找到`koktlzz.github.io`的主机 IP 地址。域名的层级结构如下：

![20210420](https://cdn.jsdelivr.net/gh/koktlzz/ImgBed@master/20210420.jpeg)

使用 **dig** 命令可以看到寻找给定域名的 IP 地址的全部过程：

```bash
[root@koktlzz ~]# dig +trace -t A koktlzz.github.io 

; <<>> DiG 9.11.20-RedHat-9.11.20-5.el8_3.1 <<>> +trace -t A koktlzz.github.io
;; global options: +cmd
.                       232352  IN      NS      h.root-servers.net.
.                       232352  IN      NS      a.root-servers.net.
.                       232352  IN      NS      m.root-servers.net.
.                       232352  IN      NS      k.root-servers.net.
.                       232352  IN      NS      b.root-servers.net.
.                       232352  IN      NS      l.root-servers.net.
.                       232352  IN      NS      j.root-servers.net.
.                       232352  IN      NS      g.root-servers.net.
.                       232352  IN      NS      i.root-servers.net.
.                       232352  IN      NS      e.root-servers.net.
.                       232352  IN      NS      c.root-servers.net.
.                       232352  IN      NS      d.root-servers.net.
.                       232352  IN      NS      f.root-servers.net.
;; Received 228 bytes from 100.100.2.136#53(100.100.2.136) in 0 ms

io.                     172800  IN      NS      a2.nic.io.
io.                     172800  IN      NS      b0.nic.io.
io.                     172800  IN      NS      c0.nic.io.
io.                     172800  IN      NS      a0.nic.io.
;; Received 629 bytes from 202.12.27.33#53(m.root-servers.net) in 33 ms

github.io.              86400   IN      NS      dns2.p05.nsone.net.
github.io.              86400   IN      NS      ns-1622.awsdns-10.co.uk.
github.io.              86400   IN      NS      dns1.p05.nsone.net.
github.io.              86400   IN      NS      dns3.p05.nsone.net.
github.io.              86400   IN      NS      ns-692.awsdns-22.net.
;; Received 688 bytes from 65.22.163.17#53(a2.nic.io) in 141 ms

koktlzz.github.io.      3600    IN      A       185.199.108.153
koktlzz.github.io.      3600    IN      A       185.199.109.153
koktlzz.github.io.      3600    IN      A       185.199.110.153
koktlzz.github.io.      3600    IN      A       185.199.111.153
;; Received 110 bytes from 198.51.45.5#53(dns2.p05.nsone.net) in 62 ms
```

每行输出结果共有 5 个字段，第一个字段是请求，最后一个字段是响应。第二个字段是 DNS 响应的有效时间 TimetoLive（以秒为单位），一小时内有效，而第四个字段代表 DNS 响应/请求的类型。从输出结果的 Recieve from 信息中我们可以看到此次 DNS 解析共经过了：本地 DNS 服务器 100.100.2.136、根域名服务器 m.root-servers.net、顶级域名服务器 a2.nic.io 和权威域名服务器 dns2.p05.nsone.net。这个权威域名服务器实际上是由次级域名服务器`github.io.`的域名注册商维护的，它可以根据已有配置（就像 hosts 文件那样）直接返回`koktlzz.github.io.`域名的 IP 地址。

上述过程用图片说明可能更加直观：

![20201223142840](https://cdn.jsdelivr.net/gh/koktlzz/NoteImg@main/20201223142840.png)

>所谓递归查询过程就是“查询的递交者”更替，而迭代查询过程则是“查询的递交者”不变。
>举个例子来说，你想知道某个一起上法律课的女孩的电话，并且你偷偷拍了她的照片，回到寝室告诉一个很仗义的哥们儿，这个哥们儿二话没说，拍着胸脯告诉你，甭急，我替你查（此处完成了一次递归查询，即，问询者的角色更替）。然后他拿着照片问了学院大四学长，学长告诉他，这姑娘是 xx 系的；然后这哥们儿马不停蹄又问了 xx 系的办公室主任助理同学，助理同学说是 xx 系 yy 班的，然后很仗义的哥们儿去 xx 系 yy 班的班长那里取到了该女孩儿电话。（此处完成若干次迭代查询，即，问询者角色不变，但反复更替问询对象）最后，他把号码交到了你手里。完成整个查询过程。

### 记录类型

- A 记录（Address）：指定主机名（或域名）对应的 IPv4 地址的记录；
- AAAA 记录：指定主机名（或域名）对应的 IPv6 地址的记录；
- NS（Name Server）记录：指定主机名（或域名）由哪个 DNS 服务器来进行解析；
- CNAME 记录 (Canonical Name)：将一个或多个主机名（域名）映射到一个域名记录上。例如可以将 ftp.example.com 和 www.example.com 指向 CNAME 记录 example.com，这样访问 ftp.example.com 时便会解析 example.com 对应的 IP 地址（A 记录）；
- SRV 记录：标识某台主机暴露的某个服务，其格式为`_Service._Proto.Name TTL Class SRV Priority Weight Port Target`。其中，_Service 是目标主机提供的服务名称，Proto 是协议类型（_TCP/_UDP），Port 是服务暴露的端口，Target 是目标主机的域名。

## UDP 协议

只实现多路复用（将来自应用层的多个应用程序的数据包组合到同一网络层）和多路分离（将来自单个网络层的数据包分发到多个应用程序）。DNS 通常使用 UDP 协议传输数据。

虽然 UDP 协议位于传输控制层，但数据包在主机间的传递是由其底层的 IP 协议完成的，UDP 协议只是根据端口号定位处理数据的具体进程。

> IP 协议是 TCP/IP 协议栈的核心成员，它不保证端到端数据的可靠性和顺序，也不包含流控制等机制，其作用就是从来源向目的地传输数据包。『UDP 协议只能尽力送达数据』这一说法『继承』自 UDP 的下层协议，也就是 IP 协议。只包含了两个端口号的 UDP 协议本身是无法提供路由和寻址功能的，它还是需要下层的协议来解决这个问题。

### UDP 的主要特点

1. UDP 是无连接的，可以减少建立连接的开销和发送数据之前的延时；
2. UDP 使用最大努力交付，不保证可靠交付；
3. UDP 是面向报文的，一次发送一个完整的报文（对应用层报文不做任何处理，仅增加一个 UDP 首部）；
4. 适合一次性传输少量数据的网络应用；
5. UDP 无阻塞控制，适合很多实时应用；
6. UDP 首部开销小，仅有 8B（TCP 首部 20B）；
7. 有单播、多播和广播的功能；
8. 相对于 TCP 套接字的四元组，UDP 套接字只包含了目的 IP+目的端口号。

### UDP 首部格式

1. 16 位源端口号：2B
2. 16 位目标端口号：2B
3. 16 位 UDP 长度（UDP 首部+数据字段总长度）：2B
4. 16 位 UDP 检验码（利用伪首部检验首部和数据字段是否有错，如有错则丢弃或附上错误警告交给应用层）：2B

## HTTPS 协议

![20210109125505](https://cdn.jsdelivr.net/gh/koktlzz/ImgBed@master/20210109125505.png)

1. Client 发起一个 HTTPS（https:/demo.linianhui.dev）的请求，根据 RFC2818 的规定，Client 知道需要连接 Server 的 443（默认）端口。
2. Server 把事先配置好的公钥证书（public key certificate）返回给客户端。
3. Client 验证公钥证书：比如是否在有效期内，证书的用途是不是匹配 Client 请求的站点，是不是在 CRL 吊销列表里面，它的上一级证书是否有效，这是一个递归的过程，直到验证到根证书（操作系统内置的 Root 证书或者 Client 内置的 Root 证书）。如果验证通过则继续，不通过则显示警告信息。
4. Client 使用伪随机数生成器生成加密所使用的会话密钥，然后用证书的公钥加密这个会话密钥，发给 Server。
5. Server 使用自己的私钥（private key）解密这个消息，得到会话密钥。至此，Client 和 Server 双方都持有了相同的会话密钥。
6. Server 使用会话密钥加密“明文内容 A”，发送给 Client。Client 使用会话密钥解密响应的密文，得到“明文内容 A”。
7. Client 再次发起 HTTPS 的请求，使用会话密钥加密请求的“明文内容 B”，然后 Server 使用会话密钥解密密文，得到“明文内容 B”。

在 Linux 系统中使用命令：**curl https://www.baidu.com -v**，可以观察到上述加密流程：

![20210109124816](https://cdn.jsdelivr.net/gh/koktlzz/ImgBed@master/20210109124816.png)
