---
title: "信息的表示和处理"
description: ""
date: 2021-02-24T22:05:45+08:00
lastmod: 2021-02-24T22:05:45+08:00
draft: false
images: []
menu:
  infra:
    parent: "CSAPP"
weight: 600
---

The average energy of the neutrinos $\langle E \rangle$ emitted during a supernova explosion is of the order of 10MeV, and the neutrino luminosity at the early epoch of the explosion is approximately $10^{52}\mathrm{ergs\cdot s^{-1}}$.
Therefore, the number density of the neutrinos at the radius $R$ is

$$
\begin{equation*}
   n \sim  10^{18} \mathrm{cm^{-3}} \left(\frac{100\mathrm{km}}{R}\right)^2 \left(\frac{10\mathrm{MeV}}{\langle E \rangle}\right).
\end{equation*}
$$

## 信息的存储

大多数机器使用字节（8 位的块）作为存储器中的最小寻址单元，而非访问单独的位。内存中的每一个字节都对应一个唯一的数字，即它的地址，所有可能的地址集合构成了 [虚拟内存](/infra/csapp/计算机系统之旅/#虚拟内存）。它是由 DRAM、闪存（flash memory) 和磁盘存储共同实现的，而在程序看来则只是一个统一的字节数组。

编译器和运行时系统负责将这个内存空间划分为更加可管理的单元，来存储不同的程序对象。例如，C 中指针的值代表存储块中第一个字节的虚拟地址。C 编译器还将每个指针与其类型信息联系起来，这样就可以根据指针值的类型生成不同的机器级代码来访问指针所指向的值。不过机器级代码中并没有任何有关类型的信息，而是简单的把每个程序对象都视为一个字节块。

### 十六进制表示法

使用二进制表示位模式（bit pattern）会非常冗长，因为一个字节就包含了 8 位。而如果使用十进制，则不方便与位模式进行互相转化，因此我们采用十六进制（Hexadecimal）来书写位模式。由于一个十六进制数占 4 位，一个字节的取值范围就是 $00_16$ ~ FF~16~ 。

将一个二进制数字转化为十六进制数字，需要首先将其分为多个 4 位的组，然后再将每组数转化为十六进制。如果总位数不为 4 的倍数，那么最左边的一组可以少于四位，然后在首位补 0。如 111100~2~ 可以分成 0011 和 1100，转化结果为 3C~16~ 。在 C 中，一个常数以 0x 或 0X 作为前缀，则代表它是一个十六进制数字。

### 数据大小

每台计算机都有一个字长（word size），它指定了指针数据的标准大小。如果一台机器的字长为 w 位，那么虚拟地址的范围为 $$ 0～2^w^ -1 $$，程序最多访问 2^w^ 字节。32 位机器的虚拟地址大小约为 4GB，而 64 位机器则能达到 16EB。

C 中几个基本数据类型的大小如下表所示：

| Signed        | Unsigned       | 32-bit | 64-bit |
| ------------- | -------------- | ------ | ------ |
| \[signed\] char | unsigned char  | 1      | 1      |
| short         | unsigned short | 2      | 2      |
| int           | unsigned       | 4      | 4      |
| long          | unsigned long  | 4      | 8      |
| int32_t       | uint_32t       | 4      | 4      |
| int64_t       | uint_64t       | 8      | 8      |
| char *        |                | 4      | 8      |
| float         |                | 4      | 4      |
| double        |                | 8      | 8      |

除 char 外，若不添加前缀 unsigned，则默认使用有符号类型。指针类型的数据使用机器的全字长，如 char *。由于某些数据类型的大小在不同机器上有所不同，因此开发人员应使程序对不同数据类型的确切大小不敏感，从而保证程序的可移植性（portable）。

### 寻址和字节顺序

对于多字节的程序对象，我们必须建立两个准则：这个对象的地址是什么和这些字节在内存中的排列顺序是怎样的。某些机器选择按照从最低有效字节到最高有效字节的顺序存储对象，称为小端法（little endian）；而某些则与之相反，称为大端法（big endian）。如一个 int 类型的变量 x 地址为 0x100，其值为十六进制的 0x1234567，那么上述两种机器存储该变量的方式分别如下：

little endian

|      | 0x100 | 0x101 | 0x102 | 0x103 |      |
| :--: | :---: | :---: | :---: | :---: | :--: |
| ...  |  67   |  45   |  23   |  01   | ...  |

big endian

|      | 0x100 | 0x101 | 0x102 | 0x103 |      |
| :--: | :---: | :---: | :---: | :---: | :--: |
| ...  |  01   |  23   |  45   |  67   | ...  |

有些时候不同的存储顺序可能导致一些问题：

- 不同类型的机器通过网络传递二进制数据，如小端法机器产生的数据发送到大端机器上，得到的字节序列是反的。这就要求发送方的机器需要将代码转换为网络标准，接收方再将其转化为其内部的表达方式；
- 对于小端法机器，书写字节序列与书写数字的顺序相反；
- 某些使用强制类型转换（cast）的程序，在不同类型的机器上编译运行的结果不同。

对于上述第三种情况，我们以一个程序为例：

```c
#include <stdio.h>

typedef unsigned char *byte_pointer;

void show_bytes(byte_pointer start, size_t len)
{
    size_t i;
    for (i = 0; i < len; i++)
    {
        // %.2x 代表整数会被打印为至少两位（digits）的十六进制数字
        printf("%.2x", start[i]);
    }
    printf("\n");
}

void show_int(int x)
{
    show_bytes((byte_pointer)&x, sizeof(int));
}

void show_float(float x)
{
    show_bytes((byte_pointer)&x, sizeof(float));
}

void show_pointer(void *x)
{
    show_bytes((byte_pointer)&x, sizeof(void *));
}

int main()
{
    int val = 12345;
    float fval = (float) val;
    int *pval = &val;
    show_int(val);
    show_float(fval);
    show_pointer(pval);
}
```

不同类型机器的输出结果如下：

| Machine   | val        | fval       | pval               |
| --------- | ---------- | ---------- | ------------------ |
| Linux32   | 0x39300000 | 0x00e44046 | 0xe4f9ffbf         |
| Windows32 | 0x39300000 | 0x00e44046 | 0xb4cc2200         |
| Sun       | 0x00003039 | 0x4640e400 | 0xeffffa0c         |
| Linux64   | 0x39300000 | 0x00e44046 | 0xb811e5ffff7f0000 |

这是因为 Sun 系统采用大端法，其他三者采用小端法。对于指针类型的变量，不同操作系统在存储分配上有着不同的准则。同时，64 位系统使用 8 字节地址，32 位系统使用 4 字节地址，这导致了指针类型的变量 pval 输出结果的不同。

### 字符串

字符串在 C 中被编码为一个以 null 字符结尾（其值为 0）的字符数组，每个字符都由某种标准编码组成，如 ASCII 码。因此，如果我们执行上面的程序`show_bytes("12345", 6)`，将得到 31 32 33 34 35 00。

由于字符串中各字符的排列顺序是由字符串本身决定的，因此字符串不会受到大端法/小端法的影响，除非字符使用 16 位两字节的 Unicode 进行编码。

### 代码

不同类型的机器使用不同且不兼容的指令和编码方式，因此二进制代码很少能在不同机器和操作系统组合之间移植。

### 布尔代数简介

几种布尔运算符的定义如下：

- ～：非，相当于逻辑运算的 NOT；
- &：与，相当于逻辑运算的 AND；
- ｜：或，相当于逻辑运算的 OR；
- ^：异或，相当于逻辑运算的 EXCLUSIVE-OR。若 p = 0，q = 1 或 p = 1，q = 0 时，p ^ q = 1。

布尔运算符可以应用于位向量，即固定长度的 0、1 序列。举例来说，若 a 为 [0110]，b 为 [0101]，那么：

| Operation | Result |
| --------- | ------ |
| ~a        | [1001] |
| a & b     | [0100] |
| a \| b    | [0111] |
| a ^ b     | [0011] |

### C 中的位级运算

C 中支持按位布尔运算，上面提到的布尔运算符其实就是在 C 中使用的。一个使用布尔运算符的经典程序如下：

```c
#include <stdio.h>

void inplace_swap(int *x, int *y)
{
    *y = *x ^ *y;
    *x = *x ^ *y;
    *y = *x ^ *y;
}
```

利用对于任意数 a ，a ^ a = 0 以及 0 ^ a = a 这一性质，该程序不使用中间变量便完成了变量值的交换。另外，上述方法的实现还建立在异或运算满足交换律和结合律的基础之上。

### C 中的逻辑运算

C 还提供了逻辑运算符，即 || 、&& 和 !。它们和位级运算的一个区别就是，如果对第一个参数求值就能确定表达式的结果，那么就不会对第二个参数进行求值。如表达式 a && 5 / a 不会导致除数为 0 的异常，而 p && *p++ 也不会导致简介引用空指针。

### C 中的移位运算

C 中的移位运算有左移和右移两种，均不会改变位向量的长度。左移运算 x << k 就是 x 向左移动 k 位，丢弃 k 个高位，并在右端补充 k 个 0。通常可以使用 x << 1 和 x << 2 分别代替 x \* 2 和 x \* 4，因为位级运算拥有相比乘法更快的运算速度。

右移运算分为两种形式，逻辑和算术。无符号数据必须使用逻辑右移，x >> k 将 x 的左端补充 k 个 0 ，并丢弃 k 个低位。而大多数机器使用算术右移处理有符号数据，x >> k 将 x 的左端补充 k 个最高有效位的拷贝，并丢弃 k 个低位。

加减乘除运算符的优先级大于移位运算符，因此 1 << 2 + 3 << 4 等效于 1 << (2 + 3) << 4。

## 整数的表示

### 无符号编码

### 二进制补码

二进制补码（Two's-Complement Encoding)将位向量的最高位作为负权重（negative weight）。如一个长度为w的位向量，它从二进制转化为二进制补码的公式为：

### 有符号数和无符号数的转换

### C 中的有符号数和无符号数

### 扩展一个数的位级表示

### 截断数字

## 整数的运算

## 浮点

## 小结
