<!doctype html><html lang=en-us><head><script async src="https://www.googletagmanager.com/gtag/js?id=G-D022F6NT2P"></script><script>window.dataLayer=window.dataLayer||[];function gtag(){dataLayer.push(arguments)}gtag('js',new Date),gtag('config','G-D022F6NT2P')</script><script>(function(b,d,e,a,g){b[a]=b[a]||[],b[a].push({'gtm.start':(new Date).getTime(),event:'gtm.js'});var f=d.getElementsByTagName(e)[0],c=d.createElement(e),h=a!='dataLayer'?'&l='+a:'';c.async=!0,c.src='https://www.googletagmanager.com/gtm.js?id='+g+h,f.parentNode.insertBefore(c,f)})(window,document,'script','dataLayer','GTM-P72R45W')</script><meta charset=utf-8><meta http-equiv=x-ua-compatible content="ie=edge"><meta name=viewport content="width=device-width,initial-scale=1,shrink-to-fit=no"><link rel=preload as=font href=https://koktlzz.github.io/fonts/vendor/jost/jost-v4-latin-regular.woff2 type=font/woff2 crossorigin><link rel=preload as=font href=https://koktlzz.github.io/fonts/vendor/jost/jost-v4-latin-700.woff2 type=font/woff2 crossorigin><link rel=preload as=font href=https://koktlzz.github.io/fonts/KaTeX_Main-Regular.woff2 type=font/woff2 crossorigin><link rel=preload as=font href=https://koktlzz.github.io/fonts/KaTeX_Math-Italic.woff2 type=font/woff2 crossorigin><link rel=stylesheet href=https://koktlzz.github.io/main.09ec2f025fdb9f947415a273a44df08d5f3ec03e47aaa8b29ade63a14a6c9a7bc68d57acd1f4c9231d9c21a0673bb8280a543e2552346241f7c2b9c86274c6ff.css integrity="sha512-CewvAl/bn5R0FaJzpE3wjV8+wD5Hqqiymt5joUpsmnvGjVes0fTJIx2cIaBnO7goClQ+JVI0YkH3wrnIYnTG/w==" crossorigin=anonymous><noscript><style>img.lazyload{display:none}</style></noscript><meta name=robots content="index, follow"><meta name=googlebot content="index, follow, max-snippet:-1, max-image-preview:large, max-video-preview:-1"><meta name=bingbot content="index, follow, max-snippet:-1, max-image-preview:large, max-video-preview:-1"><title>Linux 启动流程 | KnowledgeBase</title><meta name=description content><link rel=canonical href=https://koktlzz.github.io/infrastructure/linux/boot/><meta property="og:locale" content="en_US"><meta property="og:type" content="article"><meta property="og:title" content="Linux 启动流程"><meta property="og:description" content="TODO:
 Set Root Initerd/initramfs  启动一台 Linux 机器的过程可以分为两个部分：Boot 和 Startup。其中，Boot 起始于计算机启动，在内核初始化完成且 Systemd 进程开始加载后结束。紧接着， Startup 接管任务，使计算机达到一个用户可操作的状态。
Boot 如上图所示，Boot 过程又可以详细地分为三个部分：
 BIOS POST Boot Loader 内核初始化  BIOS POST 开机自检（Power On Self Test，POST）是 基本输入输出系统（Basic I/O System，BIOS）的一部分，也是启动 Linux 机器的第一个步骤。其工作对象是计算机硬件，因此对于任何操作系统都是相同的。POST 检查硬件的基本可操作性，若失败则 Boot 过程将会被终止。
POST 检查完毕后会发出一个 BIOS 中断调用 INT 13H，它将在任何可连接且可引导的磁盘上搜索含有有效引导记录的引导扇区（boot sector），通常是 主引导扇区。引导扇区中的主引导记录（Master Boot Record，MBR）将被加载到 RAM 中，然后控制权就会转移到其手中。
Boot Loader 大多数 Linux 发行版使用三种 Boot Loader 程序：GRUB、GRUB2 和 LILO，其中 GRUB2 是最新且使用最为广泛的。GRUB2 代表“GRand Unified Bootloader, version 2”，它能够让计算机找到操作系统内核并将其加载到内存中。GRUB2 还允许用户选择从几种不同的内核中引导计算机，如果更新的内核版本出现兼容性问题，我们就可以恢复到先前内核版本。GRUB2 的引导过程可以分为以下三个阶段："><meta property="og:url" content="https://koktlzz.github.io/infrastructure/linux/boot/"><meta property="og:site_name" content="KnowledgeBase"><meta property="article:published_time" content="2021-02-24T22:05:45+08:00"><meta property="article:modified_time" content="2021-02-24T22:05:45+08:00"><meta property="og:image" content="https://koktlzz.github.io/doks.png"><meta property="og:image:alt" content="KnowledgeBase"><meta name=twitter:card content="summary_large_image"><meta name=twitter:site content="@getdoks"><meta name=twitter:creator content="@henkverlinde"><meta name=twitter:title content="Linux 启动流程"><meta name=twitter:description content><meta name=twitter:image content="https://koktlzz.github.io/doks.png"><meta name=twitter:image:alt content="Linux 启动流程"><script type=application/ld+json>{"@context":"https://schema.org","@graph":[{"@type":"Organization","@id":"https://koktlzz.github.io/#/schema/organization/1","name":"Doks","url":"https://koktlzz.github.io/","sameAs":["https://twitter.com/getdoks","https://github.com/h-enk/doks"],"logo":{"@type":"ImageObject","@id":"https://koktlzz.github.io/#/schema/image/1","url":"https://koktlzz.github.io/logo-doks.png","width":512,"height":512,"caption":"Doks"},"image":{"@id":"https://koktlzz.github.io/#/schema/image/1"}},{"@type":"WebSite","@id":"https://koktlzz.github.io/#/schema/website/1","url":"https://koktlzz.github.io/","name":"KnowledgeBase","description":"","publisher":{"@id":"https://koktlzz.github.io/#/schema/organization/1"}},{"@type":"WebPage","@id":"https://koktlzz.github.io/infrastructure/linux/boot/","url":"https://koktlzz.github.io/infrastructure/linux/boot/","name":"Linux 启动流程","description":"","isPartOf":{"@id":"https://koktlzz.github.io/#/schema/website/1"},"about":{"@id":"https://koktlzz.github.io/#/schema/organization/1"},"datePublished":"2021-02-24T22:05:45CET","dateModified":"2021-02-24T22:05:45CET","breadcrumb":{"@id":"https://koktlzz.github.io/infrastructure/linux/boot/#/schema/breadcrumb/1"},"primaryImageOfPage":{"@id":"https://koktlzz.github.io/infrastructure/linux/boot/#/schema/image/2"},"inLanguage":"en-US","potentialAction":[{"@type":"ReadAction","target":["https://koktlzz.github.io/infrastructure/linux/boot/"]}]},{"@type":"BreadcrumbList","@id":"https://koktlzz.github.io/infrastructure/linux/boot/#/schema/breadcrumb/1","name":"Breadcrumbs","itemListElement":[{"@type":"ListItem","position":1,"item":{"@type":"WebPage","@id":"https://koktlzz.github.io/","url":"https://koktlzz.github.io/","name":"Home"}},{"@type":"ListItem","position":2,"item":{"@type":"WebPage","@id":"https://koktlzz.github.io/infrastructure/","url":"https://koktlzz.github.io/infrastructure/","name":"Infrastructure"}},{"@type":"ListItem","position":3,"item":{"@type":"WebPage","@id":"https://koktlzz.github.io/infrastructure/linux/","url":"https://koktlzz.github.io/infrastructure/linux/","name":"Linux"}},{"@type":"ListItem","position":4,"item":{"@id":"https://koktlzz.github.io/infrastructure/linux/boot/"}}]},{"@context":"https://schema.org","@graph":[{"@type":"ImageObject","@id":"https://koktlzz.github.io/infrastructure/linux/boot/#/schema/image/2","url":"https://koktlzz.github.io/doks.png","contentUrl":"https://koktlzz.github.io/doks.png","caption":"Linux 启动流程"}]}]}</script><meta name=theme-color content="#fff"><link rel=apple-touch-icon sizes=180x180 href=https://koktlzz.github.io/apple-touch-icon.png><link rel=icon type=image/png sizes=32x32 href=https://koktlzz.github.io/favicon-32x32.ico><link rel=icon type=image/png sizes=16x16 href=https://koktlzz.github.io/favicon-16x16.ico><link rel=manifest crossorigin=use-credentials href=https://koktlzz.github.io/site.webmanifest></head><body class="Infrastructure single dark"><noscript><iframe src="https://www.googletagmanager.com/ns.html?id=GTM-P72R45W" height=0 width=0 style=display:none;visibility:hidden></iframe></noscript><div class="header-bar fixed-top"></div><header class="navbar fixed-top navbar-expand-md navbar-light"><div class=container-fluid><input class="menu-btn order-0" type=checkbox id=menu-btn>
<label class="menu-icon d-md-none" for=menu-btn><span class=navicon></span></label><a class="navbar-brand order-1 order-md-0 me-auto" href=https://koktlzz.github.io/>KnowledgeBase</a>
<button id=mode class="btn btn-link order-2 order-md-4" type=button aria-label="Toggle mode">
<span class=toggle-dark><svg xmlns="http://www.w3.org/2000/svg" width="20" height="20" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="feather feather-moon"><path d="M21 12.79A9 9 0 1111.21 3 7 7 0 0021 12.79z"/></svg></span><span class=toggle-light><svg xmlns="http://www.w3.org/2000/svg" width="20" height="20" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="feather feather-sun"><circle cx="12" cy="12" r="5"/><line x1="12" y1="1" x2="12" y2="3"/><line x1="12" y1="21" x2="12" y2="23"/><line x1="4.22" y1="4.22" x2="5.64" y2="5.64"/><line x1="18.36" y1="18.36" x2="19.78" y2="19.78"/><line x1="1" y1="12" x2="3" y2="12"/><line x1="21" y1="12" x2="23" y2="12"/><line x1="4.22" y1="19.78" x2="5.64" y2="18.36"/><line x1="18.36" y1="5.64" x2="19.78" y2="4.22"/></svg></span></button><ul class="navbar-nav social-nav order-3 order-md-5"><li class=nav-item><a class=nav-link href=https://github.com/koktlzz><svg xmlns="http://www.w3.org/2000/svg" width="20" height="20" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="feather feather-github"><path d="M9 19c-5 1.5-5-2.5-7-3m14 6v-3.87a3.37 3.37.0 00-.94-2.61c3.14-.35 6.44-1.54 6.44-7A5.44 5.44.0 0020 4.77 5.07 5.07.0 0019.91 1S18.73.65 16 2.48a13.38 13.38.0 00-7 0C6.27.65 5.09 1 5.09 1A5.07 5.07.0 005 4.77 5.44 5.44.0 003.5 8.55c0 5.42 3.3 6.61 6.44 7A3.37 3.37.0 009 18.13V22"/></svg><span class="ms-2 visually-hidden">GitHub</span></a></li></ul><div class="collapse navbar-collapse order-4 order-md-1"><ul class="navbar-nav main-nav me-auto order-5 order-md-2"><li class=nav-item><a class=nav-link href=https://koktlzz.github.io/container/docker/intro>Container</a></li><li class=nav-item><a class=nav-link href=https://koktlzz.github.io/observability/elasticstack/intro>Observability</a></li><li class=nav-item><a class=nav-link href=https://koktlzz.github.io/programming/go/intro>Programming</a></li><li class=nav-item><a class=nav-link href=https://koktlzz.github.io/infrastructure/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/tcpip%E7%BD%91%E7%BB%9C%E6%A8%A1%E5%9E%8B>Infrastructure</a></li></ul><div class="break order-6 d-md-none"></div></div></div></header><div class="wrap container-fluid" role=document><div class=content><div class="row flex-xl-nowrap"><div class="col-lg-4 col-xl-3 d-none d-xl-block"><nav class=docs-links aria-label="Main navigation"><h3>计算机网络</h3><ul class=list-unstyled><li><a class=docs-link href=https://koktlzz.github.io/infrastructure/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/tcpip%E7%BD%91%E7%BB%9C%E6%A8%A1%E5%9E%8B/>TCP/IP 网络模型</a></li><li><a class=docs-link href=https://koktlzz.github.io/infrastructure/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/dnshttps/>DNS、UDP 与 HTTPS</a></li><li><a class=docs-link href=https://koktlzz.github.io/infrastructure/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/%E8%99%9A%E6%8B%9F%E6%9C%BA%E7%BD%91%E7%BB%9C/>虚拟机网络</a></li><li><a class=docs-link href=https://koktlzz.github.io/infrastructure/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/vlan/>VLAN</a></li></ul><h3>CSAPP</h3><ul class=list-unstyled><li><a class=docs-link href=https://koktlzz.github.io/infrastructure/csapp/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9F%E4%B9%8B%E6%97%85/>计算机系统之旅</a></li><li><a class=docs-link href=https://koktlzz.github.io/infrastructure/csapp/%E4%BF%A1%E6%81%AF%E7%9A%84%E8%A1%A8%E7%A4%BA%E5%92%8C%E5%A4%84%E7%90%86/>信息的表示和处理</a></li><li><a class=docs-link href=https://koktlzz.github.io/infrastructure/csapp/%E7%A8%8B%E5%BA%8F%E7%9A%84%E6%9C%BA%E5%99%A8%E7%BA%A7%E8%A1%A8%E7%A4%BA/>程序的机器级表示</a></li></ul><h3>Linux</h3><ul class=list-unstyled><li><a class=docs-link href=https://koktlzz.github.io/infrastructure/linux/boot/>Linux 启动流程</a></li><li><a class=docs-link href=https://koktlzz.github.io/infrastructure/linux/filepermission/>文件权限</a></li></ul></nav></div><main class="docs-content col-lg-12 col-xl-10"><h1>Linux 启动流程</h1><p class=lead></p><p>TODO:</p><ul><li>Set Root</li><li>Initerd/initramfs</li></ul><p>启动一台 Linux 机器的过程可以分为两个部分：Boot 和 Startup。其中，Boot 起始于计算机启动，在内核初始化完成且 Systemd 进程开始加载后结束。紧接着， Startup 接管任务，使计算机达到一个用户可操作的状态。</p><p><img src=https://cdn.jsdelivr.net/gh/koktlzz/ImgBed@master/202110171642.jpeg alt=202110171642></p><h2 id=boot>Boot<a href=#boot class=anchor aria-hidden=true>#</a></h2><p>如上图所示，Boot 过程又可以详细地分为三个部分：</p><ul><li>BIOS POST</li><li>Boot Loader</li><li>内核初始化</li></ul><h3 id=bios-post>BIOS POST<a href=#bios-post class=anchor aria-hidden=true>#</a></h3><p>开机自检（Power On Self Test，POST）是 <a href=https://zh.wikipedia.org/wiki/BIOS>基本输入输出系统</a>（Basic I/O System，BIOS）的一部分，也是启动 Linux 机器的第一个步骤。其工作对象是计算机硬件，因此对于任何操作系统都是相同的。<strong>POST 检查硬件的基本可操作性</strong>，若失败则 Boot 过程将会被终止。</p><p>POST 检查完毕后会发出一个 BIOS 中断调用 <a href=https://en.wikipedia.org/wiki/INT_13H>INT 13H</a>，它将在任何可连接且可引导的磁盘上搜索含有有效引导记录的引导扇区（boot sector），通常是 <a href=https://zh.wikipedia.org/wiki/%E4%B8%BB%E5%BC%95%E5%AF%BC%E8%AE%B0%E5%BD%95>主引导扇区</a>。引导扇区中的主引导记录（Master Boot Record，MBR）将被加载到 RAM 中，然后控制权就会转移到其手中。</p><h3 id=boot-loader>Boot Loader<a href=#boot-loader class=anchor aria-hidden=true>#</a></h3><p>大多数 Linux 发行版使用三种 Boot Loader 程序：GRUB、GRUB2 和 LILO，其中 GRUB2 是最新且使用最为广泛的。GRUB2 代表“GRand Unified Bootloader, version 2”，<strong>它能够让计算机找到操作系统内核并将其加载到内存中</strong>。GRUB2 还允许用户选择从几种不同的内核中引导计算机，如果更新的内核版本出现兼容性问题，我们就可以恢复到先前内核版本。GRUB2 的引导过程可以分为以下三个阶段：</p><h4 id=stage-1>stage 1<a href=#stage-1 class=anchor aria-hidden=true>#</a></h4><p>上文提到，BIOS 中断调用会定位主引导扇区，其结构如下图所示：</p><p><img src=https://cdn.jsdelivr.net/gh/koktlzz/NoteImg@main/20211015161614.png alt=20211015161614></p><p>主引导记录首部的引导代码便是 stage 1 文件 boot.img，大小仅有 446 字节。其作用是检查分区表是否正确，然后<strong>定位和加载 stage 1.5</strong>。当 stage 1.5 加载到 RAM 后，控制权也随之转移。</p><h4 id=stage-15>stage 1.5<a href=#stage-15 class=anchor aria-hidden=true>#</a></h4><p>446 字节的 stage 1 文件放不下能够识别文件系统的代码，只能通过计算扇区的偏移量来定位和加载 stage 1.5，因此 stage 1.5 文件 core.img 必须位于主引导记录和驱动器的第一个分区（partition）之间。第一个分区从扇区 63 开始，与位于扇区 0 的主引导记录之间有 62 个扇区（每个 512 字节），因此有足够的空间存储大小为 25389 字节的 core.img 文件。</p><p>core.img 文件中包含一些常见的文件系统驱动程序，如 EXT、FAT 和 NTFS 等，它和 boot.img 文件均位于 /boot/grub2 目录下：</p><div class=highlight><pre style=color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=color:#ff79c6>[</span>root@bastion ~<span style=color:#ff79c6>]</span><span style=color:#6272a4># ls /boot/grub2/i386-pc/ | grep img</span>
boot.img
core.img
</code></pre></div><p>既然 core.img 文件可以识别文件系统，那么它就能够根据安装时确定的系统路径<strong>定位和加载 stage 2</strong>。同样，当 stage 2 加载到 RAM 后，控制权也随之转移。</p><h4 id=stage-2>stage 2<a href=#stage-2 class=anchor aria-hidden=true>#</a></h4><p>stage 2 文件并非是一个 .img 的镜像，而是一些运行时内核模块：</p><div class=highlight><pre style=color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=color:#ff79c6>[</span>root@bastion ~<span style=color:#ff79c6>]</span><span style=color:#6272a4># ls /boot/grub2/i386-pc/ | grep .mod | head</span>
acpi.mod
adler32.mod
affs.mod
afs.mod
ahci.mod
all_video.mod
aout.mod
appendedsig.mod
appended_signature_test.mod
archelp.mod
</code></pre></div><p>它们的任务是根据 grub.cfg 文件的配置<strong>定位和加载内核文件</strong>，然后将控制权转交给 Linux 内核。grub.cfg 文件存放在 /boot/grub2 目录下：</p><div class=highlight><pre style=color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=color:#ff79c6>[</span>root@bastion ~<span style=color:#ff79c6>]</span><span style=color:#6272a4># head /boot/grub2/grub.cfg -n 5</span>
<span style=color:#6272a4>#</span>
<span style=color:#6272a4># DO NOT EDIT THIS FILE</span>
<span style=color:#6272a4>#</span>
<span style=color:#6272a4># It is automatically generated by grub2-mkconfig using templates</span>
<span style=color:#6272a4># from /etc/grub.d and settings from /etc/default/grub</span>
</code></pre></div><p>根据该文件的注释我们可以知道，它实际上是由 grub2-mkconfig 命令使用 /etc/grub.d 目录下的一些模板文件并根据 /etc/default/grub 文件中的设置而生成的：</p><div class=highlight><pre style=color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=color:#ff79c6>[</span>root@bastion ~<span style=color:#ff79c6>]</span><span style=color:#6272a4># ls /etc/grub.d/</span>
00_header  00_tuned  01_users  10_linux  20_linux_xen  20_ppc_terminfo  30_os-prober  40_custom  41_custom  README
</code></pre></div><p>40_custom 和 41_custom 文件常用于用户对 GRUB2 配置的修改。如将一台 CentOS 系统的计算机升级为 CoreOS 系统，可在 40_custom 文件末尾追加如下配置：</p><div class=highlight><pre style=color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell>menuentry <span style=color:#f1fa8c>&#39;coreos&#39;</span> <span style=color:#ff79c6>{</span>
        <span style=color:#8be9fd;font-style:italic>set</span> <span style=color:#8be9fd;font-style:italic>root</span><span style=color:#ff79c6>=</span><span style=color:#f1fa8c>&#39;hd0,msdos1&#39;</span>
        linux16 /rhcos-live-kernel-x86_64 coreos.inst<span style=color:#ff79c6>=</span>yes coreos.inst.install_dev<span style=color:#ff79c6>=</span>vda rd.neednet<span style=color:#ff79c6>=</span><span style=color:#bd93f9>1</span> <span style=color:#8be9fd;font-style:italic>console</span><span style=color:#ff79c6>=</span>tty0 <span style=color:#8be9fd;font-style:italic>console</span><span style=color:#ff79c6>=</span>ttyS0 coreos.live.rootfs_url<span style=color:#ff79c6>=</span>http://<span style=color:#ff79c6>{{</span>HTTP-Server-Path<span style=color:#ff79c6>}}</span>/rhcos-live-rootfs.x86_64.img coreos.inst.ignition_url<span style=color:#ff79c6>=</span>http://<span style=color:#ff79c6>{{</span>HTTP-Server-Path<span style=color:#ff79c6>}}</span>/master.ign <span style=color:#8be9fd;font-style:italic>ip</span><span style=color:#ff79c6>=</span>dhcp
        initrd16 /rhcos-live-initramfs.x86_64.img
<span style=color:#ff79c6>}</span>
</code></pre></div><p>Menuentry 中实际上包含了三个 Shell 命令：</p><ul><li><code>set root='hd0,msdos1'</code>：指定 GRUB2 文件在计算机硬件上的位置。本例中的 hd 代表硬盘（hard drive），0 代表第一块硬盘，mosdos 代表分区格式，1 代表第一个分区。详细的硬件命名规范见 <a href=https://www.gnu.org/software/grub/manual/grub/grub.html#Naming-convention>Naming Convention</a>；</li><li><code>linux16 /rhcos-live-kernel-x86_64</code>：以 16 位模式从 rhcos-live-kernel-x86_64 文件中加载 Linux 内核映像。本例中还分别通过 coreos.live.rootfs_url 和 coreos.inst.ignition_url 参数指定 rootfs 镜像文件和点火文件的下载链接，<code>ip=dhcp</code>则代表该计算机网络将由 DHCP 服务器动态配置。当然也可以写入静态配置，其标准格式为：<code>ip={{HostIP}}::{{Gateway}}:{{Genmask}}:{{Hostname}}::none nameserver={{DNSServer}}</code>；</li><li><code>initrd16 /rhcos-live-initramfs.x86_64.img</code>：加载 Linux 内核所需的初始 ramdisk。</li></ul><blockquote><p>在早期的 Linux 系统中，一般就只有软盘或者硬盘被用来作为 Linux 的根文件系统，因此很容易把这些设备的驱动程序集成到内核中。但是现在根文件系统 可能保存在各种存储设备上，包括 SCSI, SATA, U 盘等等。因此把这些设备驱动程序全部编译到内核中显得不太方便。在 Linux 内核模块自动加载机制的介绍中，我们看到利用 udevd 可以实现实现内核模 块的自动加载，因此我们希望根文件系统的设备驱动程序也能够实现自动加载。但是这里有一个矛盾，udevd 是一个可执行文件，在根文件系统被挂载前，是不 可能执行 udevd 的，但是如果 udevd 没有启动，那就无法自动加载根根据系统设备的驱动程序，同时也无法在/dev 目录下建立相应的设备节点。为了解决这个矛盾，于是出现了 initrd(boot loader initialized RAM disk)。initrd 是一个被压缩过的小型根目录，这个目录中包含了启动阶段中必须的驱动模块，可执行文件和启动脚本。包括上面提到的 udevd，当 系统启动的时候，booload 会把 initrd 文件读到内存中，然后把 initrd 的起始地址告诉内核。内核在运行过程中会解压 initrd，然后把 initrd 挂载为根目录，然后执行根目录中的/initrc 脚本，您可以在这个脚本中运行 initrd 中的 udevd，让它来自动加载设备驱动程序以及 在/dev 目录下建立必要的设备节点。在 udevd 自动加载磁盘驱动程序之后，就可以 mount 真正的根目录，并切换到这个根目录中。
Linux 启动需要加载内核文件，但需要文件系统；而使用文件系统有需要内核，这就产生了一个先有鸡还是先有蛋的问题。</p><p>initrd(Initial RAM Disk)，它在 stage2 这个步骤就被拷贝到了内存中，这个文件是在安装系统时产生的，是一个临时的根文件系统 (rootfs)。因为 Kernel 为了精简，只保留了最基本的模块，因此，Kernel 上并没有各种硬件的驱动程序，也就无法识 rootfs 所在的设备，故产生了 initrd 这个文件，该文件装载了必要的驱动模块，当 Kernel 启动时，可以从 initrd 文件中装载驱动模块，直到挂载真正的 rootfs，然后将 initrd 从内存中移除。</p></blockquote><p>除此之外还需要将 /etc/default/grub 文件中的 <a href=https://www.gnu.org/software/grub/manual/grub/grub.html#Simple-configuration>GRUB_DEFAULT=saved</a> 修改为 GRUB_DEFAULT=&ldquo;coreos&rdquo;，使其与 40_custom 文件中的<code>menuentry 'coreos'</code>对应。最后使用命令<code>grub2-mkconfig -o /boot/grub2/grub.cfg</code>重新生成一份 grub.cfg 文件，这样系统重启后 GRUB2 就会根据我们的配置来加载内核了。</p><h3 id=内核初始化>内核初始化<a href=#内核初始化 class=anchor aria-hidden=true>#</a></h3><p>不同内核及其相关文件位于 /boot 目录中，均以 vmlinuz 开头：</p><div class=highlight><pre style=color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=color:#ff79c6>[</span>root@bastion ~<span style=color:#ff79c6>]</span><span style=color:#6272a4># ls /boot/ | grep vmlinuz</span>
vmlinuz-0-rescue-20210623110808105647395700239158
vmlinuz-4.18.0-305.12.1.el8_4.x86_64
vmlinuz-4.18.0-305.3.1.el8.x86_64
</code></pre></div><p>内核通过压缩自身来节省存储空间，所以当选定的内核被加载到内存中后，它首先需要进行解压缩（extracting）。一旦解压完成，内核便会开始<strong>加载 Systemd 并将控制权移交给它</strong>。此时 Boot 阶段全部完成，只有 Linux 内核和 Systemd 正在运行，因此用户还无法执行任何任务。</p><h2 id=startup>Startup<a href=#startup class=anchor aria-hidden=true>#</a></h2><h2 id=参考文献>参考文献<a href=#参考文献 class=anchor aria-hidden=true>#</a></h2><p><a href=https://zh.wikipedia.org/wiki/BIOS>BIOS - Wikipedia</a></p><p><a href=https://en.wikipedia.org/wiki/INT_13H>INT 13H - Wikipedia</a></p><p><a href=https://zh.wikipedia.org/wiki/%E4%B8%BB%E5%BC%95%E5%AF%BC%E8%AE%B0%E5%BD%95>主引导记录 - Wikipedia</a></p><p><a href=https://opensource.com/article/17/2/linux-boot-and-startup>An Introduction To the Linux Boot and Startup Processes</a></p><p><a href=https://linux.cn/article-8603-1.html>Linux GRUB2 配置简介</a></p><p><a href=https://www.gnu.org/software/grub/manual/grub/grub.html>GNU GRUB Manual 2.06</a></p><p class=edit-page><a href=https://github.com/koktlzz/koktlzz.github.io/blob/master/content/Infrastructure/Linux/Boot.md><svg xmlns="http://www.w3.org/2000/svg" width="16" height="16" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="feather feather-edit-2"><path d="M17 3a2.828 2.828.0 114 4L7.5 20.5 2 22l1.5-5.5L17 3z"/></svg>Edit this page on GitHub</a></p><div class="docs-navigation d-flex justify-content-between"><a href=https://koktlzz.github.io/infrastructure/csapp/%E7%A8%8B%E5%BA%8F%E7%9A%84%E6%9C%BA%E5%99%A8%E7%BA%A7%E8%A1%A8%E7%A4%BA/><div class="card my-1"><div class="card-body py-2">&larr; 程序的机器级表示</div></div></a><a class=ms-auto href=https://koktlzz.github.io/infrastructure/linux/filepermission/><div class="card my-1"><div class="card-body py-2">文件权限 &rarr;</div></div></a></div><script src=https://utteranc.es/client.js repo=koktlzz/koktlzz.github.io issue-term=pathname theme=photon-dark crossorigin=anonymous async></script></main><nav class="docs-toc d-none d-xl-block col-lg-3 col-xl-2" aria-label="Secondary navigation"><div class=page-links><h3>On this page</h3><nav id=TableOfContents><ul><li><a href=#boot>Boot</a><ul><li><a href=#bios-post>BIOS POST</a></li><li><a href=#boot-loader>Boot Loader</a></li><li><a href=#内核初始化>内核初始化</a></li></ul></li><li><a href=#startup>Startup</a></li><li><a href=#参考文献>参考文献</a></li></ul></nav></div></nav></div></div></div><script src=https://koktlzz.github.io/js/bootstrap.min.d67050adf5d370668aede4201f82af781b16970934804995a1ca37c1ee9222c2fc530972aa6d5d2b6124caf1fe318f139aac99df2c1e89af65504fc1185c7972.js integrity="sha512-1nBQrfXTcGaK7eQgH4KveBsWlwk0gEmVoco3we6SIsL8Uwlyqm1dK2EkyvH+MY8TmqyZ3yweia9lUE/BGFx5cg==" crossorigin=anonymous defer></script><script src=https://koktlzz.github.io/js/vendor/katex/dist/katex.min.b334e5b00c45f572e7f38a543046f36854bf4cbb543880480c09271a0efedc694d6905f719934f6ede2f26f52e80411c05b90121d722cbf8be2fa8fc51bc6b81.js integrity="sha512-szTlsAxF9XLn84pUMEbzaFS/TLtUOIBIDAknGg7+3GlNaQX3GZNPbt4vJvUugEEcBbkBIdciy/i+L6j8UbxrgQ==" crossorigin=anonymous defer></script><script src=https://koktlzz.github.io/js/vendor/katex/dist/contrib/auto-render.min.916823ec103cf367b71e28a6f01513cb9c3ac6708ccb5229402ec46b8e30a8b25003db694df35d80e9dd666a371f327c6152790617b6256390c164109a90bd4c.js integrity="sha512-kWgj7BA882e3Hiim8BUTy5w6xnCMy1IpQC7Ea44wqLJQA9tpTfNdgOndZmo3HzJ8YVJ5Bhe2JWOQwWQQmpC9TA==" crossorigin=anonymous defer></script><script src=https://koktlzz.github.io/main.min.1febbf2f6fd6a36fc2f57dd50d7935fbb640743329baeb4ef7cefcf2e7630e413371fbba976e103656b82808ee227dc4a84237edb0f8433648bef3a56900661a.js integrity="sha512-H+u/L2/Wo2/C9X3VDXk1+7ZAdDMpuutO98788udjDkEzcfu6l24QNla4KAjuIn3EqEI37bD4QzZIvvOlaQBmGg==" crossorigin=anonymous defer></script></body></html>