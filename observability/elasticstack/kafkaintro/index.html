<!doctype html><html lang=en-us><head><script async src="https://www.googletagmanager.com/gtag/js?id=G-D022F6NT2P"></script><script>window.dataLayer=window.dataLayer||[];function gtag(){dataLayer.push(arguments)}gtag('js',new Date),gtag('config','G-D022F6NT2P')</script><script>(function(b,d,e,a,g){b[a]=b[a]||[],b[a].push({'gtm.start':(new Date).getTime(),event:'gtm.js'});var f=d.getElementsByTagName(e)[0],c=d.createElement(e),h=a!='dataLayer'?'&l='+a:'';c.async=!0,c.src='https://www.googletagmanager.com/gtm.js?id='+g+h,f.parentNode.insertBefore(c,f)})(window,document,'script','dataLayer','GTM-P72R45W')</script><meta charset=utf-8><meta http-equiv=x-ua-compatible content="ie=edge"><meta name=viewport content="width=device-width,initial-scale=1,shrink-to-fit=no"><link rel=preload as=font href=https://koktlzz.github.io/fonts/vendor/jost/jost-v4-latin-regular.woff2 type=font/woff2 crossorigin><link rel=preload as=font href=https://koktlzz.github.io/fonts/vendor/jost/jost-v4-latin-700.woff2 type=font/woff2 crossorigin><link rel=preload as=font href=https://koktlzz.github.io/fonts/KaTeX_Main-Regular.woff2 type=font/woff2 crossorigin><link rel=preload as=font href=https://koktlzz.github.io/fonts/KaTeX_Math-Italic.woff2 type=font/woff2 crossorigin><link rel=stylesheet href=https://koktlzz.github.io/main.09ec2f025fdb9f947415a273a44df08d5f3ec03e47aaa8b29ade63a14a6c9a7bc68d57acd1f4c9231d9c21a0673bb8280a543e2552346241f7c2b9c86274c6ff.css integrity="sha512-CewvAl/bn5R0FaJzpE3wjV8+wD5Hqqiymt5joUpsmnvGjVes0fTJIx2cIaBnO7goClQ+JVI0YkH3wrnIYnTG/w==" crossorigin=anonymous><noscript><style>img.lazyload{display:none}</style></noscript><meta name=robots content="index, follow"><meta name=googlebot content="index, follow, max-snippet:-1, max-image-preview:large, max-video-preview:-1"><meta name=bingbot content="index, follow, max-snippet:-1, max-image-preview:large, max-video-preview:-1"><title>Kafka 简介 | KnowledgeBase</title><meta name=description content><link rel=canonical href=https://koktlzz.github.io/observability/elasticstack/kafkaintro/><meta property="og:locale" content="en_US"><meta property="og:type" content="article"><meta property="og:title" content="Kafka 简介"><meta property="og:description" content="架构 概念  Broker：Kafka 集群中的一台或多台服务器； Topic：逻辑概念。根据消息的类型，将其分为各种主题（Topic），以此区分不同的业务数据； Partition：物理概念。每个 Topic 可分为多个分区（Partition），而每个 Partition 都是有序且顺序不变的消息队列； Offset：每条消息都会被分配一个连续的、在其 Partition 内唯一的标识来记录顺序，即偏移量（Offset）；   Replica：可以为每个 Partition 创建副本（Replica）来实现高可用； Leader/Follwer：一个 Leader 副本处理读写请求，多个 Follower 副本同步数据。每台 Broker 上都维护着某些 Partition 的 Leader 副本和某些 Partition 的 Follower 副本，因此集群的负载是均衡的； Producer：消息的生产者，将数据主动发送到指定的 Topic； Consumer：消息的消费者，从订阅的 Topic 中主动拉取数据； Consumer Group：将多个 Consumer 划分为组，组内的 Consumer 可以并行地消费 Topic 中的数据； Zookeeper：Kafka 集群中的一个 Broker 会被选举为 Controller，负责管理集群中其他 Broker 的上下线、Partition 副本的分配和 ISR 成员变化、Leader 的选举等工作。而 Controller 的管理工作依赖于 Zookeeper，Broker 必须能通过 Zookeeper 的心跳机制维持其与 Zookeeper 的会话。  基本配置 [root@test-ece-kafka2 kafka_2.11-1.1.1]# ls config/ connect-console-sink."><meta property="og:url" content="https://koktlzz.github.io/observability/elasticstack/kafkaintro/"><meta property="og:site_name" content="KnowledgeBase"><meta property="article:published_time" content="2020-11-04T09:19:42+01:00"><meta property="article:modified_time" content="2020-11-04T09:19:42+01:00"><meta property="og:image" content="https://koktlzz.github.io/doks.png"><meta property="og:image:alt" content="KnowledgeBase"><meta name=twitter:card content="summary_large_image"><meta name=twitter:site content="@getdoks"><meta name=twitter:creator content="@henkverlinde"><meta name=twitter:title content="Kafka 简介"><meta name=twitter:description content><meta name=twitter:image content="https://koktlzz.github.io/doks.png"><meta name=twitter:image:alt content="Kafka 简介"><script type=application/ld+json>{"@context":"https://schema.org","@graph":[{"@type":"Organization","@id":"https://koktlzz.github.io/#/schema/organization/1","name":"Doks","url":"https://koktlzz.github.io/","sameAs":["https://twitter.com/getdoks","https://github.com/h-enk/doks"],"logo":{"@type":"ImageObject","@id":"https://koktlzz.github.io/#/schema/image/1","url":"https://koktlzz.github.io/logo-doks.png","width":512,"height":512,"caption":"Doks"},"image":{"@id":"https://koktlzz.github.io/#/schema/image/1"}},{"@type":"WebSite","@id":"https://koktlzz.github.io/#/schema/website/1","url":"https://koktlzz.github.io/","name":"KnowledgeBase","description":"","publisher":{"@id":"https://koktlzz.github.io/#/schema/organization/1"}},{"@type":"WebPage","@id":"https://koktlzz.github.io/observability/elasticstack/kafkaintro/","url":"https://koktlzz.github.io/observability/elasticstack/kafkaintro/","name":"Kafka 简介","description":"","isPartOf":{"@id":"https://koktlzz.github.io/#/schema/website/1"},"about":{"@id":"https://koktlzz.github.io/#/schema/organization/1"},"datePublished":"2020-11-04T09:19:42CET","dateModified":"2020-11-04T09:19:42CET","breadcrumb":{"@id":"https://koktlzz.github.io/observability/elasticstack/kafkaintro/#/schema/breadcrumb/1"},"primaryImageOfPage":{"@id":"https://koktlzz.github.io/observability/elasticstack/kafkaintro/#/schema/image/2"},"inLanguage":"en-US","potentialAction":[{"@type":"ReadAction","target":["https://koktlzz.github.io/observability/elasticstack/kafkaintro/"]}]},{"@type":"BreadcrumbList","@id":"https://koktlzz.github.io/observability/elasticstack/kafkaintro/#/schema/breadcrumb/1","name":"Breadcrumbs","itemListElement":[{"@type":"ListItem","position":1,"item":{"@type":"WebPage","@id":"https://koktlzz.github.io/","url":"https://koktlzz.github.io/","name":"Home"}},{"@type":"ListItem","position":2,"item":{"@type":"WebPage","@id":"https://koktlzz.github.io/observability/","url":"https://koktlzz.github.io/observability/","name":"Observability"}},{"@type":"ListItem","position":3,"item":{"@type":"WebPage","@id":"https://koktlzz.github.io/observability/elasticstack/","url":"https://koktlzz.github.io/observability/elasticstack/","name":"Elasticstack"}},{"@type":"ListItem","position":4,"item":{"@id":"https://koktlzz.github.io/observability/elasticstack/kafkaintro/"}}]},{"@context":"https://schema.org","@graph":[{"@type":"ImageObject","@id":"https://koktlzz.github.io/observability/elasticstack/kafkaintro/#/schema/image/2","url":"https://koktlzz.github.io/doks.png","contentUrl":"https://koktlzz.github.io/doks.png","caption":"Kafka 简介"}]}]}</script><meta name=theme-color content="#fff"><link rel=apple-touch-icon sizes=180x180 href=https://koktlzz.github.io/apple-touch-icon.png><link rel=icon type=image/png sizes=32x32 href=https://koktlzz.github.io/favicon-32x32.ico><link rel=icon type=image/png sizes=16x16 href=https://koktlzz.github.io/favicon-16x16.ico><link rel=manifest crossorigin=use-credentials href=https://koktlzz.github.io/site.webmanifest></head><body class="Observability single dark"><noscript><iframe src="https://www.googletagmanager.com/ns.html?id=GTM-P72R45W" height=0 width=0 style=display:none;visibility:hidden></iframe></noscript><div class="header-bar fixed-top"></div><header class="navbar fixed-top navbar-expand-md navbar-light"><div class=container-fluid><input class="menu-btn order-0" type=checkbox id=menu-btn>
<label class="menu-icon d-md-none" for=menu-btn><span class=navicon></span></label><a class="navbar-brand order-1 order-md-0 me-auto" href=https://koktlzz.github.io/>KnowledgeBase</a>
<button id=mode class="btn btn-link order-2 order-md-4" type=button aria-label="Toggle mode">
<span class=toggle-dark><svg xmlns="http://www.w3.org/2000/svg" width="20" height="20" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="feather feather-moon"><path d="M21 12.79A9 9 0 1111.21 3 7 7 0 0021 12.79z"/></svg></span><span class=toggle-light><svg xmlns="http://www.w3.org/2000/svg" width="20" height="20" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="feather feather-sun"><circle cx="12" cy="12" r="5"/><line x1="12" y1="1" x2="12" y2="3"/><line x1="12" y1="21" x2="12" y2="23"/><line x1="4.22" y1="4.22" x2="5.64" y2="5.64"/><line x1="18.36" y1="18.36" x2="19.78" y2="19.78"/><line x1="1" y1="12" x2="3" y2="12"/><line x1="21" y1="12" x2="23" y2="12"/><line x1="4.22" y1="19.78" x2="5.64" y2="18.36"/><line x1="18.36" y1="5.64" x2="19.78" y2="4.22"/></svg></span></button><ul class="navbar-nav social-nav order-3 order-md-5"><li class=nav-item><a class=nav-link href=https://github.com/koktlzz><svg xmlns="http://www.w3.org/2000/svg" width="20" height="20" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="feather feather-github"><path d="M9 19c-5 1.5-5-2.5-7-3m14 6v-3.87a3.37 3.37.0 00-.94-2.61c3.14-.35 6.44-1.54 6.44-7A5.44 5.44.0 0020 4.77 5.07 5.07.0 0019.91 1S18.73.65 16 2.48a13.38 13.38.0 00-7 0C6.27.65 5.09 1 5.09 1A5.07 5.07.0 005 4.77 5.44 5.44.0 003.5 8.55c0 5.42 3.3 6.61 6.44 7A3.37 3.37.0 009 18.13V22"/></svg><span class="ms-2 visually-hidden">GitHub</span></a></li></ul><div class="collapse navbar-collapse order-4 order-md-1"><ul class="navbar-nav main-nav me-auto order-5 order-md-2"><li class=nav-item><a class=nav-link href=https://koktlzz.github.io/container/docker/intro>Container</a></li><li class=nav-item><a class=nav-link href=https://koktlzz.github.io/observability/elasticstack/intro>Observability</a></li><li class=nav-item><a class=nav-link href=https://koktlzz.github.io/programming/go/intro>Programming</a></li><li class=nav-item><a class=nav-link href=https://koktlzz.github.io/infrastructure/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/tcpip%E7%BD%91%E7%BB%9C%E6%A8%A1%E5%9E%8B>Infrastructure</a></li></ul><div class="break order-6 d-md-none"></div></div></div></header><div class="wrap container-fluid" role=document><div class=content><div class="row flex-xl-nowrap"><div class="col-lg-4 col-xl-3 d-none d-xl-block"><nav class=docs-links aria-label="Main navigation"><h3>ElasticStack</h3><ul class=list-unstyled><li><a class=docs-link href=https://koktlzz.github.io/observability/elasticstack/intro/>Getting Started</a></li><li><a class=docs-link href=https://koktlzz.github.io/observability/elasticstack/%E5%8D%95%E8%8A%82%E7%82%B9%E9%83%A8%E7%BD%B2%E6%B5%81%E7%A8%8B/>单节点部署流程</a></li><li><a class=docs-link href=https://koktlzz.github.io/observability/elasticstack/elasticsearchintro/>ElasticSearch 简介</a></li><li><a class=docs-link href=https://koktlzz.github.io/observability/elasticstack/mapping/>Mapping</a></li><li><a class=docs-link href=https://koktlzz.github.io/observability/elasticstack/textanalysis/>Text analysis</a></li><li><a class=docs-link href=https://koktlzz.github.io/observability/elasticstack/template/>Template</a></li><li><a class=docs-link href=https://koktlzz.github.io/observability/elasticstack/ilm/>ILM</a></li><li><a class=docs-link href=https://koktlzz.github.io/observability/elasticstack/snapshot/>Snapshot</a></li><li><a class=docs-link href=https://koktlzz.github.io/observability/elasticstack/%E6%80%A7%E8%83%BD%E8%B0%83%E4%BC%98/>Elasticsearch 性能调优</a></li><li><a class=docs-link href=https://koktlzz.github.io/observability/elasticstack/kafkaintro/>Kafka 简介</a></li><li><a class=docs-link href=https://koktlzz.github.io/observability/elasticstack/hw/>Kafka 副本备份</a></li><li><a class=docs-link href=https://koktlzz.github.io/observability/elasticstack/transaction/>Kafka 事务</a></li></ul><h3>Prometheus</h3><ul class=list-unstyled><li><a class=docs-link href=https://koktlzz.github.io/observability/prometheus/intro/>Getting Started</a></li><li><a class=docs-link href=https://koktlzz.github.io/observability/prometheus/operator%E8%87%AA%E5%AE%9A%E4%B9%89%E9%85%8D%E7%BD%AE/>Operator 自定义配置</a></li></ul><h3>Opentelemetry</h3><ul class=list-unstyled><li><a class=docs-link href=https://koktlzz.github.io/observability/opentelemetry/intro/>Getting Started</a></li><li><a class=docs-link href=https://koktlzz.github.io/observability/opentelemetry/collectorexample/>Collector Example</a></li></ul></nav></div><main class="docs-content col-lg-12 col-xl-10"><h1>Kafka 简介</h1><p class=lead></p><h2 id=架构>架构<a href=#架构 class=anchor aria-hidden=true>#</a></h2><p><img src=https://cdn.jsdelivr.net/gh/koktlzz/ImgBed@master/202103212048.jpeg alt=202103212048></p><h2 id=概念>概念<a href=#概念 class=anchor aria-hidden=true>#</a></h2><ul><li>Broker：Kafka 集群中的一台或多台服务器；</li><li>Topic：逻辑概念。根据消息的类型，将其分为各种主题（Topic），以此区分不同的业务数据；</li><li>Partition：物理概念。每个 Topic 可分为多个分区（Partition），而每个 Partition 都是有序且顺序不变的消息队列；</li><li>Offset：每条消息都会被分配一个连续的、在其 Partition 内唯一的标识来记录顺序，即偏移量（Offset）；</li></ul><p><img src=https://cdn.jsdelivr.net/gh/koktlzz/ImgBed@master/202103211905.png alt=202103211905></p><ul><li>Replica：可以为每个 Partition 创建副本（Replica）来实现高可用；</li><li>Leader/Follwer：一个 Leader 副本处理读写请求，多个 Follower 副本同步数据。每台 Broker 上都维护着某些 Partition 的 Leader 副本和某些 Partition 的 Follower 副本，因此集群的负载是均衡的；</li><li>Producer：消息的生产者，将数据主动发送到指定的 Topic；</li><li>Consumer：消息的消费者，从订阅的 Topic 中主动拉取数据；</li><li>Consumer Group：将多个 Consumer 划分为组，组内的 Consumer 可以并行地消费 Topic 中的数据；</li><li>Zookeeper：Kafka 集群中的一个 Broker 会被选举为 Controller，负责管理集群中其他 Broker 的上下线、Partition 副本的分配和 ISR 成员变化、Leader 的选举等工作。而 Controller 的管理工作依赖于 Zookeeper，Broker 必须能通过 Zookeeper 的心跳机制维持其与 Zookeeper 的会话。</li></ul><h2 id=基本配置>基本配置<a href=#基本配置 class=anchor aria-hidden=true>#</a></h2><div class=highlight><pre style=color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-bash data-lang=bash><span style=color:#ff79c6>[</span>root@test-ece-kafka2 kafka_2.11-1.1.1<span style=color:#ff79c6>]</span><span style=color:#6272a4># ls config/</span>
connect-console-sink.properties    connect-file-sink.properties    connect-standalone.properties  producer.properties     zookeeper.properties
connect-console-source.properties  connect-file-source.properties  consumer.properties            server.properties
connect-distributed.properties     connect-log4j.properties        log4j.properties               tools-log4j.properties
</code></pre></div><p>Kafka 的基本配置在安装目录中 config 下的 server.properties 文件中：</p><div class=highlight><pre style=color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-json data-lang=json># The id of the broker. This must be set to a unique integer for each broker.
broker.id=<span style=color:#bd93f9>2</span>

# A comma separated list of directories under which to store log files
log.dirs=/data/kafka/logs

# The minimum age of a log file to be eligible for deletion due to age
log.retention.hours=<span style=color:#bd93f9>72</span>

# A size-based retention policy for logs. Segments are pruned from the log unless the remaining
# segments drop below log.retention.bytes. Functions independently of log.retention.hours.
#log.retention.bytes=<span style=color:#bd93f9>1073741824</span>

# The maximum size of a log segment file. When this size is reached a new log segment will be created.
log.segment.bytes=<span style=color:#bd93f9>1073741824</span>

# The interval at which log segments are checked to see if they can be deleted according
# to the retention policies
log.retention.check.interval.ms=<span style=color:#bd93f9>300000</span>

# zookeeper cluster
zookeeper.connect=test-ece-zk<span style=color:#bd93f9>1</span>:<span style=color:#bd93f9>2181</span>,test-ece-zk<span style=color:#bd93f9>2</span>:<span style=color:#bd93f9>2181</span>,test-ece-zk<span style=color:#bd93f9>3</span>:<span style=color:#bd93f9>2181</span>
</code></pre></div><h2 id=常用命令>常用命令<a href=#常用命令 class=anchor aria-hidden=true>#</a></h2><p>启动</p><div class=highlight><pre style=color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-bash data-lang=bash>bin/kafka-server-start.sh config/server.properties
</code></pre></div><p>创建 Topic</p><div class=highlight><pre style=color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-bash data-lang=bash>bin/kafka-topics.sh --create --zookeeper &lt;zookeeper-server&gt; --replication-factor &lt;n&gt; --partitions &lt;n&gt; --topic &lt;topic-name&gt;
</code></pre></div><p>查看 Topic</p><div class=highlight><pre style=color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-bash data-lang=bash>bin/kafka-topics.sh --list --zookeeper &lt;zookeeper-server&gt;
</code></pre></div><div class=highlight><pre style=color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-bash data-lang=bash>bin/kafka-topics.sh --describe --zookeeper &lt;zookeeper-server&gt; --topic &lt;topic-name&gt;
</code></pre></div><p>发送消息</p><div class=highlight><pre style=color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-bash data-lang=bash>bin/kafka-console-producer.sh --broker-list &lt;broker&gt; --topic &lt;topic-name&gt;
</code></pre></div><p>消费消息</p><div class=highlight><pre style=color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-bash data-lang=bash>bin/kafka-console-consumer.sh --bootstrap-server &lt;bootstrap-server&gt; --topic &lt;topic-name&gt; --from-beginning
</code></pre></div><p>查看消费者 Offset 与积压（lag）</p><div class=highlight><pre style=color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-bash data-lang=bash>bin/kafka-consumer-groups.sh  --describe --bootstrap-server &lt;bootstrap-server&gt;  --group &lt;counsumer-group&gt;
</code></pre></div><h2 id=producer>Producer<a href=#producer class=anchor aria-hidden=true>#</a></h2><p>消息的生产者，将数据主动发送到指定的 Topic。</p><ul><li>由于只有 Leader 副本处理读写请求，因此 Producer 会将消息发送到 Leader 所在的 Broker 上。为了实现这一功能，所有 Broker 都能响应其请求：哪些 Broker 存活（alive）和 Partition 中的 Leader 在哪台 Broker 上。</li><li>为了提升性能，Producer 会尝试在内存中汇总数据，并用一次请求批量发送消息。这种处理方式不仅可以指定批量发送的消息数量，也可以指定等待的延迟时间（如 10ms)，这将允许汇总更多的数据后再发送，从而减少在 Broker 端的 IO 操作。</li></ul><h2 id=partition>Partition<a href=#partition class=anchor aria-hidden=true>#</a></h2><p>Kafka 中的每个 Topic 可分为多个分区（Partition），这样做的目的是：</p><ul><li>水平扩展：每个单独的 Partition 受限于其所在 Broker 的文件限制，因此可以通过增加 Partition 数量来增大数据量；</li><li>负载均衡：Partition 由多台 Broker 维护，并发处理请求从而分担读写压力。</li></ul><p>Producer 只关心消息发往哪个 Topic，至于消息具体发送到哪一个 Partition 是由分配策略决定的：</p><ul><li>当指定 Partition 的情况下，直接分配到对应的 Partition；</li><li>没有指定 Partition 但指定了消息的键值 key，将使用 key 的 hash 值与 Topic 的 Partition 数进行取余得到 Partition 值，即<code>hash(key) % numPartitions</code>。因此我们可以指定用户 id 作为 key，那么跟用户有关的所有数据都将发送到同一 Partition 中。；</li><li>若两者都没有指定，第一次分配消息时会随机生成一个整数（之后再次分配会自增），将此值 Partition 数进行取余得到 Partition 值（即 Round-Robin 算法）。</li></ul><p>Partition 中的数据是直接写入磁盘的，其过程是将消息一直追加到文件末端，这样便可以省去大量磁头寻址的过程。</p><blockquote><p>相比于维护尽可能多的 in-memory cache，并且在空间不足的时候匆忙将数据 flush 到文件系统，我们把这个过程倒过来。所有数据一开始就被写入到文件系统的持久化日志中，而不用在 cache 空间不足的时候 flush 到磁盘。实际上，这表明数据被转移到了内核的 pagecache 中。</p></blockquote><p>Partition 在底层被拆分成了一个个 segment，而每个 segment 则由一个。log 文件和一个。index 文件组成：</p><div class=highlight><pre style=color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-bash data-lang=bash><span style=color:#ff79c6>[</span>root@test-ece-kafka2 ~<span style=color:#ff79c6>]</span><span style=color:#6272a4># ls /data/kafka/logs/&lt;topic-partition_number&gt; </span>
00000000000000083456.index  00000000000000083456.snapshot   00000000000000126371.index  00000000000000126371.snapshot   leaderer-epoch-checkpoint
00000000000000083456.log    00000000000000083456.timeindex  00000000000000126371.log    00000000000000126371.timeindex
</code></pre></div><ul><li>当起始。log 文件大小超过 Kafka 配置文件中<code>log.segment.bytes</code>参数指定的值，就会创建新的。log 文件，即新的 segment；</li><li>.index 和。log 文件以当前 segment 的第一条消息的 Offset 命名；</li><li>.index 文件中保存了每条消息的 Offset 值、在。log 文件中存储的物理偏移地址和大小，因此 Consumer 在消费时可以很快的根据。index 文件找到指定消息在。log 文件中的位置。具体过程如下：Consumer 将当前消费消息的 Offset 值与。index 文件名中的数字对比，找到该消息所在的。index 文件。随后在。index 文件中找到该消息在。log 文件中的起始地址，并根据消息大小确定其在。log 文件中的终止地址，从而拿到完整的目标消息。</li><li>leaderer-epoch-checkpoint 文件保存了 Partition 的 Leader Epoch 信息，详见 <a href=https://koktlzz.github.io/elastic/kafka/hw/#leader-epoch>Leader Epoch</a>。</li></ul><h2 id=consumer>Consumer<a href=#consumer class=anchor aria-hidden=true>#</a></h2><p>Consumer 采用主动拉取（Pull）的方式从 Broker 中读取数据，因此可以根据 Consumer 的消费能力以适当的速率消费数据。这种方式与 Broker 主动向 Consumer 推送（Push）消息相比，可以防止 Consumer 因不堪重负而出现拒绝服务、网路堵塞等问题。但如果 Topic 中已经没有数据，Consumer 依然会向 Broker 不断发起 Pull 请求。为此 Kafka 引入了一个时长参数<code>timeout</code>，即如果当前没有数据可供消费，Consumer 会等待一段时间之后再重新开始拉取数据。</p><p><img src=https://cdn.jsdelivr.net/gh/koktlzz/ImgBed@master/202103211935.jpeg alt=202103211935></p><p>每个 Topic 中的一个 Partition 只能被一个 Consumer Group 中的一个 Consumer 消费，而 Consumer 到底消费哪一个 Partition 是由 Consumer 客户端的<code>partition.assignment.strategy</code>参数，即 Partition 的分配策略所决定的。Kafka 目前支持三种分配策略：</p><ul><li>Range：参数值为<code>org.apache.kafka.clients.consumer.RangeAssignor</code>。对于每一个 Topic，RangeAssignor 将 Consumer Group 内所有订阅该 Topic 的 Consumer 名称按照字典顺序排序，然后为每个 Consumer 平均分配 n 个 Partition（n=Partition 数/Consumer 数）。m 个多余的 Partition（m=Partition 数%Consumer 数）将会按序分配给字典顺序靠前的 Consumer；</li><li>RoundRobin：参数值为<code>org.apache.kafka.clients.consumer.RoundRobinAssignor</code>。RoundRobinAssignor 将 Consumer Group 内所有 Consumer 以及 Consumer 订阅的所有 Topic 中的 Partition 按照字典顺序排序，然后通过轮询 Consumer 方式逐个将 Partition 分配给每个 Consumer；</li><li>Sticky：参数值为<code>org.apache.kafka.clients.consumer.StickyAssignor</code>。StickyAssignor 除了要保证 Partition 均匀分配之外，还会尽可能保证集群变动前后多次 Partition 分配的结果相同。</li></ul><p>详见：<a href=https://blog.csdn.net/u010022158/article/details/106271208>Kafka Range、RoundRobin、Sticky 三种分区分配策略区别</a></p><p>由于 Consumer 在消费过程中可能会出现断电宕机等故障，当其恢复后需要从故障前的位置的继续消费，因此 Consumer 需要实时记录当前消费的 Offset。而 Offset 保存在 Kafka 的内置 Topic 中，即_consumer_offsets。</p><blockquote><p>在每一个消费者中唯一保存的元数据是 offset（偏移量）即消费在 log 中的位置。偏移量由消费者所控制：通常在读取记录后，消费者会以线性的方式增加偏移量，但是实际上，由于这个位置由消费者控制，所以消费者可以采用任何顺序来消费记录。例如，一个消费者可以重置到一个旧的偏移量，从而重新处理过去的数据；也可以跳过最近的记录，从"现在"开始消费。</p></blockquote><h2 id=数据可靠性>数据可靠性<a href=#数据可靠性 class=anchor aria-hidden=true>#</a></h2><p>Kafka 通过以下机制来保证 Producer 向 Partition 发送数据的可靠性：</p><ul><li>每个 Partition 在接收到 Producer 发送的消息后，都要通过其所在的 Broker 返回一个 ACK（Acknowledge）数据包。Producer 收到该数据包后才会继续发送消息，否则重新发送消息；</li><li>Leader 中维护了一个动态的 ISR（in-sync replica set）, 即与 Leader 保持同步的 Follower 集合。当 ISR 中的 Follower 完成数据同步后，也会给 Leader 发送 Ack 数据包。若在参数<code>replica.lag.time.max.ms</code>规定的时间内未返回 Ack 数据包，该 Follower 将被踢出 ISR；</li><li><code>min.insync.replicas</code>参数指定了 ISR 中的最小副本数，默认值为 1。</li></ul><p>Kafka 的吞吐量和可靠性是不可兼得的，我们可以通过调整 ACK 参数来对其进行权衡。对于某些不太重要的数据，其可靠性要求不是很高，能够容忍数据的少量丢失，因此没必要等 ISR 中的 Follower 全部同步完成。</p><ul><li>ACK=0：即使数据还未在某个 Partition 的 Leader 上落盘，Producer 也会认为消息发送成功，不再等待 Broker 返回的 ACK 数据包。若 Leader 所在的 Broker 发生故障，则有可能丢失数据；</li><li>ACK=1（默认值）：只要 Leader 接收到 Producer 发送的消息就返回 ACK 数据包，Producer 认为消息发送成功。如果在 Follower 同步数据前，Leader 所在的 Broker 发生故障，则有可能丢失数据。如果 Follower 同步数据成功，但返回的 ACK 数据包发送失败，Producer 会再次发送相同的消息，从而造成数据重复。</li><li>ACK=-1（all）：只有 ISR 中的所有副本均同步完成，Leader 才会返回 ACK 数据包，Producer 认为消息发送成功。若<code>min.insync.replicas</code>值为 1 且 ISR 中只有 Leader 副本，那么即使设置 ACK=-1，也和 ACK=1 的情况相同。</li></ul><h2 id=幂等性>幂等性<a href=#幂等性 class=anchor aria-hidden=true>#</a></h2><p>我们已经可以通过调整 ACK 参数来保证数据不丢失 <strong>At Least Once</strong>（ACK=-1）或者不重复 <strong>At Most Once</strong>（ACK=0）。但对于一些重要信息，如交易数据，Consumer 要求数据既不丢失也不能重复。Kafka 引入幂等性的特性来保证无论 Producer 发送多少条重复数据到 Partition 中，Consumer 都只会消费一条有效信息，即 <strong>Exactly-Once</strong>。要启用幂等性，只需将 Producer 参数中<code>enable.idompotence</code>参数设置为 true 即可。为了实现幂等性，Kafka 在底层设计架构中引入了 ProducerID 和 SequenceNumber 两个概念：</p><ul><li>ProducerID：在每个新的 Producer 初始化时，会被分配一个唯一的 ProducerID，这个 ProducerID 对客户端使用者是不可见的；</li><li>SequenceNumber：对于每个 ProducerID，Producer 发往同一 Partition 的不同数据都分别对应了一个从 0 开始单调递增的 SequenceNumber 值。</li></ul><p>当 Producer 发送消息 (x2,y2) 给 Broker 时，Broker 接收到消息并将其追加到消息流中。此时，Broker 返回 ACK 信号给 Producer 时，发生异常导致 Producer 接收 ACK 信号失败。对于 Producer 来说，会触发重试机制，将消息 (x2,y2) 再次发送，但是，由于引入了幂等性，在每条消息中附带了 PID（ProducerID）和 SequenceNumber。相同的 PID 和 SequenceNumber 发送给 Broker，而之前 Broker 缓存过之前发送的相同的消息，那么在消息流中的消息就只有一条 (x2,y2)，不会出现重复发送的情况。</p><p><img src=https://cdn.jsdelivr.net/gh/koktlzz/NoteImg@main/20210304135205.png alt=20210304135205></p><p>由于 Producer 重启后 ProducerID 会发生改变，而不同的 Partition 也会有不同的 SequenceNumber，因此 Kafka 无法保证跨会话或跨 Partition 的幂等性。</p><h2 id=参考文献>参考文献<a href=#参考文献 class=anchor aria-hidden=true>#</a></h2><p><a href=https://levelup.gitconnected.com/kafka-for-engineers-975feaea6067>Kafka for Engineers</a></p><p class=edit-page><a href=https://github.com/koktlzz/koktlzz.github.io/blob/master/content/Observability/ElasticStack/KafkaIntro.md><svg xmlns="http://www.w3.org/2000/svg" width="16" height="16" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="feather feather-edit-2"><path d="M17 3a2.828 2.828.0 114 4L7.5 20.5 2 22l1.5-5.5L17 3z"/></svg>Edit this page on GitHub</a></p><div class="docs-navigation d-flex justify-content-between"><a href=https://koktlzz.github.io/observability/elasticstack/%E6%80%A7%E8%83%BD%E8%B0%83%E4%BC%98/><div class="card my-1"><div class="card-body py-2">&larr; Elasticsearch 性能调优</div></div></a><a class=ms-auto href=https://koktlzz.github.io/observability/elasticstack/hw/><div class="card my-1"><div class="card-body py-2">Kafka 副本备份 &rarr;</div></div></a></div><script src=https://utteranc.es/client.js repo=koktlzz/koktlzz.github.io issue-term=pathname theme=photon-dark crossorigin=anonymous async></script></main><nav class="docs-toc d-none d-xl-block col-lg-3 col-xl-2" aria-label="Secondary navigation"><div class=page-links><h3>On this page</h3><nav id=TableOfContents><ul><li><a href=#架构>架构</a></li><li><a href=#概念>概念</a></li><li><a href=#基本配置>基本配置</a></li><li><a href=#常用命令>常用命令</a></li><li><a href=#producer>Producer</a></li><li><a href=#partition>Partition</a></li><li><a href=#consumer>Consumer</a></li><li><a href=#数据可靠性>数据可靠性</a></li><li><a href=#幂等性>幂等性</a></li><li><a href=#参考文献>参考文献</a></li></ul></nav></div></nav></div></div></div><script src=https://koktlzz.github.io/js/bootstrap.min.d67050adf5d370668aede4201f82af781b16970934804995a1ca37c1ee9222c2fc530972aa6d5d2b6124caf1fe318f139aac99df2c1e89af65504fc1185c7972.js integrity="sha512-1nBQrfXTcGaK7eQgH4KveBsWlwk0gEmVoco3we6SIsL8Uwlyqm1dK2EkyvH+MY8TmqyZ3yweia9lUE/BGFx5cg==" crossorigin=anonymous defer></script><script src=https://koktlzz.github.io/js/vendor/katex/dist/katex.min.b334e5b00c45f572e7f38a543046f36854bf4cbb543880480c09271a0efedc694d6905f719934f6ede2f26f52e80411c05b90121d722cbf8be2fa8fc51bc6b81.js integrity="sha512-szTlsAxF9XLn84pUMEbzaFS/TLtUOIBIDAknGg7+3GlNaQX3GZNPbt4vJvUugEEcBbkBIdciy/i+L6j8UbxrgQ==" crossorigin=anonymous defer></script><script src=https://koktlzz.github.io/js/vendor/katex/dist/contrib/auto-render.min.916823ec103cf367b71e28a6f01513cb9c3ac6708ccb5229402ec46b8e30a8b25003db694df35d80e9dd666a371f327c6152790617b6256390c164109a90bd4c.js integrity="sha512-kWgj7BA882e3Hiim8BUTy5w6xnCMy1IpQC7Ea44wqLJQA9tpTfNdgOndZmo3HzJ8YVJ5Bhe2JWOQwWQQmpC9TA==" crossorigin=anonymous defer></script><script src=https://koktlzz.github.io/main.min.1febbf2f6fd6a36fc2f57dd50d7935fbb640743329baeb4ef7cefcf2e7630e413371fbba976e103656b82808ee227dc4a84237edb0f8433648bef3a56900661a.js integrity="sha512-H+u/L2/Wo2/C9X3VDXk1+7ZAdDMpuutO98788udjDkEzcfu6l24QNla4KAjuIn3EqEI37bD4QzZIvvOlaQBmGg==" crossorigin=anonymous defer></script></body></html>