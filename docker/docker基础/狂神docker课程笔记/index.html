<!doctype html><html lang=en-us><head><script async src="https://www.googletagmanager.com/gtag/js?id=G-D022F6NT2P"></script><script>window.dataLayer=window.dataLayer||[];function gtag(){dataLayer.push(arguments)}gtag('js',new Date),gtag('config','G-D022F6NT2P')</script><script>(function(b,d,e,a,g){b[a]=b[a]||[],b[a].push({'gtm.start':(new Date).getTime(),event:'gtm.js'});var f=d.getElementsByTagName(e)[0],c=d.createElement(e),h=a!='dataLayer'?'&l='+a:'';c.async=!0,c.src='https://www.googletagmanager.com/gtm.js?id='+g+h,f.parentNode.insertBefore(c,f)})(window,document,'script','dataLayer','GTM-P72R45W')</script><meta charset=utf-8><meta http-equiv=x-ua-compatible content="ie=edge"><meta name=viewport content="width=device-width,initial-scale=1,shrink-to-fit=no"><link rel=preload as=font href=https://koktlzz.github.io/fonts/vendor/jost/jost-v4-latin-regular.woff2 type=font/woff2 crossorigin><link rel=preload as=font href=https://koktlzz.github.io/fonts/vendor/jost/jost-v4-latin-700.woff2 type=font/woff2 crossorigin><link rel=preload as=font href=https://koktlzz.github.io/fonts/KaTeX_Main-Regular.woff2 type=font/woff2 crossorigin><link rel=preload as=font href=https://koktlzz.github.io/fonts/KaTeX_Math-Italic.woff2 type=font/woff2 crossorigin><link rel=stylesheet href=https://koktlzz.github.io/main.0ae7165cfeda76c765ab05aa408a696be65779f1e277afd078efecc543cc00bb72be873f087e148ccf7ac1016b22c2d2586f058c7ee5d92dcca60206eae2dd99.css integrity="sha512-CucWXP7adsdlqwWqQIppa+ZXefHid6/QeO/sxUPMALtyvoc/CH4UjM96wQFrIsLSWG8FjH7l2S3MpgIG6uLdmQ==" crossorigin=anonymous><noscript><style>img.lazyload{display:none}</style></noscript><meta name=robots content="index, follow"><meta name=googlebot content="index, follow, max-snippet:-1, max-image-preview:large, max-video-preview:-1"><meta name=bingbot content="index, follow, max-snippet:-1, max-image-preview:large, max-video-preview:-1"><title>狂神 Docker 课程笔记 | Inspire Hub</title><meta name=description content><link rel=canonical href=https://koktlzz.github.io/docker/docker%E5%9F%BA%E7%A1%80/%E7%8B%82%E7%A5%9Edocker%E8%AF%BE%E7%A8%8B%E7%AC%94%E8%AE%B0/><meta property="og:locale" content="en_US"><meta property="og:type" content="article"><meta property="og:title" content="狂神 Docker 课程笔记"><meta property="og:description" content="课程链接  https://www.bilibili.com/video/BV1og4y1q7M4?from=search&seid=18106350651153543104
 Docker 为什么出现？  开发和运维两套环境，而环境配置十分麻烦。 如在 Windows 上开发，要发布到 Linux 上运行。Docker 给以上问题提出了解决方案： Java &mdash; Jar（环境）&mdash;打包项目带上环境（镜像）&mdash;Docker 仓库（应用商店）&mdash;下载镜像&mdash;直接运行 Docker 的思想来自于集装箱，核心思想：隔离。 即将应用打包装箱，每个箱子是互相隔离的，可以将服务器利用到极致。 官方文档 仓库地址  Docker 能做什么？ 传统虚拟机与 Docker 对比 Docker 的优点  不模拟完整的操作系统，系统内核（kernel）非常小，更少的抽象层（GuestOS：如 Centos） 容器内的应用直接运行在宿主机的内核，容器本身没有自己的内核，也没有虚拟硬件。 每个容器相互隔离，内部都有属于自己的文件系统，互不影响。  Docker 实现 DevOps  应用更快速的交付和部署 打包镜像发布测试，一键运行；不再需要写大量帮助文档，安装程序 更便捷的升级和扩缩容？ 部署应用就和搭积木一样 更简单的系统运维 开发和测试的环境高度一致 更高效的计算资源利用 内核级别的虚拟化，可以在一个物理机上运行很多的容器实例，服务器性能可以被压榨到极致。  Docker 的基本组成  镜像（image）：镜像是一种轻量级、可执行的独立软件包，用来打包软件运行环境和基于运行环境开发的软件。它包含运行某个软件所需的所有内容，包括代码、运行时、库、环境变量和配置文件。相当于一个模板，通过这个模板来创建容器服务，可以通过一个镜像创建多个容器。 容器（container）：独立运行一个或一组应用/基本命令有：启动，停止，删除等。可理解为一个简单的 linux 系统。 仓库（repository）：存放镜像的地方（公有/私有）  Docker 运行原理 Docker 是一个 Client-Server 结构的系统，以守护进程运行在主机上。通过 Socket 从客户端进行访问。
Docker 的常用命令 帮助命令 docker --help # 帮助信息 docker info # 系统信息，包括镜像和容器的数量 帮助文档地址：https://docs."><meta property="og:url" content="https://koktlzz.github.io/docker/docker%E5%9F%BA%E7%A1%80/%E7%8B%82%E7%A5%9Edocker%E8%AF%BE%E7%A8%8B%E7%AC%94%E8%AE%B0/"><meta property="og:site_name" content="Inspire Hub"><meta property="article:published_time" content="2021-02-24T22:05:45+08:00"><meta property="article:modified_time" content="2021-02-24T22:05:45+08:00"><meta property="og:image" content="https://koktlzz.github.io/doks.png"><meta property="og:image:alt" content="Inspire Hub"><meta name=twitter:card content="summary_large_image"><meta name=twitter:site content="@getdoks"><meta name=twitter:creator content="@henkverlinde"><meta name=twitter:title content="狂神 Docker 课程笔记"><meta name=twitter:description content><meta name=twitter:image content="https://koktlzz.github.io/doks.png"><meta name=twitter:image:alt content="狂神 Docker 课程笔记"><script type=application/ld+json>{"@context":"https://schema.org","@graph":[{"@type":"Organization","@id":"https://koktlzz.github.io/#/schema/organization/1","name":"Doks","url":"https://koktlzz.github.io/","sameAs":["https://twitter.com/getdoks","https://github.com/h-enk/doks"],"logo":{"@type":"ImageObject","@id":"https://koktlzz.github.io/#/schema/image/1","url":"https://koktlzz.github.io/logo-doks.png","width":512,"height":512,"caption":"Doks"},"image":{"@id":"https://koktlzz.github.io/#/schema/image/1"}},{"@type":"WebSite","@id":"https://koktlzz.github.io/#/schema/website/1","url":"https://koktlzz.github.io/","name":"Inspire Hub","description":"","publisher":{"@id":"https://koktlzz.github.io/#/schema/organization/1"}},{"@type":"WebPage","@id":"https://koktlzz.github.io/docker/docker%E5%9F%BA%E7%A1%80/%E7%8B%82%E7%A5%9Edocker%E8%AF%BE%E7%A8%8B%E7%AC%94%E8%AE%B0/","url":"https://koktlzz.github.io/docker/docker%E5%9F%BA%E7%A1%80/%E7%8B%82%E7%A5%9Edocker%E8%AF%BE%E7%A8%8B%E7%AC%94%E8%AE%B0/","name":"狂神 Docker 课程笔记","description":"","isPartOf":{"@id":"https://koktlzz.github.io/#/schema/website/1"},"about":{"@id":"https://koktlzz.github.io/#/schema/organization/1"},"datePublished":"2021-02-24T22:05:45CET","dateModified":"2021-02-24T22:05:45CET","breadcrumb":{"@id":"https://koktlzz.github.io/docker/docker%E5%9F%BA%E7%A1%80/%E7%8B%82%E7%A5%9Edocker%E8%AF%BE%E7%A8%8B%E7%AC%94%E8%AE%B0/#/schema/breadcrumb/1"},"primaryImageOfPage":{"@id":"https://koktlzz.github.io/docker/docker%E5%9F%BA%E7%A1%80/%E7%8B%82%E7%A5%9Edocker%E8%AF%BE%E7%A8%8B%E7%AC%94%E8%AE%B0/#/schema/image/2"},"inLanguage":"en-US","potentialAction":[{"@type":"ReadAction","target":["https://koktlzz.github.io/docker/docker%E5%9F%BA%E7%A1%80/%E7%8B%82%E7%A5%9Edocker%E8%AF%BE%E7%A8%8B%E7%AC%94%E8%AE%B0/"]}]},{"@type":"BreadcrumbList","@id":"https://koktlzz.github.io/docker/docker%E5%9F%BA%E7%A1%80/%E7%8B%82%E7%A5%9Edocker%E8%AF%BE%E7%A8%8B%E7%AC%94%E8%AE%B0/#/schema/breadcrumb/1","name":"Breadcrumbs","itemListElement":[{"@type":"ListItem","position":1,"item":{"@type":"WebPage","@id":"https://koktlzz.github.io/","url":"https://koktlzz.github.io/","name":"Home"}},{"@type":"ListItem","position":2,"item":{"@type":"WebPage","@id":"https://koktlzz.github.io/docker/","url":"https://koktlzz.github.io/docker/","name":"Docker"}},{"@type":"ListItem","position":3,"item":{"@type":"WebPage","@id":"https://koktlzz.github.io/docker/docker%E5%9F%BA%E7%A1%80/","url":"https://koktlzz.github.io/docker/docker%E5%9F%BA%E7%A1%80/","name":"Docker% E5%9 F% Ba% E7% A1%80"}},{"@type":"ListItem","position":4,"item":{"@id":"https://koktlzz.github.io/docker/docker%E5%9F%BA%E7%A1%80/%E7%8B%82%E7%A5%9Edocker%E8%AF%BE%E7%A8%8B%E7%AC%94%E8%AE%B0/"}}]},{"@context":"https://schema.org","@graph":[{"@type":"ImageObject","@id":"https://koktlzz.github.io/docker/docker%E5%9F%BA%E7%A1%80/%E7%8B%82%E7%A5%9Edocker%E8%AF%BE%E7%A8%8B%E7%AC%94%E8%AE%B0/#/schema/image/2","url":"https://koktlzz.github.io/doks.png","contentUrl":"https://koktlzz.github.io/doks.png","caption":"狂神 Docker 课程笔记"}]}]}</script><meta name=theme-color content="#fff"><link rel=apple-touch-icon sizes=180x180 href=https://koktlzz.github.io/apple-touch-icon.png><link rel=icon type=image/png sizes=32x32 href=https://koktlzz.github.io/favicon-32x32.ico><link rel=icon type=image/png sizes=16x16 href=https://koktlzz.github.io/favicon-16x16.ico><link rel=manifest crossorigin=use-credentials href=https://koktlzz.github.io/site.webmanifest></head><body class="Docker single dark"><noscript><iframe src="https://www.googletagmanager.com/ns.html?id=GTM-P72R45W" height=0 width=0 style=display:none;visibility:hidden></iframe></noscript><div class="header-bar fixed-top"></div><header class="navbar fixed-top navbar-expand-md navbar-light"><div class=container-fluid><input class="menu-btn order-0" type=checkbox id=menu-btn>
<label class="menu-icon d-md-none" for=menu-btn><span class=navicon></span></label><a class="navbar-brand order-1 order-md-0 me-auto" href=https://koktlzz.github.io/>Inspire Hub</a>
<button id=mode class="btn btn-link order-2 order-md-4" type=button aria-label="Toggle mode">
<span class=toggle-dark><svg xmlns="http://www.w3.org/2000/svg" width="20" height="20" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="feather feather-moon"><path d="M21 12.79A9 9 0 1111.21 3 7 7 0 0021 12.79z"/></svg></span><span class=toggle-light><svg xmlns="http://www.w3.org/2000/svg" width="20" height="20" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="feather feather-sun"><circle cx="12" cy="12" r="5"/><line x1="12" y1="1" x2="12" y2="3"/><line x1="12" y1="21" x2="12" y2="23"/><line x1="4.22" y1="4.22" x2="5.64" y2="5.64"/><line x1="18.36" y1="18.36" x2="19.78" y2="19.78"/><line x1="1" y1="12" x2="3" y2="12"/><line x1="21" y1="12" x2="23" y2="12"/><line x1="4.22" y1="19.78" x2="5.64" y2="18.36"/><line x1="18.36" y1="5.64" x2="19.78" y2="4.22"/></svg></span></button><ul class="navbar-nav social-nav order-3 order-md-5"><li class=nav-item><a class=nav-link href=https://github.com/koktlzz><svg xmlns="http://www.w3.org/2000/svg" width="20" height="20" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="feather feather-github"><path d="M9 19c-5 1.5-5-2.5-7-3m14 6v-3.87a3.37 3.37.0 00-.94-2.61c3.14-.35 6.44-1.54 6.44-7A5.44 5.44.0 0020 4.77 5.07 5.07.0 0019.91 1S18.73.65 16 2.48a13.38 13.38.0 00-7 0C6.27.65 5.09 1 5.09 1A5.07 5.07.0 005 4.77 5.44 5.44.0 003.5 8.55c0 5.42 3.3 6.61 6.44 7A3.37 3.37.0 009 18.13V22"/></svg><span class="ms-2 visually-hidden">GitHub</span></a></li></ul><div class="collapse navbar-collapse order-4 order-md-1"><ul class="navbar-nav main-nav me-auto order-5 order-md-2"><li class=nav-item><a class=nav-link href=https://koktlzz.github.io/docker/docker%E5%9F%BA%E7%A1%80/intro>Docker</a></li><li class=nav-item><a class=nav-link href=https://koktlzz.github.io/kubernetes/kubernetes%E5%9F%BA%E7%A1%80/intro>Kubernetes</a></li><li class=nav-item><a class=nav-link href=https://koktlzz.github.io/elastic/elasticstack/intro>Elastic</a></li><li class=nav-item><a class=nav-link href=https://koktlzz.github.io/go/go%E5%9F%BA%E7%A1%80/intro>Go</a></li><li class=nav-item><a class=nav-link href=https://koktlzz.github.io/infra/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E5%9F%BA%E7%A1%80/tcpip%E7%BD%91%E7%BB%9C%E6%A8%A1%E5%9E%8B>Infra</a></li></ul><div class="break order-6 d-md-none"></div></div></div></header><div class="wrap container-fluid" role=document><div class=content><div class="row flex-xl-nowrap"><div class="col-lg-3 col-xl-2 d-none d-xl-block"><nav class=docs-links aria-label="Main navigation"><h3>Docker 基础</h3><ul class=list-unstyled><li><a class=docs-link href=https://koktlzz.github.io/docker/docker%E5%9F%BA%E7%A1%80/intro/>Get Started</a></li><li><a class=docs-link href=https://koktlzz.github.io/docker/docker%E5%9F%BA%E7%A1%80/%E7%8B%82%E7%A5%9Edocker%E8%AF%BE%E7%A8%8B%E7%AC%94%E8%AE%B0/>狂神 Docker 课程笔记</a></li><li><a class=docs-link href=https://koktlzz.github.io/docker/docker%E5%9F%BA%E7%A1%80/dockercompose/>Docker Compose</a></li></ul><h3>Docker 核心原理</h3><ul class=list-unstyled><li><a class=docs-link href=https://koktlzz.github.io/docker/docker%E6%A0%B8%E5%BF%83%E5%8E%9F%E7%90%86/namespace%E9%9A%94%E7%A6%BB/>Namespace 隔离</a></li><li><a class=docs-link href=https://koktlzz.github.io/docker/docker%E6%A0%B8%E5%BF%83%E5%8E%9F%E7%90%86/cgroups%E9%9A%94%E7%A6%BB/>cgroups 隔离</a></li><li><a class=docs-link href=https://koktlzz.github.io/docker/docker%E6%A0%B8%E5%BF%83%E5%8E%9F%E7%90%86/%E9%95%9C%E5%83%8F%E4%B8%8E%E5%AE%B9%E5%99%A8/>镜像与容器</a></li></ul></nav></div><main class="docs-content col-lg-13 col-xl-11"><h1>狂神 Docker 课程笔记</h1><p class=lead></p><h2 id=课程链接>课程链接<a href=#课程链接 class=anchor aria-hidden=true>#</a></h2><blockquote><p><a href="https://www.bilibili.com/video/BV1og4y1q7M4?from=search&seid=18106350651153543104">https://www.bilibili.com/video/BV1og4y1q7M4?from=search&seid=18106350651153543104</a></p></blockquote><h2 id=docker-为什么出现>Docker 为什么出现？<a href=#docker-为什么出现 class=anchor aria-hidden=true>#</a></h2><ul><li>开发和运维两套环境，而环境配置十分麻烦。
如在 Windows 上开发，要发布到 Linux 上运行。Docker 给以上问题提出了解决方案：
Java &mdash; Jar（环境）&mdash;打包项目带上环境（镜像）&mdash;Docker 仓库（应用商店）&mdash;下载镜像&mdash;直接运行</li><li>Docker 的思想来自于集装箱，核心思想：隔离。
即将应用打包装箱，每个箱子是互相隔离的，可以将服务器利用到极致。</li><li><a href=https://docs.docker.com/>官方文档</a></li><li><a href=https://hub.docker.com/>仓库地址</a></li></ul><h2 id=docker-能做什么>Docker 能做什么？<a href=#docker-能做什么 class=anchor aria-hidden=true>#</a></h2><h3 id=传统虚拟机与-docker-对比>传统虚拟机与 Docker 对比<a href=#传统虚拟机与-docker-对比 class=anchor aria-hidden=true>#</a></h3><p><img src=https://cdn.jsdelivr.net/gh/koktlzz/NoteImg@main/20201209124302.png alt=20201209124302></p><h3 id=docker-的优点>Docker 的优点<a href=#docker-的优点 class=anchor aria-hidden=true>#</a></h3><ul><li>不模拟完整的操作系统，系统内核（kernel）非常小，更少的抽象层（GuestOS：如 Centos）</li><li>容器内的应用直接运行在宿主机的内核，容器本身没有自己的内核，也没有虚拟硬件。</li><li>每个容器相互隔离，内部都有属于自己的文件系统，互不影响。</li></ul><h3 id=docker-实现-devops>Docker 实现 DevOps<a href=#docker-实现-devops class=anchor aria-hidden=true>#</a></h3><ul><li>应用更快速的交付和部署
打包镜像发布测试，一键运行；不再需要写大量帮助文档，安装程序</li><li>更便捷的升级和扩缩容？
部署应用就和搭积木一样</li><li>更简单的系统运维
开发和测试的环境高度一致</li><li>更高效的计算资源利用
内核级别的虚拟化，可以在一个物理机上运行很多的容器实例，服务器性能可以被压榨到极致。</li></ul><h2 id=docker-的基本组成>Docker 的基本组成<a href=#docker-的基本组成 class=anchor aria-hidden=true>#</a></h2><p><img src=https://cdn.jsdelivr.net/gh/koktlzz/NoteImg@main/20201208171750.png alt=20201208171750></p><ul><li>镜像（image）：镜像是一种轻量级、可执行的独立软件包，用来打包软件运行环境和基于运行环境开发的软件。它包含运行某个软件所需的所有内容，包括代码、运行时、库、环境变量和配置文件。相当于一个模板，通过这个模板来创建容器服务，可以通过一个镜像创建多个容器。</li><li>容器（container）：独立运行一个或一组应用/基本命令有：启动，停止，删除等。可理解为一个简单的 linux 系统。</li><li>仓库（repository）：存放镜像的地方（公有/私有）</li></ul><h2 id=docker-运行原理>Docker 运行原理<a href=#docker-运行原理 class=anchor aria-hidden=true>#</a></h2><p>Docker 是一个 Client-Server 结构的系统，以守护进程运行在主机上。通过 Socket 从客户端进行访问。</p><h2 id=docker-的常用命令>Docker 的常用命令<a href=#docker-的常用命令 class=anchor aria-hidden=true>#</a></h2><p><img src=https://cdn.jsdelivr.net/gh/koktlzz/ImgBed@master/20201212210110.png alt=20201212210110></p><h3 id=帮助命令>帮助命令<a href=#帮助命令 class=anchor aria-hidden=true>#</a></h3><div class=highlight><pre style=color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-bash data-lang=bash>docker --help            <span style=color:#6272a4># 帮助信息</span>
docker info              <span style=color:#6272a4># 系统信息，包括镜像和容器的数量</span>
</code></pre></div><p>帮助文档地址：<a href=https://docs.docker.com/engine/reference/>https://docs.docker.com/engine/reference/</a></p><h3 id=镜像命令>镜像命令<a href=#镜像命令 class=anchor aria-hidden=true>#</a></h3><div class=highlight><pre style=color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-bash data-lang=bash>docker search 镜像名      <span style=color:#6272a4># 搜索镜像</span>
docker pull 镜像名        <span style=color:#6272a4># 下载镜像</span>
</code></pre></div><p>Docker 采用联合文件系统，不同镜像的相同文件无需再次下载：</p><p><img src=https://cdn.jsdelivr.net/gh/koktlzz/ImgBed@master/20201212192925.png alt=20201212192925></p><div class=highlight><pre style=color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-bash data-lang=bash>docker rmi 镜像名/id      删除镜像
</code></pre></div><h3 id=容器命令>容器命令<a href=#容器命令 class=anchor aria-hidden=true>#</a></h3><div class=highlight><pre style=color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-bash data-lang=bash>docker run <span style=color:#ff79c6>[</span>options<span style=color:#ff79c6>]</span> 镜像名/id <span style=color:#ff79c6>[</span>command<span style=color:#ff79c6>]</span>  <span style=color:#6272a4># 建立容器并启动：         </span>
<span style=color:#ff79c6>[</span>options<span style=color:#ff79c6>]</span>:                
            --name<span style=color:#ff79c6>=</span>容器名                 <span style=color:#6272a4># 命名容器以区分不同容器</span>
            -d                           <span style=color:#6272a4># 在后台运行容器（必须有一个前台进程，否则进程会自动关闭）</span>
            -it                          <span style=color:#6272a4># 使用交互方式运行，进入容器查看内容</span>
            -p 主机端口：容器端口            <span style=color:#6272a4># 暴露指定容器端口</span>
            -P                           <span style=color:#6272a4># 暴露容器所有端口</span>
<span style=color:#ff79c6>[</span>command<span style=color:#ff79c6>]</span>:
            /bin/bash                    <span style=color:#6272a4># 控制台</span>
</code></pre></div><p><img src=https://cdn.jsdelivr.net/gh/koktlzz/NoteImg@main/2.jpg alt=2></p><div class=highlight><pre style=color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-bash data-lang=bash>Exit                         <span style=color:#6272a4># 从容器中退回主机 </span>
CTRL+Q+P                     <span style=color:#6272a4># 容器不停止退出</span>
docker ps                    <span style=color:#6272a4># 显示当前运行的容器 </span>
          -a                 <span style=color:#6272a4># 带出历史运行过的容器</span>
docker rm 容器名/id           <span style=color:#6272a4># 删除指定容器</span>
docker rm <span style=color:#ff79c6>$(</span>docker ps -aq<span style=color:#ff79c6>)</span>   <span style=color:#6272a4># 删除全部容器</span>
</code></pre></div><h3 id=其他命令>其他命令<a href=#其他命令 class=anchor aria-hidden=true>#</a></h3><div class=highlight><pre style=color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-bash data-lang=bash>docker start/restart/stop/kill 容器名/id             
docker logs -tf --tail 显示的日志条数 容器名/id  <span style=color:#6272a4># 查看日志</span>
docker top 容器名/id                 <span style=color:#6272a4># 查看容器中的进程信息</span>
docker inspect 容器名/id             <span style=color:#6272a4># 查看镜像的元数据</span>
docker <span style=color:#8be9fd;font-style:italic>exec</span> -it 容器名/id /bin/bash  <span style=color:#6272a4># 通常容器以后台方式运行，需要进入其中修改配置：进入容器后开启一个新终端       </span>
docker attach 容器名/id              <span style=color:#6272a4># 进入容器正在执行的终端</span>
docker cp 容器名/id: 容器内路径 主机文件路径       <span style=color:#6272a4># 从容器内拷贝文件到主机上</span>
</code></pre></div><h2 id=docker-镜像详解>Docker 镜像详解<a href=#docker-镜像详解 class=anchor aria-hidden=true>#</a></h2><p><img src=https://cdn.jsdelivr.net/gh/koktlzz/NoteImg@main/20201208182908.png alt=133></p><h3 id=unionfs联合文件系统>UnionFS（联合文件系统）<a href=#unionfs联合文件系统 class=anchor aria-hidden=true>#</a></h3><ul><li>联合文件系统（UnionFS）是一种分层、轻量级并且高性能的文件系统，它支持对文件系统的修改作为一次提交来一层层的叠加，同时可以将不同目录挂载到同一个虚拟文件系统下。联合文件系统是 Docker 镜像的基础。镜像可以通过分层来进行继承，基于基础镜像（没有父镜像），可以制作各种具体的应用镜像。</li><li>特性：一次同时加载多个文件系统，但从外面看起来只能看到一个文件系统。联合加载会把各层文件系统叠加起来，这样最终的文件系统会包含所有底层的文件和目录。</li></ul><h3 id=镜像加载原理>镜像加载原理<a href=#镜像加载原理 class=anchor aria-hidden=true>#</a></h3><p>Docker 的镜像实际由一层一层的文件系统组成：</p><ul><li>bootfs（boot file system）主要包含 bootloader 和 kernel。bootloader 主要是引导加载 kernel，完成后整个内核就都在内存中了。此时内存的使用权已由 bootfs 转交给内核，系统卸载 bootfs。可以被不同的 Linux 发行版公用。</li><li>rootfs（root file system），包含典型 Linux 系统中的/dev，/proc，/bin，/etc 等标准目录和文件。rootfs 就是各种不同操作系统发行版（Ubuntu，Centos 等）。因为底层直接用 Host 的 kernel，rootfs 只包含最基本的命令，工具和程序就可以了。</li><li>分层理解：所有的 Docker 镜像都起始于一个基础镜像层，当进行修改或增加新的内容时，就会在当前镜像层之上，创建新的容器层。
容器在启动时会在镜像最外层上建立一层可读写的容器层（R/W），而镜像层是只读的（R/O）。</li></ul><p><img src=https://cdn.jsdelivr.net/gh/koktlzz/NoteImg@main/20201208183559.png alt=20201208183559></p><div class=highlight><pre style=color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-bash data-lang=bash>docker commit -m<span style=color:#ff79c6>=</span><span style=color:#f1fa8c>&#34;描述信息&#34;</span> -a<span style=color:#ff79c6>=</span><span style=color:#f1fa8c>&#34;作者&#34;</span> 容器 id 目标镜像名：<span style=color:#ff79c6>[</span>tag<span style=color:#ff79c6>]</span>  <span style=color:#6272a4># 编辑容器后提交容器成为一个新镜像</span>
</code></pre></div><h2 id=容器数据卷>容器数据卷<a href=#容器数据卷 class=anchor aria-hidden=true>#</a></h2><p><img src=https://cdn.jsdelivr.net/gh/koktlzz/NoteImg@main/20201208183759.png alt=20201208183759></p><h3 id=什么是容器数据卷>什么是容器数据卷？<a href=#什么是容器数据卷 class=anchor aria-hidden=true>#</a></h3><p>为了实现数据持久化，使容器之间可以共享数据。可以将容器内的目录，挂载到宿主机上或其他容器内，实现同步和共享的操作。即使将容器删除，挂载到本地的数据卷也不会丢失。</p><h3 id=使用容器数据卷>使用容器数据卷<a href=#使用容器数据卷 class=anchor aria-hidden=true>#</a></h3><p>使用命令：</p><div class=highlight><pre style=color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-bash data-lang=bash>dokcer run -it -v 主机内目录：容器内目录 镜像名/id
</code></pre></div><p>将容器内目录挂载到主机内目录上，通过 <strong>docker inspect</strong> 命令查看该容器即可以看到挂载信息：</p><p><img src=https://cdn.jsdelivr.net/gh/koktlzz/NoteImg@main/20201211162429.png alt=20201211162429></p><p>建立挂载关系后，只要使用命令在主机内新建一个文件：</p><div class=highlight><pre style=color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-bash data-lang=bash>touch /home/mountdir/test.txt
</code></pre></div><p>就会在容器内的挂载目录下发现相同的文件（test.txt），从而实现了容器和主机的文件同步和共享：</p><p><img src=https://cdn.jsdelivr.net/gh/koktlzz/NoteImg@main/20201211162933.png alt=20201211162933></p><h3 id=匿名挂载>匿名挂载<a href=#匿名挂载 class=anchor aria-hidden=true>#</a></h3><div class=highlight><pre style=color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-bash data-lang=bash>docker run -d  -v 容器内目录  镜像名/id  <span style=color:#6272a4># 匿名挂载</span>
</code></pre></div><p>匿名挂载后，使用 <strong>docker volume ls</strong> 命令查看所有挂载的卷：</p><p><img src=https://cdn.jsdelivr.net/gh/koktlzz/NoteImg@main/20201208184201.png alt=20201208184201></p><p>每一个 VOLUME NAME 对应一个挂载的卷，由于挂载时未指定主机目录，因此无法直接找到目录。</p><h3 id=具名挂载>具名挂载<a href=#具名挂载 class=anchor aria-hidden=true>#</a></h3><div class=highlight><pre style=color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-bash data-lang=bash>docker run -d  -v 卷名：容器内目录  镜像名/id  <span style=color:#6272a4># 具名挂载</span>
</code></pre></div><p><img src=https://cdn.jsdelivr.net/gh/koktlzz/NoteImg@main/20201211164244.png alt=20201211164244></p><p>可以发现挂载的卷：volume01，并通过 <strong>docker volume inspect 卷名</strong> 命令找到主机内目录：</p><p><img src=https://cdn.jsdelivr.net/gh/koktlzz/NoteImg@main/20201211164505.png alt=20201211164505></p><p>所有 docker 容器内的卷，在未指定主机内目录时，都在：<em>/var/lib/docker/volumes/卷名/_data</em> 下，可通过具名挂载可以方便的找到卷，因此广泛使用这种方式进行挂载。</p><h3 id=数据卷容器>数据卷容器<a href=#数据卷容器 class=anchor aria-hidden=true>#</a></h3><p><img src=https://cdn.jsdelivr.net/gh/koktlzz/NoteImg@main/20201208184546.png alt=20201208184546></p><div class=highlight><pre style=color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-bash data-lang=bash>docker run -it --name container02 --volumes from container01 镜像名/id  <span style=color:#6272a4># 将两个容器进行挂载</span>
</code></pre></div><h2 id=dockerfile>DockerFile<a href=#dockerfile class=anchor aria-hidden=true>#</a></h2><p>Dockerfile 是用来构建 docker 镜像的文件</p><h3 id=构建步骤>构建步骤<a href=#构建步骤 class=anchor aria-hidden=true>#</a></h3><p>编写一个 dockerfile 文件，随后运行命令：</p><div class=highlight><pre style=color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-bash data-lang=bash>docker build -f 文件路径 -t 标签 .  <span style=color:#6272a4># 文件名为 Dockerfile 时可省略且最后的。不要忽略</span>
docker run     <span style=color:#6272a4># 运行镜像</span>
docker push    <span style=color:#6272a4># 发布镜像</span>
</code></pre></div><h3 id=dockerfile-命令>dockerfile 命令<a href=#dockerfile-命令 class=anchor aria-hidden=true>#</a></h3><table><thead><tr><th>命令</th><th>效果</th></tr></thead><tbody><tr><td>FROM</td><td>基础镜像：Centos/Ubuntu</td></tr><tr><td>MAINTAINER</td><td>镜像作者+邮箱</td></tr><tr><td>RUN</td><td>镜像构建的时候需要运行的命令</td></tr><tr><td>ADD</td><td>为镜像添加内容，可以是文件或 URL 资源。若为压缩包则会解压缩</td></tr><tr><td>WORKDIR</td><td>镜像工作目录（进入容器时的目录）</td></tr><tr><td>VOLUME</td><td>挂载的目录</td></tr><tr><td>EXPOSE</td><td>暴露端口配置</td></tr><tr><td>CMD/ENTRYPOINT</td><td>指定这个容器启动时要运行的命令</td></tr><tr><td>COPY</td><td>类似于 ADD。将文件拷贝到镜像中，但不会进行解压缩操作，也不能指定 URL 资源</td></tr><tr><td>ENV</td><td>构建时设置环境变量</td></tr></tbody></table><p>Dockerfile 应最多包含一条 ENTRYPOINT 命令和一条 CMD 命令，如：</p><div class=highlight><pre style=color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-bash data-lang=bash>ENTRYPOINT <span style=color:#ff79c6>[</span><span style=color:#f1fa8c>&#34;/bin/ping&#34;</span><span style=color:#ff79c6>]</span>
CMD <span style=color:#ff79c6>[</span><span style=color:#f1fa8c>&#34;localhost&#34;</span><span style=color:#ff79c6>]</span>
</code></pre></div><p>如果编写了多条命令，则只有最后一条命令生效。由于默认的 ENTRYPOINT 命令是 <strong>/bin/sh -c</strong>，因此可以在不指定 ENTRYPOINT 的前提下运行 CMD，如：</p><div class=highlight><pre style=color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-bash data-lang=bash>CMD <span style=color:#ff79c6>[</span><span style=color:#f1fa8c>&#34;/bin/ping&#34;</span>, <span style=color:#f1fa8c>&#34;localhost&#34;</span><span style=color:#ff79c6>]</span>
</code></pre></div><p>另外在启动容器时，<strong>docker run &lt;image></strong> 后可以添加参数覆盖 CMD 命令，从而增加容器的灵活性。因此如果使用 <strong>docker run &lt;image> baidu.com</strong> 命令启动容器，那么在上述第一个例子中容器将会 ping baidu.com 而非 localhost。</p><h3 id=构建过程>构建过程<a href=#构建过程 class=anchor aria-hidden=true>#</a></h3><ul><li>每个保留关键字（指令）都必须是大写字母</li><li>从上到下顺序执行</li><li>&ldquo;#&rdquo; 表示注释</li><li>每一个指令都会创建提交一个新的镜像层并提交</li></ul><h3 id=构建实例>构建实例<a href=#构建实例 class=anchor aria-hidden=true>#</a></h3><p><img src=https://cdn.jsdelivr.net/gh/koktlzz/NoteImg@main/20201208185616.png alt=20201208185616></p><h2 id=docker-网络>Docker 网络<a href=#docker-网络 class=anchor aria-hidden=true>#</a></h2><h3 id=理解-doker0>理解 Doker0<a href=#理解-doker0 class=anchor aria-hidden=true>#</a></h3><p>通过命令 <strong>ip addr</strong> 查看本地 ip 地址，我们发现除了本机回环地址和埃里远的内网地址外，还多了一个网卡：Docker0，这是 Docker 服务启动后自动生成的。</p><p><img src=https://cdn.jsdelivr.net/gh/koktlzz/NoteImg@main/20201211165741.png alt=20201211165741></p><p>而如果进入一个正在后台运行的 tomcat 容器，同样使用 <strong>ip addr</strong> 命令，发现容器得到了一个新的网络：<strong>12: eth@if13</strong>，ip 地址：<strong>172.17.0.2</strong>。这是 Docker 在容器启动时为其分配的。</p><p><img src=https://cdn.jsdelivr.net/gh/koktlzz/NoteImg@main/1607676753(1).png alt=1607676753(1)></p><p>思考一个问题：此时我们的 linux 主机可以 ping 通容器内部（<strong>172.17.0.2</strong>）吗？（<strong>注意与容器暴露端口相区分</strong>）</p><p><img src=https://cdn.jsdelivr.net/gh/koktlzz/NoteImg@main/20201211170424.png alt=20201211170424></p><p>linux 可以 ping 通 docker 容器内部，因为 docker0 的 ip 地址为 <strong>172.17.0.1</strong>，容器为 <strong>172.17.0.2</strong>。原理：我们每启动一个 docker 容器，docker 就会给容器分配一个默认的可用 ip，我们只要安装了 docker，就会有一个网卡 docker0(bridge)。网卡采用桥接模式，并使用 veth-pair 技术（veth-pair 就是一堆虚拟设备接口，成对出现，一段连着协议，一段彼此相连，充当一个桥梁。）。
这时我们退出容器，回到主机再次观察主机的 ip 地址：</p><p><img src=https://cdn.jsdelivr.net/gh/koktlzz/NoteImg@main/20201211170810.png alt=20201211170810></p><p>我们惊奇地发现了一个新网络 <strong>13: vethda1df4b@if12</strong>，对应容器内网络地址的 <strong>12: eth@if13</strong>。
容器和容器之间是可以互相 ping 通的：容器 1→Docker0→容器 2</p><p><img src=https://cdn.jsdelivr.net/gh/koktlzz/ImgBed@master/20210131140833.png alt=20210131140833></p><p>docker 中的所有网络接口都是虚拟的 ，转发效率高。删除容器后，对应的网桥也随之删除。</p><h3 id=--link>&ndash;link<a href=#--link class=anchor aria-hidden=true>#</a></h3><p>若编写一个微服务并连接数据库，如果数据库 ip 改变，如何根据容器名而不是 ip 访问容器？显然，直接使用容器名是无法 ping 通容器内部的：</p><p><img src=https://cdn.jsdelivr.net/gh/koktlzz/ImgBed@master/20201212200850.png alt=20201212200850></p><p>这时我们可以在容器启动命令中加入一个选项：<strong>&ndash;link</strong>，使得我们可以根据容器名来访问容器。</p><div class=highlight><pre style=color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-bash data-lang=bash>docker run -d -P --link 容器名/id 镜像名/id
</code></pre></div><p><img src=https://cdn.jsdelivr.net/gh/koktlzz/ImgBed@master/20201212200748.png alt=20201212200748></p><p>然而反向就不可以 ping 通，这是因为&ndash;link 的本质是把需要连接的容器名/id 写入启动容器的配置文件中，即增加了一个 ip 和容器名/id 的映射：</p><p><img src=https://cdn.jsdelivr.net/gh/koktlzz/ImgBed@master/20201212201930.png alt=20201212201930></p><p>目前已经不建议使用这种方式。</p><h3 id=自定义网络>自定义网络<a href=#自定义网络 class=anchor aria-hidden=true>#</a></h3><p>我们使用命令：</p><div class=highlight><pre style=color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-bash data-lang=bash>docker network ls    <span style=color:#6272a4># 查看所有的 docker 网络</span>
</code></pre></div><p><img src=https://cdn.jsdelivr.net/gh/koktlzz/ImgBed@master/20201212202126.png alt=20201212202126></p><p>docker 中的网络模式有：</p><ul><li>bridge：桥接（docker 默认）/</li><li>none：不配置网络 /</li><li>host：和宿主机共享网络</li></ul><p><strong>docker run</strong> 命令默认带有一个参数&ndash;net bridge，此处的 bridge 指的就是 docker0。如果我们不想使用 docker0，那如何创建一个新的网络呢？</p><div class=highlight><pre style=color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-bash data-lang=bash>docker  network create --driver 网络模式 --subnet 子网 ip --gateway 网关 网络名       
</code></pre></div><p><img src=https://cdn.jsdelivr.net/gh/koktlzz/ImgBed@master/20201212205640.png alt=20201212205640></p><p>我们不仅在 <strong>docker network ls</strong> 命令下发现了这个新创建的网络 newnet，还可以使用 <strong>docker network inspect</strong> 命令查看其详细信息，包括了我们创建时定义的子网 ip 和网关：</p><p><img src=https://cdn.jsdelivr.net/gh/koktlzz/ImgBed@master/20201212202733.png alt=20201212202733></p><p>只要两个容器启动时都通过 <strong>&ndash;net</strong>，选用了同一个已创建的网络，不同容器间即可通过 ip 地址或容器名/id 连通：</p><p><img src=https://cdn.jsdelivr.net/gh/koktlzz/ImgBed@master/20201212203023.png alt=20201212203023></p><h3 id=网络连通>网络连通<a href=#网络连通 class=anchor aria-hidden=true>#</a></h3><p><img src=https://cdn.jsdelivr.net/gh/koktlzz/ImgBed@master/20201212204434.png alt=20201212204434></p><p>对于建立在不同网络下 (docker0, newnet) 的两个容器 tomcat01 和 tomcat02，他们的网段不同，因此是无法彼此 ping 通容器内部的：</p><p><img src=https://cdn.jsdelivr.net/gh/koktlzz/ImgBed@master/20201212204311.png alt=20201212204311></p><p>这时我们需要通过 <strong>docker network connect</strong> 命令打通容器与网络之间的连接：</p><div class=highlight><pre style=color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-bash data-lang=bash>docker network connect 网络名 容器名/id
</code></pre></div><p><img src=https://cdn.jsdelivr.net/gh/koktlzz/ImgBed@master/20201212203803.png alt=20201212203803></p><p>这个功能类似于将一个容器赋予多个 ip 地址，同样可以用 <strong>docker network inspect</strong> 命令查看网络连通后，该网络的变化：</p><p><img src=https://cdn.jsdelivr.net/gh/koktlzz/ImgBed@master/20201212204235.png alt=20201212204235></p><p>原本 newnet 网络中只含有 tomcat02，现在增加了 tomcat01，因此可以连通。</p><p class=edit-page><a href=https://github.com/koktlzz/koktlzz.github.io/blob/master/content/Docker/Docker%e5%9f%ba%e7%a1%80/%e7%8b%82%e7%a5%9eDocker%e8%af%be%e7%a8%8b%e7%ac%94%e8%ae%b0.md><svg xmlns="http://www.w3.org/2000/svg" width="16" height="16" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="feather feather-edit-2"><path d="M17 3a2.828 2.828.0 114 4L7.5 20.5 2 22l1.5-5.5L17 3z"/></svg>Edit this page on GitHub</a></p><div class="docs-navigation d-flex justify-content-between"><a href=https://koktlzz.github.io/docker/docker%E5%9F%BA%E7%A1%80/intro/><div class="card my-1"><div class="card-body py-2">&larr; Get Started</div></div></a><a class=ms-auto href=https://koktlzz.github.io/docker/docker%E5%9F%BA%E7%A1%80/dockercompose/><div class="card my-1"><div class="card-body py-2">Docker Compose &rarr;</div></div></a></div><script src=https://utteranc.es/client.js repo=koktlzz/koktlzz.github.io issue-term=pathname theme=photon-dark crossorigin=anonymous async></script></main><nav class="docs-toc d-none d-xl-block col-lg-3 col-xl-2" aria-label="Secondary navigation"><div class=page-links><h3>On this page</h3><nav id=TableOfContents><ul><li><a href=#课程链接>课程链接</a></li><li><a href=#docker-为什么出现>Docker 为什么出现？</a></li><li><a href=#docker-能做什么>Docker 能做什么？</a><ul><li><a href=#传统虚拟机与-docker-对比>传统虚拟机与 Docker 对比</a></li><li><a href=#docker-的优点>Docker 的优点</a></li><li><a href=#docker-实现-devops>Docker 实现 DevOps</a></li></ul></li><li><a href=#docker-的基本组成>Docker 的基本组成</a></li><li><a href=#docker-运行原理>Docker 运行原理</a></li><li><a href=#docker-的常用命令>Docker 的常用命令</a><ul><li><a href=#帮助命令>帮助命令</a></li><li><a href=#镜像命令>镜像命令</a></li><li><a href=#容器命令>容器命令</a></li><li><a href=#其他命令>其他命令</a></li></ul></li><li><a href=#docker-镜像详解>Docker 镜像详解</a><ul><li><a href=#unionfs联合文件系统>UnionFS（联合文件系统）</a></li><li><a href=#镜像加载原理>镜像加载原理</a></li></ul></li><li><a href=#容器数据卷>容器数据卷</a><ul><li><a href=#什么是容器数据卷>什么是容器数据卷？</a></li><li><a href=#使用容器数据卷>使用容器数据卷</a></li><li><a href=#匿名挂载>匿名挂载</a></li><li><a href=#具名挂载>具名挂载</a></li><li><a href=#数据卷容器>数据卷容器</a></li></ul></li><li><a href=#dockerfile>DockerFile</a><ul><li><a href=#构建步骤>构建步骤</a></li><li><a href=#dockerfile-命令>dockerfile 命令</a></li><li><a href=#构建过程>构建过程</a></li><li><a href=#构建实例>构建实例</a></li></ul></li><li><a href=#docker-网络>Docker 网络</a><ul><li><a href=#理解-doker0>理解 Doker0</a></li><li><a href=#--link>&ndash;link</a></li><li><a href=#自定义网络>自定义网络</a></li><li><a href=#网络连通>网络连通</a></li></ul></li></ul></nav></div></nav></div></div></div><footer class="footer text-muted"><div class=container><div class=row><div class="col-lg-8 order-last order-lg-first"><ul class=list-inline><li class=list-inline-item></li></ul></div><div class="col-lg-8 order-first order-lg-last text-lg-end"><ul class=list-inline></ul></div></div></div></footer><script src=https://koktlzz.github.io/js/bootstrap.min.d67050adf5d370668aede4201f82af781b16970934804995a1ca37c1ee9222c2fc530972aa6d5d2b6124caf1fe318f139aac99df2c1e89af65504fc1185c7972.js integrity="sha512-1nBQrfXTcGaK7eQgH4KveBsWlwk0gEmVoco3we6SIsL8Uwlyqm1dK2EkyvH+MY8TmqyZ3yweia9lUE/BGFx5cg==" crossorigin=anonymous defer></script><script src=https://koktlzz.github.io/js/vendor/katex/dist/katex.min.b334e5b00c45f572e7f38a543046f36854bf4cbb543880480c09271a0efedc694d6905f719934f6ede2f26f52e80411c05b90121d722cbf8be2fa8fc51bc6b81.js integrity="sha512-szTlsAxF9XLn84pUMEbzaFS/TLtUOIBIDAknGg7+3GlNaQX3GZNPbt4vJvUugEEcBbkBIdciy/i+L6j8UbxrgQ==" crossorigin=anonymous defer></script><script src=https://koktlzz.github.io/js/vendor/katex/dist/contrib/auto-render.min.916823ec103cf367b71e28a6f01513cb9c3ac6708ccb5229402ec46b8e30a8b25003db694df35d80e9dd666a371f327c6152790617b6256390c164109a90bd4c.js integrity="sha512-kWgj7BA882e3Hiim8BUTy5w6xnCMy1IpQC7Ea44wqLJQA9tpTfNdgOndZmo3HzJ8YVJ5Bhe2JWOQwWQQmpC9TA==" crossorigin=anonymous defer></script><script src=https://koktlzz.github.io/main.min.1febbf2f6fd6a36fc2f57dd50d7935fbb640743329baeb4ef7cefcf2e7630e413371fbba976e103656b82808ee227dc4a84237edb0f8433648bef3a56900661a.js integrity="sha512-H+u/L2/Wo2/C9X3VDXk1+7ZAdDMpuutO98788udjDkEzcfu6l24QNla4KAjuIn3EqEI37bD4QzZIvvOlaQBmGg==" crossorigin=anonymous defer></script></body></html>