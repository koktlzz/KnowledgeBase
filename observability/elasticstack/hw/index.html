<!doctype html><html lang=en-us><head><script async src="https://www.googletagmanager.com/gtag/js?id=G-D022F6NT2P"></script><script>window.dataLayer=window.dataLayer||[];function gtag(){dataLayer.push(arguments)}gtag('js',new Date),gtag('config','G-D022F6NT2P')</script><script>(function(b,d,e,a,g){b[a]=b[a]||[],b[a].push({'gtm.start':(new Date).getTime(),event:'gtm.js'});var f=d.getElementsByTagName(e)[0],c=d.createElement(e),h=a!='dataLayer'?'&l='+a:'';c.async=!0,c.src='https://www.googletagmanager.com/gtm.js?id='+g+h,f.parentNode.insertBefore(c,f)})(window,document,'script','dataLayer','GTM-P72R45W')</script><meta charset=utf-8><meta http-equiv=x-ua-compatible content="ie=edge"><meta name=viewport content="width=device-width,initial-scale=1,shrink-to-fit=no"><link rel=preload as=font href=https://koktlzz.github.io/fonts/vendor/jost/jost-v4-latin-regular.woff2 type=font/woff2 crossorigin><link rel=preload as=font href=https://koktlzz.github.io/fonts/vendor/jost/jost-v4-latin-700.woff2 type=font/woff2 crossorigin><link rel=preload as=font href=https://koktlzz.github.io/fonts/KaTeX_Main-Regular.woff2 type=font/woff2 crossorigin><link rel=preload as=font href=https://koktlzz.github.io/fonts/KaTeX_Math-Italic.woff2 type=font/woff2 crossorigin><link rel=stylesheet href=https://koktlzz.github.io/main.27967119d9bfd1f18848f648c47494cdf9c8666df2bb5d54d01736bacd6e74dc5f8b9b2cbc827df0fc8e4cef4f4bae41b13b93c84017caf5272a107d6f2af5cc.css integrity="sha512-J5ZxGdm/0fGISPZIxHSUzfnIZm3yu11U0Bc2us1udNxfi5ssvIJ98PyOTO9PS65BsTuTyEAXyvUnKhB9byr1zA==" crossorigin=anonymous><noscript><style>img.lazyload{display:none}</style></noscript><meta name=robots content="index, follow"><meta name=googlebot content="index, follow, max-snippet:-1, max-image-preview:large, max-video-preview:-1"><meta name=bingbot content="index, follow, max-snippet:-1, max-image-preview:large, max-video-preview:-1"><title>Kafka 副本备份 | KnowledgeBase</title><meta name=description content><link rel=canonical href=https://koktlzz.github.io/observability/elasticstack/hw/><meta property="og:locale" content="en_US"><meta property="og:type" content="article"><meta property="og:title" content="Kafka 副本备份"><meta property="og:description" content="通常，Kafka 中的每个 Partiotion 中有多个副本 (Replica) 用于实现高可用，使用相关命令可以查看某一 Topic 中的 Partition 数量、Leader、Follower 以及 ISR 的情况：
[root@test-ece-kafka2 kafka]# ./bin/kafka-topics.sh --describe --zookeeper test-zk1:2181 --topic uat-log Topic:uat-log PartitionCount:5 ReplicationFactor:2 Configs: Topic: uat-log Partition: 0 Leader: 1 Replicas: 1,3 Isr: 3,1 Topic: uat-log Partition: 1 Leader: 2 Replicas: 2,1 Isr: 2,1 Topic: uat-log Partition: 2 Leader: 3 Replicas: 3,2 Isr: 2,3 Topic: uat-log Partition: 3 Leader: 1 Replicas: 1,2 Isr: 2,1 Topic: uat-log Partition: 4 Leader: 2 Replicas: 2,3 Isr: 2,3 想象一个场景，Consumer 正在消费 Leader 中 Offset=10 的数据，而此时 Follower 中只同步到 Offset=8。那么当 Leader 所在的 Broker 宕机后，当前 Follower 经选举成为新的 Leader，Consumer 再次消费时便会报错。因此，Kafka 引入了 High Watermark（高水位）来保证副本数据的可靠性和一致性。"><meta property="og:url" content="https://koktlzz.github.io/observability/elasticstack/hw/"><meta property="og:site_name" content="KnowledgeBase"><meta property="article:published_time" content="2020-11-04T09:19:42+01:00"><meta property="article:modified_time" content="2020-11-04T09:19:42+01:00"><meta property="og:image" content="https://koktlzz.github.io/doks.png"><meta property="og:image:alt" content="KnowledgeBase"><meta name=twitter:card content="summary_large_image"><meta name=twitter:site content="@getdoks"><meta name=twitter:creator content="@henkverlinde"><meta name=twitter:title content="Kafka 副本备份"><meta name=twitter:description content><meta name=twitter:image content="https://koktlzz.github.io/doks.png"><meta name=twitter:image:alt content="Kafka 副本备份"><script type=application/ld+json>{"@context":"https://schema.org","@graph":[{"@type":"Organization","@id":"https://koktlzz.github.io/#/schema/organization/1","name":"Doks","url":"https://koktlzz.github.io/","sameAs":["https://twitter.com/getdoks","https://github.com/h-enk/doks"],"logo":{"@type":"ImageObject","@id":"https://koktlzz.github.io/#/schema/image/1","url":"https://koktlzz.github.io/logo-doks.png","width":512,"height":512,"caption":"Doks"},"image":{"@id":"https://koktlzz.github.io/#/schema/image/1"}},{"@type":"WebSite","@id":"https://koktlzz.github.io/#/schema/website/1","url":"https://koktlzz.github.io/","name":"KnowledgeBase","description":"","publisher":{"@id":"https://koktlzz.github.io/#/schema/organization/1"}},{"@type":"WebPage","@id":"https://koktlzz.github.io/observability/elasticstack/hw/","url":"https://koktlzz.github.io/observability/elasticstack/hw/","name":"Kafka 副本备份","description":"","isPartOf":{"@id":"https://koktlzz.github.io/#/schema/website/1"},"about":{"@id":"https://koktlzz.github.io/#/schema/organization/1"},"datePublished":"2020-11-04T09:19:42CET","dateModified":"2020-11-04T09:19:42CET","breadcrumb":{"@id":"https://koktlzz.github.io/observability/elasticstack/hw/#/schema/breadcrumb/1"},"primaryImageOfPage":{"@id":"https://koktlzz.github.io/observability/elasticstack/hw/#/schema/image/2"},"inLanguage":"en-US","potentialAction":[{"@type":"ReadAction","target":["https://koktlzz.github.io/observability/elasticstack/hw/"]}]},{"@type":"BreadcrumbList","@id":"https://koktlzz.github.io/observability/elasticstack/hw/#/schema/breadcrumb/1","name":"Breadcrumbs","itemListElement":[{"@type":"ListItem","position":1,"item":{"@type":"WebPage","@id":"https://koktlzz.github.io/","url":"https://koktlzz.github.io/","name":"Home"}},{"@type":"ListItem","position":2,"item":{"@type":"WebPage","@id":"https://koktlzz.github.io/observability/","url":"https://koktlzz.github.io/observability/","name":"Observability"}},{"@type":"ListItem","position":3,"item":{"@type":"WebPage","@id":"https://koktlzz.github.io/observability/elasticstack/","url":"https://koktlzz.github.io/observability/elasticstack/","name":"Elasticstack"}},{"@type":"ListItem","position":4,"item":{"@id":"https://koktlzz.github.io/observability/elasticstack/hw/"}}]},{"@context":"https://schema.org","@graph":[{"@type":"ImageObject","@id":"https://koktlzz.github.io/observability/elasticstack/hw/#/schema/image/2","url":"https://koktlzz.github.io/doks.png","contentUrl":"https://koktlzz.github.io/doks.png","caption":"Kafka 副本备份"}]}]}</script><meta name=theme-color content="#fff"><link rel=apple-touch-icon sizes=180x180 href=https://koktlzz.github.io/apple-touch-icon.png><link rel=icon type=image/png sizes=32x32 href=https://koktlzz.github.io/favicon-32x32.ico><link rel=icon type=image/png sizes=16x16 href=https://koktlzz.github.io/favicon-16x16.ico><link rel=manifest crossorigin=use-credentials href=https://koktlzz.github.io/site.webmanifest></head><body class="Observability single dark"><noscript><iframe src="https://www.googletagmanager.com/ns.html?id=GTM-P72R45W" height=0 width=0 style=display:none;visibility:hidden></iframe></noscript><div class="header-bar fixed-top"></div><header class="navbar fixed-top navbar-expand-md navbar-light"><div class=container-fluid><input class="menu-btn order-0" type=checkbox id=menu-btn>
<label class="menu-icon d-md-none" for=menu-btn><span class=navicon></span></label><a class="navbar-brand order-1 order-md-0 me-auto" href=https://koktlzz.github.io/>KnowledgeBase</a>
<button id=mode class="btn btn-link order-2 order-md-4" type=button aria-label="Toggle mode">
<span class=toggle-dark><svg xmlns="http://www.w3.org/2000/svg" width="20" height="20" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="feather feather-moon"><path d="M21 12.79A9 9 0 1111.21 3 7 7 0 0021 12.79z"/></svg></span><span class=toggle-light><svg xmlns="http://www.w3.org/2000/svg" width="20" height="20" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="feather feather-sun"><circle cx="12" cy="12" r="5"/><line x1="12" y1="1" x2="12" y2="3"/><line x1="12" y1="21" x2="12" y2="23"/><line x1="4.22" y1="4.22" x2="5.64" y2="5.64"/><line x1="18.36" y1="18.36" x2="19.78" y2="19.78"/><line x1="1" y1="12" x2="3" y2="12"/><line x1="21" y1="12" x2="23" y2="12"/><line x1="4.22" y1="19.78" x2="5.64" y2="18.36"/><line x1="18.36" y1="5.64" x2="19.78" y2="4.22"/></svg></span></button><ul class="navbar-nav social-nav order-3 order-md-5"><li class=nav-item><a class=nav-link href=https://github.com/koktlzz><svg xmlns="http://www.w3.org/2000/svg" width="20" height="20" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="feather feather-github"><path d="M9 19c-5 1.5-5-2.5-7-3m14 6v-3.87a3.37 3.37.0 00-.94-2.61c3.14-.35 6.44-1.54 6.44-7A5.44 5.44.0 0020 4.77 5.07 5.07.0 0019.91 1S18.73.65 16 2.48a13.38 13.38.0 00-7 0C6.27.65 5.09 1 5.09 1A5.07 5.07.0 005 4.77 5.44 5.44.0 003.5 8.55c0 5.42 3.3 6.61 6.44 7A3.37 3.37.0 009 18.13V22"/></svg><span class="ms-2 visually-hidden">GitHub</span></a></li></ul><div class="collapse navbar-collapse order-4 order-md-1"><ul class="navbar-nav main-nav me-auto order-5 order-md-2"><li class=nav-item><a class=nav-link href=https://koktlzz.github.io/container/docker/intro>Container</a></li><li class=nav-item><a class=nav-link href=https://koktlzz.github.io/observability/elasticstack/intro>Observability</a></li><li class=nav-item><a class=nav-link href=https://koktlzz.github.io/programming/go/intro>Programming</a></li><li class=nav-item><a class=nav-link href=https://koktlzz.github.io/infrastructure/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/tcpip%E7%BD%91%E7%BB%9C%E6%A8%A1%E5%9E%8B>Infrastructure</a></li></ul><div class="break order-6 d-md-none"></div></div></div></header><div class="wrap container-fluid" role=document><div class=content><div class="row flex-xl-nowrap"><div class="col-lg-4 col-xl-3 d-none d-xl-block"><nav class=docs-links aria-label="Main navigation"><h3>ElasticStack</h3><ul class=list-unstyled><li><a class=docs-link href=https://koktlzz.github.io/observability/elasticstack/intro/>Getting Started</a></li><li><a class=docs-link href=https://koktlzz.github.io/observability/elasticstack/%E5%8D%95%E8%8A%82%E7%82%B9%E9%83%A8%E7%BD%B2%E6%B5%81%E7%A8%8B/>单节点部署流程</a></li><li><a class=docs-link href=https://koktlzz.github.io/observability/elasticstack/elasticsearchintro/>ElasticSearch 简介</a></li><li><a class=docs-link href=https://koktlzz.github.io/observability/elasticstack/mapping/>Mapping</a></li><li><a class=docs-link href=https://koktlzz.github.io/observability/elasticstack/textanalysis/>Text analysis</a></li><li><a class=docs-link href=https://koktlzz.github.io/observability/elasticstack/template/>Template</a></li><li><a class=docs-link href=https://koktlzz.github.io/observability/elasticstack/ilm/>ILM</a></li><li><a class=docs-link href=https://koktlzz.github.io/observability/elasticstack/snapshot/>Snapshot</a></li><li><a class=docs-link href=https://koktlzz.github.io/observability/elasticstack/%E6%80%A7%E8%83%BD%E8%B0%83%E4%BC%98/>Elasticsearch 性能调优</a></li><li><a class=docs-link href=https://koktlzz.github.io/observability/elasticstack/kafkaintro/>Kafka 简介</a></li><li><a class=docs-link href=https://koktlzz.github.io/observability/elasticstack/hw/>Kafka 副本备份</a></li><li><a class=docs-link href=https://koktlzz.github.io/observability/elasticstack/transaction/>Kafka 事务</a></li></ul><h3>Prometheus</h3><ul class=list-unstyled><li><a class=docs-link href=https://koktlzz.github.io/observability/prometheus/intro/>Getting Started</a></li><li><a class=docs-link href=https://koktlzz.github.io/observability/prometheus/operator%E8%87%AA%E5%AE%9A%E4%B9%89%E9%85%8D%E7%BD%AE/>Operator 自定义配置</a></li></ul><h3>Opentelemetry</h3><ul class=list-unstyled><li><a class=docs-link href=https://koktlzz.github.io/observability/opentelemetry/intro/>Getting Started</a></li><li><a class=docs-link href=https://koktlzz.github.io/observability/opentelemetry/collectorexample/>Collector Example</a></li></ul></nav></div><main class="docs-content col-lg-12 col-xl-10"><h1>Kafka 副本备份</h1><p class=lead></p><p>通常，Kafka 中的每个 Partiotion 中有多个副本 (Replica) 用于实现高可用，使用相关命令可以查看某一 Topic 中的 Partition 数量、Leader、Follower 以及 ISR 的情况：</p><div class=highlight><pre style=color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-bash data-lang=bash><span style=color:#ff79c6>[</span>root@test-ece-kafka2 kafka<span style=color:#ff79c6>]</span><span style=color:#6272a4># ./bin/kafka-topics.sh --describe --zookeeper test-zk1:2181 --topic uat-log</span>
Topic:uat-log  PartitionCount:5        ReplicationFactor:2     Configs:
        Topic: uat-log Partition: <span style=color:#bd93f9>0</span>    Leader: <span style=color:#bd93f9>1</span>       Replicas: 1,3   Isr: 3,1
        Topic: uat-log Partition: <span style=color:#bd93f9>1</span>    Leader: <span style=color:#bd93f9>2</span>       Replicas: 2,1   Isr: 2,1
        Topic: uat-log Partition: <span style=color:#bd93f9>2</span>    Leader: <span style=color:#bd93f9>3</span>       Replicas: 3,2   Isr: 2,3
        Topic: uat-log Partition: <span style=color:#bd93f9>3</span>    Leader: <span style=color:#bd93f9>1</span>       Replicas: 1,2   Isr: 2,1
        Topic: uat-log Partition: <span style=color:#bd93f9>4</span>    Leader: <span style=color:#bd93f9>2</span>       Replicas: 2,3   Isr: 2,3
</code></pre></div><p>想象一个场景，Consumer 正在消费 Leader 中 Offset=10 的数据，而此时 Follower 中只同步到 Offset=8。那么当 Leader 所在的 Broker 宕机后，当前 Follower 经选举成为新的 Leader，Consumer 再次消费时便会报错。因此，Kafka 引入了 High Watermark（高水位）来保证副本数据的可靠性和一致性。</p><h2 id=high-watermarkhw>High Watermark（HW）<a href=#high-watermarkhw class=anchor aria-hidden=true>#</a></h2><p>HW 定义了消息的可见性，即标识 Partition 中的哪些消息是可以被 Consumer 消费的，只有小于 HW 值的消息才被认为是已备份或已提交的（committed）。而 LEO（Log End Offset）则表示副本写入<strong>下一条</strong>消息的 Offset，因此同一副本的 HW 值永远不会大于其 LEO 值。</p><p><img src=https://cdn.jsdelivr.net/gh/koktlzz/ImgBed@master/202103230302.jpeg alt=202103230302></p><p>当集群中副本所在的 Broker 发生故障而后恢复时，副本先将数据截断（Truncation）到其 HW 处（LEO 等于 HW），然后再开始向 Leader 同步数据。</p><h2 id=hw-的更新机制>HW 的更新机制<a href=#hw-的更新机制 class=anchor aria-hidden=true>#</a></h2><p>每一个副本都保存了其 HW 值和 LEO 值，即 Leader HW（实际上也是 Partition HW）、Leader LEO 和 Follower HW、Follower LEO。而 Leader 所在的 Broker 上还保存了其他 Follower 的 LEO 值，称为 Remote LEO。上述几个值的更新流程如下：</p><p><img src=https://cdn.jsdelivr.net/gh/koktlzz/ImgBed@master/202103230149.jpeg alt=202103230149></p><p>如图所示，当 Producer 向 log 文件写入数据时，Leader LEO 首先被更新。而 Remote LEO 要等到 Follower 向 Leader 发送同步请求（Fetch）时，才会根据请求携带的当前 Follower LEO 值更新。随后，Leader 计算所有副本 LEO 的最小值，将其作为新的 Leader HW。考虑到 Leader HW 只能单调递增，因此还增加了一个 LEO 最小值与当前 Leader HW 的比较，防止 Leader HW 值降低（<code>max[Leader HW, min(All LEO)]</code>）。</p><p>Follower 在接收到 Leader 的响应（Response）后，首先将消息写入 log 文件中，随后更新 Follower LEO。由于 Response 中携带了新的 Leader HW，Follower 将其与刚刚更新过的 Follower LEO 相比较，取最小值作为 Follower HW（<code>min(Follower LEO, Leader HW)</code>）。</p><p>举例来说，如果一开始 Leader 和 Follower 中没有任何数据，即所有值均为 0。那么当 Prouder 向 Leader 写入第一条消息，上述几个值的变化顺序如下：</p><table><thead><tr><th></th><th>Leader LEO</th><th>Remote LEO</th><th>Leader HW</th><th>Follower LEO</th><th>Follower HW</th></tr></thead><tbody><tr><td>Producer Write</td><td>1</td><td>0</td><td>0</td><td>0</td><td>0</td></tr><tr><td>Follower Fetch</td><td>1</td><td>0</td><td>0</td><td>0</td><td>0</td></tr><tr><td>Leader Update HW</td><td>1</td><td>0</td><td>0</td><td>0</td><td>0</td></tr><tr><td>Leader Response</td><td>1</td><td>0</td><td>0</td><td>1</td><td>0</td></tr><tr><td>Follower Update HW</td><td>1</td><td>0</td><td>0</td><td>1</td><td>0</td></tr><tr><td>Follower Fetch</td><td>1</td><td>1</td><td>0</td><td>1</td><td>0</td></tr><tr><td>Leader Update HW</td><td>1</td><td>1</td><td>1</td><td>1</td><td>0</td></tr><tr><td>Leader Response</td><td>1</td><td>1</td><td>1</td><td>1</td><td>0</td></tr><tr><td>Follower Update HW</td><td>1</td><td>1</td><td>1</td><td>1</td><td>1</td></tr></tbody></table><h2 id=hw-的隐患>HW 的隐患<a href=#hw-的隐患 class=anchor aria-hidden=true>#</a></h2><p>通过上面的表格我们发现，Follower 往往需要进行两次 Fetch 请求才能成功更新 HW。Follower HW 在某一阶段内总是落后于 Leader HW，因此副本在根据 HW 值截取数据时将有可能发生数据的丢失或不一致。</p><p><img src=https://cdn.jsdelivr.net/gh/koktlzz/ImgBed@master/202103241107.jpeg alt=202103241107></p><p>图中两副本的 LEO 均为 2，但 Leader 副本 B 上的 HW 为 2，Follower 副本 A 上的 HW 为 1。正常情况下，副本 A 将在接收 Leader Response 后根据 Leader HW 更新其 Follower HW 为 2。但假如此时副本 A 所在的 Broker 重启，它会把 Follower LEO 修改为重启前自身的 HW 值 1，因此数据 M1（Offset=1）被截断。当副本 A 重新向副本 B 发送同步请求时，如果副本 B 所在的 Broker 发生宕机，副本 A 将被选举成为新的 Leader。即使副本 B 所在的 Broker 能够成功重启且其 LEO 值依然为 2，但只要它向当前 Leader（副本 A）发起同步请求后就会更新其 HW 为 1（计算<code>min(Follower LEO, Leader HW)</code>），数据 M1（Offset=1）随即被截断。如果<code>min.insync.replicas</code>参数为 1，那么 Producer 不会因副本 A 没有同步成功而重新发送消息，M1 也就永远丢失了。</p><p><img src=https://cdn.jsdelivr.net/gh/koktlzz/ImgBed@master/202103241119.jpeg alt=202103241119></p><p>图中 Leader 副本 B 写入了两条数据 M0 和 M1，Follower 副本 A 只写入了一条数据 M0。此时 Leader HW 为 2，Follower HW 为 1。如果在 Follower 同步第二条数据前，两副本所在的 Broker 均发生重启且副本 B 所在的 Broker 先重启成功，那么副本 A 将成为新的 Leader。这时 Producer 向其写入数据 M2，副本 A 作为集群中的唯一副本，更新其 HW 为 2。当副本 B 所在的 Broker 重启后，它将向当前的 Leader 副本 A 同步数据。由于两者的 HW 均为 2，因此副本 B 不需要进行任何截断操作。在这种情况下，副本 B 中的数据为重启前的 M0 和 M1，副本 A 中的数据却是 M0 和 M2，副本间的数据出现了不一致。</p><h2 id=leader-epoch>Leader Epoch<a href=#leader-epoch class=anchor aria-hidden=true>#</a></h2><p>Kakfa 引入 Leader Epoch 后，Follower 就不再参考 HW，而是根据 Leader Epoch 信息来截断 Leader 中不存在的消息。这种机制可以弥补基于 HW 的副本同步机制的不足，Leader Epoch 由两部分组成：</p><ul><li>Epoch：一个单调增加的版本号。每当 Leader 副本发生变更时，都会增加该版本号。Epoch 值较小的 Leader 被认为是过期 Leader，不能再行使 Leader 的权力；</li><li>起始位移（Start Offset）：Leader 副本在该 Epoch 值上写入首条消息的 Offset。</li></ul><p>举例来说，某个 Partition 有两个 Leader Epoch，分别为 (0, 0) 和 (1, 100)。这意味该 Partion 历经一次 Leader 副本变更，版本号为 0 的 Leader 从 Offset=0 处开始写入消息，共写入了 100 条。而版本号为 1 的 Leader 则从 Offset=100 处开始写入消息。</p><p>每个副本的 Leader Epoch 信息既缓存在内存中，也会定期写入消息目录下的 leaderer-epoch-checkpoint 文件中。当一个 Follower 副本从故障中恢复重新加入 ISR 中，它将：</p><ol><li>向 Leader 发送 LeaderEpochRequest，请求中包含了 Follower 的 Epoch 信息；</li><li>Leader 将返回其 Follower 所在 Epoch 的 Last Offset；</li><li>如果 Leader 与 Follower 处于同一 Epoch，那么 Last Offset 显然等于 Leader LEO；</li><li>如果 Follower 的 Epoch 落后于 Leader，则 Last Offset 等于 Follower Epoch + 1 所对应的 Start Offset。这可能有点难以理解，我们还是以 (0, 0) 和 (1, 100) 为例进行说明：Offset=100 的消息既是 Epoch=1 的 Start Offset，也是 Epoch=0 的 Last Offset；</li><li>Follower 接收响应后根据返回的 Last Offset 截断数据；</li><li>在数据同步期间，只要 Follower 发现 Leader 返回的 Epoch 信息与自身不一致，便会随之更新 Leader Epoch 并写入磁盘。</li></ol><p><img src=https://cdn.jsdelivr.net/gh/koktlzz/ImgBed@master/202103261242.jpeg alt=202103261242></p><p>在刚刚介绍的数据丢失场景中，副本 A 所在的 Broker 重启后根据自身的 HW 将数据 M1 截断。而现在，副本 A 重启后会先向副本 B 发送一个请求（LeaderEpochRequest）。由于两副本的 Epoch 均为 0，副本 B 返回的 Last Offset 为 Leader LEO 值 2。而副本 A 上并没有 Offset 大于等 2 的消息，因此无需进行数据截断，同时其 HW 也会更新为 2。之后副本 B 所在的 Broker 宕机，副本 A 成为新的 Leader，Leader Epoch 随即更新为 (1, 2)。当副本 B 重启回来并向当前 Leader 副本 A 发送 LeaderEpochRequest，得到的 Last Offset 为 Epoch=1 对应的 Start Offset 值 2。同样，副本 B 中消息的最大 Offset 值只有 1，因此也无需进行数据截断，消息 M1 成功保留了下来。</p><p><img src=https://cdn.jsdelivr.net/gh/koktlzz/ImgBed@master/202103261249.jpeg alt=202103261249></p><p>在刚刚介绍的数据不一致场景中，由于最后两副本 HW 值相等，因此没有将不一致的数据截断。而现在，副本 A 重启后并便会更新 Leader Epoch 为 (1, 1)，同时也会更新其 HW 值为 2。副本 B 重启后向当前 Leader 副本 A 发送 LeaderEpochRequest，得到的 Last Offset 为 Epoch=1 对应的 Start Offset 值 1，因此截断 Offset=1 的消息 M1。这样只要副本 B 再次发起请求同步消息 M2，两副本的数据便可以保持一致。</p><p>值得一提的是，Leader Epoch 机制在<code>min.insync.replicas</code>参数为 1 且<code>unclean.leader.election.enabled</code>参数为<code>true</code>时依然无法保证数据的可靠性。这里不再赘述，可参考 <a href=https://cwiki.apache.org/confluence/display/KAFKA/KIP-101+-+Alter+Replication+Protocol+to+use+Leader+Epoch+rather+than+High+Watermark+for+Truncation>KIP-101 - Alter Replication Protocol to use Leader Epoch rather than High Watermark for Truncation</a> 文中的附录部分。</p><h2 id=参考文献>参考文献<a href=#参考文献 class=anchor aria-hidden=true>#</a></h2><p><a href=https://cwiki.apache.org/confluence/display/KAFKA/KIP-101+-+Alter+Replication+Protocol+to+use+Leader+Epoch+rather+than+High+Watermark+for+Truncation>KIP-101 - Alter Replication Protocol to use Leader Epoch rather than High Watermark for Truncation</a></p><p class=edit-page><a href=https://github.com/koktlzz/koktlzz.github.io/blob/master/content/Observability/ElasticStack/HW.md><svg xmlns="http://www.w3.org/2000/svg" width="16" height="16" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="feather feather-edit-2"><path d="M17 3a2.828 2.828.0 114 4L7.5 20.5 2 22l1.5-5.5L17 3z"/></svg>Edit this page on GitHub</a></p><div class="docs-navigation d-flex justify-content-between"><a href=https://koktlzz.github.io/observability/elasticstack/kafkaintro/><div class="card my-1"><div class="card-body py-2">&larr; Kafka 简介</div></div></a><a class=ms-auto href=https://koktlzz.github.io/observability/elasticstack/transaction/><div class="card my-1"><div class="card-body py-2">Kafka 事务 &rarr;</div></div></a></div><script src=https://utteranc.es/client.js repo=koktlzz/koktlzz.github.io issue-term=pathname theme=photon-dark crossorigin=anonymous async></script></main><nav class="docs-toc d-none d-xl-block col-lg-3 col-xl-2" aria-label="Secondary navigation"><div class=page-links><h3>On this page</h3><nav id=TableOfContents><ul><li><a href=#high-watermarkhw>High Watermark（HW）</a></li><li><a href=#hw-的更新机制>HW 的更新机制</a></li><li><a href=#hw-的隐患>HW 的隐患</a></li><li><a href=#leader-epoch>Leader Epoch</a></li><li><a href=#参考文献>参考文献</a></li></ul></nav></div></nav></div></div></div><script src=https://koktlzz.github.io/js/bootstrap.min.d67050adf5d370668aede4201f82af781b16970934804995a1ca37c1ee9222c2fc530972aa6d5d2b6124caf1fe318f139aac99df2c1e89af65504fc1185c7972.js integrity="sha512-1nBQrfXTcGaK7eQgH4KveBsWlwk0gEmVoco3we6SIsL8Uwlyqm1dK2EkyvH+MY8TmqyZ3yweia9lUE/BGFx5cg==" crossorigin=anonymous defer></script><script src=https://koktlzz.github.io/js/vendor/katex/dist/katex.min.b334e5b00c45f572e7f38a543046f36854bf4cbb543880480c09271a0efedc694d6905f719934f6ede2f26f52e80411c05b90121d722cbf8be2fa8fc51bc6b81.js integrity="sha512-szTlsAxF9XLn84pUMEbzaFS/TLtUOIBIDAknGg7+3GlNaQX3GZNPbt4vJvUugEEcBbkBIdciy/i+L6j8UbxrgQ==" crossorigin=anonymous defer></script><script src=https://koktlzz.github.io/js/vendor/katex/dist/contrib/auto-render.min.916823ec103cf367b71e28a6f01513cb9c3ac6708ccb5229402ec46b8e30a8b25003db694df35d80e9dd666a371f327c6152790617b6256390c164109a90bd4c.js integrity="sha512-kWgj7BA882e3Hiim8BUTy5w6xnCMy1IpQC7Ea44wqLJQA9tpTfNdgOndZmo3HzJ8YVJ5Bhe2JWOQwWQQmpC9TA==" crossorigin=anonymous defer></script><script src=https://koktlzz.github.io/main.min.1febbf2f6fd6a36fc2f57dd50d7935fbb640743329baeb4ef7cefcf2e7630e413371fbba976e103656b82808ee227dc4a84237edb0f8433648bef3a56900661a.js integrity="sha512-H+u/L2/Wo2/C9X3VDXk1+7ZAdDMpuutO98788udjDkEzcfu6l24QNla4KAjuIn3EqEI37bD4QzZIvvOlaQBmGg==" crossorigin=anonymous defer></script></body></html>