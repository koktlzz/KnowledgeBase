<!doctype html><html lang=en-us><head><script async src="https://www.googletagmanager.com/gtag/js?id=G-D022F6NT2P"></script><script>window.dataLayer=window.dataLayer||[];function gtag(){dataLayer.push(arguments)}gtag('js',new Date),gtag('config','G-D022F6NT2P')</script><script>(function(b,d,e,a,g){b[a]=b[a]||[],b[a].push({'gtm.start':(new Date).getTime(),event:'gtm.js'});var f=d.getElementsByTagName(e)[0],c=d.createElement(e),h=a!='dataLayer'?'&l='+a:'';c.async=!0,c.src='https://www.googletagmanager.com/gtm.js?id='+g+h,f.parentNode.insertBefore(c,f)})(window,document,'script','dataLayer','GTM-P72R45W')</script><meta charset=utf-8><meta http-equiv=x-ua-compatible content="ie=edge"><meta name=viewport content="width=device-width,initial-scale=1,shrink-to-fit=no"><link rel=preload as=font href=https://koktlzz.github.io/fonts/vendor/jost/jost-v4-latin-regular.woff2 type=font/woff2 crossorigin><link rel=preload as=font href=https://koktlzz.github.io/fonts/vendor/jost/jost-v4-latin-700.woff2 type=font/woff2 crossorigin><link rel=preload as=font href=https://koktlzz.github.io/fonts/KaTeX_Main-Regular.woff2 type=font/woff2 crossorigin><link rel=preload as=font href=https://koktlzz.github.io/fonts/KaTeX_Math-Italic.woff2 type=font/woff2 crossorigin><link rel=stylesheet href=https://koktlzz.github.io/main.6fd70af9369bef8ad98be8ac549b09d4cc31a7751f59f66dd296a20fd0fa4ae07ec51aee16a7e125439572da86f49095224d7d27d5f3dab10a0fa43783ecd2e2.css integrity="sha512-b9cK+Tab74rZi+isVJsJ1Mwxp3UfWfZt0paiD9D6SuB+xRruFqfhJUOVctqG9JCVIk19J9Xz2rEKD6Q3g+zS4g==" crossorigin=anonymous><noscript><style>img.lazyload{display:none}</style></noscript><meta name=robots content="index, follow"><meta name=googlebot content="index, follow, max-snippet:-1, max-image-preview:large, max-video-preview:-1"><meta name=bingbot content="index, follow, max-snippet:-1, max-image-preview:large, max-video-preview:-1"><title>信息的表示和处理 | Inspire Hub</title><meta name=description content><link rel=canonical href=https://koktlzz.github.io/infra/csapp/%E4%BF%A1%E6%81%AF%E7%9A%84%E8%A1%A8%E7%A4%BA%E5%92%8C%E5%A4%84%E7%90%86/><meta property="og:locale" content="en_US"><meta property="og:type" content="article"><meta property="og:title" content="信息的表示和处理"><meta property="og:description" content="信息的存储 大多数机器使用字节（8 位的块）作为存储器中的最小寻址单元，而非访问单独的位。内存中的每一个字节都对应一个唯一的数字，即它的地址，所有可能的地址集合构成了 虚拟内存。它是由 DRAM、闪存（flash memory) 和磁盘存储共同实现的，而在程序看来则只是一个统一的字节数组。
编译器和运行时系统负责将这个内存空间划分为更加可管理的单元，来存储不同的程序对象。例如，C 中指针的值代表存储块中第一个字节的虚拟地址。C 编译器还将每个指针与其类型信息联系起来，这样就可以根据指针值的类型生成不同的机器级代码来访问指针所指向的值。不过机器级代码中并没有任何有关类型的信息，而是简单的把每个程序对象都视为一个字节块。
十六进制表示法 使用二进制表示位模式（bit pattern）会非常冗长，因为一个字节就包含了 8 位。而如果使用十进制，则不方便与位模式进行互相转化，因此我们采用十六进制（Hexadecimal）来书写位模式。一个十六进制数占 4 位，因此一个字节的取值范围就是 $00_{16}$ ~ $FF_{16}$ 。
将一个二进制数字转化为十六进制数字，需要首先将其分为多个 4 位的组，然后再将每组数转化为十六进制。如果总位数不为 4 的倍数，那么最左边的一组可以少于四位，然后在首位补 0。如 $111100_2$ 可以分成 $0011_2$ 和 $1100_2$，转化结果为 $3C_{16}$ 。在 C 中，若一个常数以 0x 或 0X 作为前缀，则代表它是一个十六进制数字。
数据大小 每台计算机都有一个字长（word size），它指定了指针数据的标准大小。如果一台机器的字长为 $\omega$ 位，那么虚拟地址的范围为 $ 0～2^\omega -1 $，程序最多访问 $2^\omega$ 字节。32 位机器的虚拟地址大小约为 4GB，而 64 位机器则能达到 16EB。
C 中几个基本数据类型的大小如下表所示：
   Signed Unsigned 32-bit 64-bit     [signed] char unsigned char 1 1   short unsigned short 2 2   int unsigned 4 4   long unsigned long 4 8   int32_t uint_32t 4 4   int64_t uint_64t 8 8   char *  4 8   float  4 4   double  8 8    除 char 外，若不添加前缀 unsigned，则默认使用有符号类型。指针类型的数据使用机器的全字长，如 char *。由于某些数据类型的大小在不同机器上有所不同，因此开发人员应使程序对不同数据类型的确切大小不敏感，从而保证程序的可移植性（portable）。"><meta property="og:url" content="https://koktlzz.github.io/infra/csapp/%E4%BF%A1%E6%81%AF%E7%9A%84%E8%A1%A8%E7%A4%BA%E5%92%8C%E5%A4%84%E7%90%86/"><meta property="og:site_name" content="Inspire Hub"><meta property="article:published_time" content="2021-02-24T22:05:45+08:00"><meta property="article:modified_time" content="2021-02-24T22:05:45+08:00"><meta property="og:image" content="https://koktlzz.github.io/doks.png"><meta property="og:image:alt" content="Inspire Hub"><meta name=twitter:card content="summary_large_image"><meta name=twitter:site content="@getdoks"><meta name=twitter:creator content="@henkverlinde"><meta name=twitter:title content="信息的表示和处理"><meta name=twitter:description content><meta name=twitter:image content="https://koktlzz.github.io/doks.png"><meta name=twitter:image:alt content="信息的表示和处理"><script type=application/ld+json>{"@context":"https://schema.org","@graph":[{"@type":"Organization","@id":"https://koktlzz.github.io/#/schema/organization/1","name":"Doks","url":"https://koktlzz.github.io/","sameAs":["https://twitter.com/getdoks","https://github.com/h-enk/doks"],"logo":{"@type":"ImageObject","@id":"https://koktlzz.github.io/#/schema/image/1","url":"https://koktlzz.github.io/logo-doks.png","width":512,"height":512,"caption":"Doks"},"image":{"@id":"https://koktlzz.github.io/#/schema/image/1"}},{"@type":"WebSite","@id":"https://koktlzz.github.io/#/schema/website/1","url":"https://koktlzz.github.io/","name":"Inspire Hub","description":"","publisher":{"@id":"https://koktlzz.github.io/#/schema/organization/1"}},{"@type":"WebPage","@id":"https://koktlzz.github.io/infra/csapp/%E4%BF%A1%E6%81%AF%E7%9A%84%E8%A1%A8%E7%A4%BA%E5%92%8C%E5%A4%84%E7%90%86/","url":"https://koktlzz.github.io/infra/csapp/%E4%BF%A1%E6%81%AF%E7%9A%84%E8%A1%A8%E7%A4%BA%E5%92%8C%E5%A4%84%E7%90%86/","name":"信息的表示和处理","description":"","isPartOf":{"@id":"https://koktlzz.github.io/#/schema/website/1"},"about":{"@id":"https://koktlzz.github.io/#/schema/organization/1"},"datePublished":"2021-02-24T22:05:45CET","dateModified":"2021-02-24T22:05:45CET","breadcrumb":{"@id":"https://koktlzz.github.io/infra/csapp/%E4%BF%A1%E6%81%AF%E7%9A%84%E8%A1%A8%E7%A4%BA%E5%92%8C%E5%A4%84%E7%90%86/#/schema/breadcrumb/1"},"primaryImageOfPage":{"@id":"https://koktlzz.github.io/infra/csapp/%E4%BF%A1%E6%81%AF%E7%9A%84%E8%A1%A8%E7%A4%BA%E5%92%8C%E5%A4%84%E7%90%86/#/schema/image/2"},"inLanguage":"en-US","potentialAction":[{"@type":"ReadAction","target":["https://koktlzz.github.io/infra/csapp/%E4%BF%A1%E6%81%AF%E7%9A%84%E8%A1%A8%E7%A4%BA%E5%92%8C%E5%A4%84%E7%90%86/"]}]},{"@type":"BreadcrumbList","@id":"https://koktlzz.github.io/infra/csapp/%E4%BF%A1%E6%81%AF%E7%9A%84%E8%A1%A8%E7%A4%BA%E5%92%8C%E5%A4%84%E7%90%86/#/schema/breadcrumb/1","name":"Breadcrumbs","itemListElement":[{"@type":"ListItem","position":1,"item":{"@type":"WebPage","@id":"https://koktlzz.github.io/","url":"https://koktlzz.github.io/","name":"Home"}},{"@type":"ListItem","position":2,"item":{"@type":"WebPage","@id":"https://koktlzz.github.io/infra/","url":"https://koktlzz.github.io/infra/","name":"Infra"}},{"@type":"ListItem","position":3,"item":{"@type":"WebPage","@id":"https://koktlzz.github.io/infra/csapp/","url":"https://koktlzz.github.io/infra/csapp/","name":"Csapp"}},{"@type":"ListItem","position":4,"item":{"@id":"https://koktlzz.github.io/infra/csapp/%E4%BF%A1%E6%81%AF%E7%9A%84%E8%A1%A8%E7%A4%BA%E5%92%8C%E5%A4%84%E7%90%86/"}}]},{"@context":"https://schema.org","@graph":[{"@type":"ImageObject","@id":"https://koktlzz.github.io/infra/csapp/%E4%BF%A1%E6%81%AF%E7%9A%84%E8%A1%A8%E7%A4%BA%E5%92%8C%E5%A4%84%E7%90%86/#/schema/image/2","url":"https://koktlzz.github.io/doks.png","contentUrl":"https://koktlzz.github.io/doks.png","caption":"信息的表示和处理"}]}]}</script><meta name=theme-color content="#fff"><link rel=apple-touch-icon sizes=180x180 href=https://koktlzz.github.io/apple-touch-icon.png><link rel=icon type=image/png sizes=32x32 href=https://koktlzz.github.io/favicon-32x32.ico><link rel=icon type=image/png sizes=16x16 href=https://koktlzz.github.io/favicon-16x16.ico><link rel=manifest crossorigin=use-credentials href=https://koktlzz.github.io/site.webmanifest></head><body class="Infra single dark"><noscript><iframe src="https://www.googletagmanager.com/ns.html?id=GTM-P72R45W" height=0 width=0 style=display:none;visibility:hidden></iframe></noscript><div class="header-bar fixed-top"></div><header class="navbar fixed-top navbar-expand-md navbar-light"><div class=container-fluid><input class="menu-btn order-0" type=checkbox id=menu-btn>
<label class="menu-icon d-md-none" for=menu-btn><span class=navicon></span></label><a class="navbar-brand order-1 order-md-0 me-auto" href=https://koktlzz.github.io/>Inspire Hub</a>
<button id=mode class="btn btn-link order-2 order-md-4" type=button aria-label="Toggle mode">
<span class=toggle-dark><svg xmlns="http://www.w3.org/2000/svg" width="20" height="20" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="feather feather-moon"><path d="M21 12.79A9 9 0 1111.21 3 7 7 0 0021 12.79z"/></svg></span><span class=toggle-light><svg xmlns="http://www.w3.org/2000/svg" width="20" height="20" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="feather feather-sun"><circle cx="12" cy="12" r="5"/><line x1="12" y1="1" x2="12" y2="3"/><line x1="12" y1="21" x2="12" y2="23"/><line x1="4.22" y1="4.22" x2="5.64" y2="5.64"/><line x1="18.36" y1="18.36" x2="19.78" y2="19.78"/><line x1="1" y1="12" x2="3" y2="12"/><line x1="21" y1="12" x2="23" y2="12"/><line x1="4.22" y1="19.78" x2="5.64" y2="18.36"/><line x1="18.36" y1="5.64" x2="19.78" y2="4.22"/></svg></span></button><ul class="navbar-nav social-nav order-3 order-md-5"><li class=nav-item><a class=nav-link href=https://github.com/koktlzz><svg xmlns="http://www.w3.org/2000/svg" width="20" height="20" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="feather feather-github"><path d="M9 19c-5 1.5-5-2.5-7-3m14 6v-3.87a3.37 3.37.0 00-.94-2.61c3.14-.35 6.44-1.54 6.44-7A5.44 5.44.0 0020 4.77 5.07 5.07.0 0019.91 1S18.73.65 16 2.48a13.38 13.38.0 00-7 0C6.27.65 5.09 1 5.09 1A5.07 5.07.0 005 4.77 5.44 5.44.0 003.5 8.55c0 5.42 3.3 6.61 6.44 7A3.37 3.37.0 009 18.13V22"/></svg><span class="ms-2 visually-hidden">GitHub</span></a></li></ul><div class="collapse navbar-collapse order-4 order-md-1"><ul class="navbar-nav main-nav me-auto order-5 order-md-2"><li class=nav-item><a class=nav-link href=https://koktlzz.github.io/docker/docker%E5%9F%BA%E7%A1%80/intro>Docker</a></li><li class=nav-item><a class=nav-link href=https://koktlzz.github.io/kubernetes/kubernetes%E5%9F%BA%E7%A1%80/intro>Kubernetes</a></li><li class=nav-item><a class=nav-link href=https://koktlzz.github.io/elastic/elasticstack/intro>Elastic</a></li><li class=nav-item><a class=nav-link href=https://koktlzz.github.io/go/go%E5%9F%BA%E7%A1%80/intro>Go</a></li><li class=nav-item><a class=nav-link href=https://koktlzz.github.io/infra/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E5%9F%BA%E7%A1%80/tcpip%E7%BD%91%E7%BB%9C%E6%A8%A1%E5%9E%8B>Infra</a></li></ul><div class="break order-6 d-md-none"></div></div></div></header><div class="wrap container-fluid" role=document><div class=content><div class="row flex-xl-nowrap"><div class="col-lg-3 col-xl-2 d-none d-xl-block"><nav class=docs-links aria-label="Main navigation"><h3>计算机网络</h3><ul class=list-unstyled><li><a class=docs-link href=https://koktlzz.github.io/infra/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E5%9F%BA%E7%A1%80/tcpip%E7%BD%91%E7%BB%9C%E6%A8%A1%E5%9E%8B/>TCP/IP 网络模型</a></li><li><a class=docs-link href=https://koktlzz.github.io/infra/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E5%9F%BA%E7%A1%80/dnshttps/>DNS、UDP 与 HTTPS</a></li><li><a class=docs-link href=https://koktlzz.github.io/infra/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E5%9F%BA%E7%A1%80/%E8%99%9A%E6%8B%9F%E6%9C%BA%E7%BD%91%E7%BB%9C/>虚拟机网络</a></li><li><a class=docs-link href=https://koktlzz.github.io/infra/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E5%9F%BA%E7%A1%80/vlan/>VLAN</a></li></ul><h3>CSAPP</h3><ul class=list-unstyled><li><a class=docs-link href=https://koktlzz.github.io/infra/csapp/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9F%E4%B9%8B%E6%97%85/>计算机系统之旅</a></li><li><a class=docs-link href=https://koktlzz.github.io/infra/csapp/%E4%BF%A1%E6%81%AF%E7%9A%84%E8%A1%A8%E7%A4%BA%E5%92%8C%E5%A4%84%E7%90%86/>信息的表示和处理</a></li></ul><h3>Linux</h3><ul class=list-unstyled><li><a class=docs-link href=https://koktlzz.github.io/infra/linux/filepermission/>文件权限</a></li></ul></nav></div><main class="docs-content col-lg-13 col-xl-11"><h1>信息的表示和处理</h1><p class=lead></p><h2 id=信息的存储>信息的存储<a href=#信息的存储 class=anchor aria-hidden=true>#</a></h2><p>大多数机器使用字节（8 位的块）作为存储器中的最小寻址单元，而非访问单独的位。内存中的每一个字节都对应一个唯一的数字，即它的地址，所有可能的地址集合构成了 <a href=https://koktlzz.github.io/infra/csapp/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9F%E4%B9%8B%E6%97%85/#%E8%99%9A%E6%8B%9F%E5%86%85%E5%AD%98>虚拟内存</a>。它是由 DRAM、闪存（flash memory) 和磁盘存储共同实现的，而在程序看来则只是一个统一的字节数组。</p><p>编译器和运行时系统负责将这个内存空间划分为更加可管理的单元，来存储不同的程序对象。例如，C 中指针的值代表存储块中第一个字节的虚拟地址。C 编译器还将每个指针与其类型信息联系起来，这样就可以根据指针值的类型生成不同的机器级代码来访问指针所指向的值。不过机器级代码中并没有任何有关类型的信息，而是简单的把每个程序对象都视为一个字节块。</p><h3 id=十六进制表示法>十六进制表示法<a href=#十六进制表示法 class=anchor aria-hidden=true>#</a></h3><p>使用二进制表示位模式（bit pattern）会非常冗长，因为一个字节就包含了 8 位。而如果使用十进制，则不方便与位模式进行互相转化，因此我们采用十六进制（Hexadecimal）来书写位模式。一个十六进制数占 4 位，因此一个字节的取值范围就是 $00_{16}$ ~ $FF_{16}$ 。</p><p>将一个二进制数字转化为十六进制数字，需要首先将其分为多个 4 位的组，然后再将每组数转化为十六进制。如果总位数不为 4 的倍数，那么最左边的一组可以少于四位，然后在首位补 0。如 $111100_2$ 可以分成 $0011_2$ 和 $1100_2$，转化结果为 $3C_{16}$ 。在 C 中，若一个常数以 0x 或 0X 作为前缀，则代表它是一个十六进制数字。</p><h3 id=数据大小>数据大小<a href=#数据大小 class=anchor aria-hidden=true>#</a></h3><p>每台计算机都有一个字长（word size），它指定了指针数据的标准大小。如果一台机器的字长为 $\omega$ 位，那么虚拟地址的范围为 $ 0～2^\omega -1 $，程序最多访问 $2^\omega$ 字节。32 位机器的虚拟地址大小约为 4GB，而 64 位机器则能达到 16EB。</p><p>C 中几个基本数据类型的大小如下表所示：</p><table><thead><tr><th>Signed</th><th>Unsigned</th><th>32-bit</th><th>64-bit</th></tr></thead><tbody><tr><td>[signed] char</td><td>unsigned char</td><td>1</td><td>1</td></tr><tr><td>short</td><td>unsigned short</td><td>2</td><td>2</td></tr><tr><td>int</td><td>unsigned</td><td>4</td><td>4</td></tr><tr><td>long</td><td>unsigned long</td><td>4</td><td>8</td></tr><tr><td>int32_t</td><td>uint_32t</td><td>4</td><td>4</td></tr><tr><td>int64_t</td><td>uint_64t</td><td>8</td><td>8</td></tr><tr><td>char *</td><td></td><td>4</td><td>8</td></tr><tr><td>float</td><td></td><td>4</td><td>4</td></tr><tr><td>double</td><td></td><td>8</td><td>8</td></tr></tbody></table><p>除 char 外，若不添加前缀 unsigned，则默认使用有符号类型。指针类型的数据使用机器的全字长，如 char *。由于某些数据类型的大小在不同机器上有所不同，因此开发人员应使程序对不同数据类型的确切大小不敏感，从而保证程序的可移植性（portable）。</p><h3 id=寻址和字节顺序>寻址和字节顺序<a href=#寻址和字节顺序 class=anchor aria-hidden=true>#</a></h3><p>对于多字节的程序对象，我们必须建立两个准则：这个对象的地址是什么和这些字节在内存中的排列顺序是怎样的。某些机器选择按照从最低有效字节到最高有效字节的顺序存储对象，称为小端法（little endian）；而某些则与之相反，称为大端法（big endian）。如一个 int 类型的变量 x 地址为 0x100，其值为十六进制的 0x1234567，那么上述两种机器存储该变量的方式分别如下：</p><p>little endian</p><table><thead><tr><th style=text-align:center></th><th style=text-align:center>0x100</th><th style=text-align:center>0x101</th><th style=text-align:center>0x102</th><th style=text-align:center>0x103</th><th style=text-align:center></th></tr></thead><tbody><tr><td style=text-align:center>&mldr;</td><td style=text-align:center>67</td><td style=text-align:center>45</td><td style=text-align:center>23</td><td style=text-align:center>01</td><td style=text-align:center>&mldr;</td></tr></tbody></table><p>big endian</p><table><thead><tr><th style=text-align:center></th><th style=text-align:center>0x100</th><th style=text-align:center>0x101</th><th style=text-align:center>0x102</th><th style=text-align:center>0x103</th><th style=text-align:center></th></tr></thead><tbody><tr><td style=text-align:center>&mldr;</td><td style=text-align:center>01</td><td style=text-align:center>23</td><td style=text-align:center>45</td><td style=text-align:center>67</td><td style=text-align:center>&mldr;</td></tr></tbody></table><p>有些时候不同的存储顺序可能导致一些问题：</p><ul><li>不同类型的机器通过网络传递二进制数据，如小端法机器产生的数据发送到大端机器上，得到的字节序列是反的。这就要求发送方的机器需要将代码转换为网络标准，接收方再将其转化为其内部的表达方式；</li><li>对于小端法机器，书写字节序列与书写数字的顺序相反；</li><li>某些使用强制类型转换（cast）的程序，在不同类型的机器上编译运行的结果不同。</li></ul><p>对于上述第三种情况，我们以一个程序为例：</p><div class=highlight><pre style=color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-c data-lang=c><span style=color:#ff79c6>#include</span> <span style=color:#ff79c6>&lt;stdio.h&gt;</span><span style=color:#ff79c6>
</span><span style=color:#ff79c6></span>
<span style=color:#ff79c6>typedef</span> <span style=color:#8be9fd>unsigned</span> <span style=color:#8be9fd>char</span> <span style=color:#ff79c6>*</span>byte_pointer;

<span style=color:#8be9fd>void</span> <span style=color:#50fa7b>show_bytes</span>(byte_pointer start, size_t len)
{
    size_t i;
    <span style=color:#ff79c6>for</span> (i <span style=color:#ff79c6>=</span> <span style=color:#bd93f9>0</span>; i <span style=color:#ff79c6>&lt;</span> len; i<span style=color:#ff79c6>++</span>)
    {
        <span style=color:#6272a4>// %.2x 代表整数会被打印为至少两位（digits）的十六进制数字
</span><span style=color:#6272a4></span>        printf(<span style=color:#f1fa8c>&#34;%.2x&#34;</span>, start[i]);
    }
    printf(<span style=color:#f1fa8c>&#34;</span><span style=color:#f1fa8c>\n</span><span style=color:#f1fa8c>&#34;</span>);
}

<span style=color:#8be9fd>void</span> <span style=color:#50fa7b>show_int</span>(<span style=color:#8be9fd>int</span> x)
{
    show_bytes((byte_pointer)<span style=color:#ff79c6>&amp;</span>x, <span style=color:#ff79c6>sizeof</span>(<span style=color:#8be9fd>int</span>));
}

<span style=color:#8be9fd>void</span> <span style=color:#50fa7b>show_float</span>(<span style=color:#8be9fd>float</span> x)
{
    show_bytes((byte_pointer)<span style=color:#ff79c6>&amp;</span>x, <span style=color:#ff79c6>sizeof</span>(<span style=color:#8be9fd>float</span>));
}

<span style=color:#8be9fd>void</span> <span style=color:#50fa7b>show_pointer</span>(<span style=color:#8be9fd>void</span> <span style=color:#ff79c6>*</span>x)
{
    show_bytes((byte_pointer)<span style=color:#ff79c6>&amp;</span>x, <span style=color:#ff79c6>sizeof</span>(<span style=color:#8be9fd>void</span> <span style=color:#ff79c6>*</span>));
}

<span style=color:#8be9fd>int</span> <span style=color:#50fa7b>main</span>()
{
    <span style=color:#8be9fd>int</span> val <span style=color:#ff79c6>=</span> <span style=color:#bd93f9>12345</span>;
    <span style=color:#8be9fd>float</span> fval <span style=color:#ff79c6>=</span> (<span style=color:#8be9fd>float</span>) val;
    <span style=color:#8be9fd>int</span> <span style=color:#ff79c6>*</span>pval <span style=color:#ff79c6>=</span> <span style=color:#ff79c6>&amp;</span>val;
    show_int(val);
    show_float(fval);
    show_pointer(pval);
}
</code></pre></div><p>不同类型机器的输出结果如下：</p><table><thead><tr><th>Machine</th><th>val</th><th>fval</th><th>pval</th></tr></thead><tbody><tr><td>Linux32</td><td>0x39300000</td><td>0x00e44046</td><td>0xe4f9ffbf</td></tr><tr><td>Windows32</td><td>0x39300000</td><td>0x00e44046</td><td>0xb4cc2200</td></tr><tr><td>Sun</td><td>0x00003039</td><td>0x4640e400</td><td>0xeffffa0c</td></tr><tr><td>Linux64</td><td>0x39300000</td><td>0x00e44046</td><td>0xb811e5ffff7f0000</td></tr></tbody></table><p>这是因为 Sun 系统采用大端法，其他三者采用小端法。对于指针类型的变量，不同操作系统在存储分配上有着不同的准则。同时，64 位系统使用 8 字节地址，32 位系统使用 4 字节地址，这导致了指针类型的变量 pval 输出结果的不同。</p><h3 id=字符串>字符串<a href=#字符串 class=anchor aria-hidden=true>#</a></h3><p>字符串在 C 中被编码为一个以 null 字符结尾（其值为 0）的字符数组，每个字符都由某种标准编码组成，如 ASCII 码。因此，如果我们执行上面的程序<code>show_bytes("12345", 6)</code>，将得到 31 32 33 34 35 00。</p><p>由于字符串中各字符的排列顺序是由字符串本身决定的，因此字符串不会受到大端法/小端法的影响，除非字符使用 16 位两字节的 Unicode 进行编码。</p><h3 id=代码>代码<a href=#代码 class=anchor aria-hidden=true>#</a></h3><p>不同类型的机器使用不同且不兼容的指令和编码方式，因此二进制代码很少能在不同机器和操作系统组合之间移植。</p><h3 id=布尔代数简介>布尔代数简介<a href=#布尔代数简介 class=anchor aria-hidden=true>#</a></h3><p>几种布尔运算符的定义如下：</p><ul><li>～：非，相当于逻辑运算的 NOT；</li><li>&：与，相当于逻辑运算的 AND；</li><li>｜：或，相当于逻辑运算的 OR；</li><li>^：异或，相当于逻辑运算的 EXCLUSIVE-OR。若 $p = 0$，$q = 1$ 或 $p = 1$，$q = 0$ 时，$p \text{\textasciicircum} q = 1$。</li></ul><p>布尔运算符可以应用于位向量，即固定长度的 0、1 序列。举例来说，若 a 为 [0110]，b 为 [0101]，那么：</p><table><thead><tr><th>Operation</th><th>Result</th></tr></thead><tbody><tr><td>~a</td><td>[1001]</td></tr><tr><td>a & b</td><td>[0100]</td></tr><tr><td>a | b</td><td>[0111]</td></tr><tr><td>a ^ b</td><td>[0011]</td></tr></tbody></table><h3 id=c-中的位级运算>C 中的位级运算<a href=#c-中的位级运算 class=anchor aria-hidden=true>#</a></h3><p>C 中支持按位布尔运算，上面提到的布尔运算符其实就是在 C 中使用的。一个使用布尔运算符的经典程序如下：</p><div class=highlight><pre style=color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-c data-lang=c><span style=color:#ff79c6>#include</span> <span style=color:#ff79c6>&lt;stdio.h&gt;</span><span style=color:#ff79c6>
</span><span style=color:#ff79c6></span>
<span style=color:#8be9fd>void</span> <span style=color:#50fa7b>inplace_swap</span>(<span style=color:#8be9fd>int</span> <span style=color:#ff79c6>*</span>x, <span style=color:#8be9fd>int</span> <span style=color:#ff79c6>*</span>y)
{
    <span style=color:#ff79c6>*</span>y <span style=color:#ff79c6>=</span> <span style=color:#ff79c6>*</span>x <span style=color:#ff79c6>^</span> <span style=color:#ff79c6>*</span>y;
    <span style=color:#ff79c6>*</span>x <span style=color:#ff79c6>=</span> <span style=color:#ff79c6>*</span>x <span style=color:#ff79c6>^</span> <span style=color:#ff79c6>*</span>y;
    <span style=color:#ff79c6>*</span>y <span style=color:#ff79c6>=</span> <span style=color:#ff79c6>*</span>x <span style=color:#ff79c6>^</span> <span style=color:#ff79c6>*</span>y;
}
</code></pre></div><p>利用对于任意数 $a$ ，$a \text{\textasciicircum} a$ = 0 以及 $0 \text{\textasciicircum} a = a$ 这一性质，该程序不使用中间变量便完成了变量值的交换。另外，上述方法的实现还建立在异或运算满足交换律和结合律的基础之上。</p><h3 id=c-中的逻辑运算>C 中的逻辑运算<a href=#c-中的逻辑运算 class=anchor aria-hidden=true>#</a></h3><p>C 还提供了逻辑运算符，即 || 、&& 和 !。它们和位级运算的一个区别就是，如果对第一个参数求值就能确定表达式的结果，那么就不会对第二个参数进行求值。如表达式 a && 5 / a 不会导致除数为 0 的异常，而 p && *p++ 也不会导致简介引用空指针。</p><h3 id=c-中的移位运算>C 中的移位运算<a href=#c-中的移位运算 class=anchor aria-hidden=true>#</a></h3><p>C 中的移位运算有左移和右移两种，均不会改变位向量的长度。左移运算 $x &#171; k$ 就是 x 向左移动 k 位，丢弃 k 个高位，并在右端补充 k 个 0。通常可以使用 $x &#171; 1$ 和 $x &#171; 2$ 分别代替 $x * 2$ 和 $x * 4$，因为位级运算拥有相比乘法更快的运算速度。</p><p>右移运算分为两种形式，逻辑和算术。无符号数据必须使用逻辑右移，$x &#187; k$ 将 x 的左端补充 k 个 0 ，并丢弃 k 个低位。而大多数机器使用算术右移处理有符号数据，$x &#187; k$ 将 x 的左端补充 k 个最高有效位的拷贝，并丢弃 k 个低位。</p><p>加减乘除运算符的优先级大于移位运算符，因此 $1 &#171; 2 + 3 &#171; 4$ 等效于 $1 &#171; (2 + 3) &#171; 4$。</p><h2 id=整数的表示>整数的表示<a href=#整数的表示 class=anchor aria-hidden=true>#</a></h2><h3 id=无符号编码>无符号编码<a href=#无符号编码 class=anchor aria-hidden=true>#</a></h3><p>一个长度为 $\omega$ 的位向量 $\vec{x} = [x_{\omega-1},x_{\omega-2},&mldr;,x_0]$，它从二进制（Binary）转化为无符号编码（Unsigned）的公式为：</p><p>$$ B2U_\omega(\vec{x}) \doteq \displaystyle\sum_{i=0}^{w - 1}x_i2^i $$</p><p>其中， $\doteq$ 符号表示等式的左手边被定义为右手边。</p><h3 id=二进制补码>二进制补码<a href=#二进制补码 class=anchor aria-hidden=true>#</a></h3><p>二进制补码（Two&rsquo;s-Complement Encoding）将位向量的最高位作为负权重（negative weight）。如一个长度为 $\omega$ 的位向量 $\vec{x} = [x_{\omega-1},x_{\omega-2},&mldr;,x_0]$，它从二进制转化为二进制补码的公式为：</p><p>$$ B2T_\omega(\vec{x}) \doteq -x_{w - 1}2^{w - 1} + \displaystyle\sum_{i=0}^{w - 2}x_i2^i $$</p><h3 id=有符号数和无符号数的转换>有符号数和无符号数的转换<a href=#有符号数和无符号数的转换 class=anchor aria-hidden=true>#</a></h3><h3 id=c-中的有符号数和无符号数>C 中的有符号数和无符号数<a href=#c-中的有符号数和无符号数 class=anchor aria-hidden=true>#</a></h3><h3 id=扩展一个数的位级表示>扩展一个数的位级表示<a href=#扩展一个数的位级表示 class=anchor aria-hidden=true>#</a></h3><h3 id=截断数字>截断数字<a href=#截断数字 class=anchor aria-hidden=true>#</a></h3><h2 id=整数的运算>整数的运算<a href=#整数的运算 class=anchor aria-hidden=true>#</a></h2><h2 id=浮点>浮点<a href=#浮点 class=anchor aria-hidden=true>#</a></h2><h2 id=小结>小结<a href=#小结 class=anchor aria-hidden=true>#</a></h2><p class=edit-page><a href=https://github.com/koktlzz/koktlzz.github.io/blob/master/content/Infra/CSAPP/%e4%bf%a1%e6%81%af%e7%9a%84%e8%a1%a8%e7%a4%ba%e5%92%8c%e5%a4%84%e7%90%86.md><svg xmlns="http://www.w3.org/2000/svg" width="16" height="16" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="feather feather-edit-2"><path d="M17 3a2.828 2.828.0 114 4L7.5 20.5 2 22l1.5-5.5L17 3z"/></svg>Edit this page on GitHub</a></p><div class="docs-navigation d-flex justify-content-between"><a href=https://koktlzz.github.io/infra/csapp/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9F%E4%B9%8B%E6%97%85/><div class="card my-1"><div class="card-body py-2">&larr; 计算机系统之旅</div></div></a><a class=ms-auto href=https://koktlzz.github.io/infra/linux/filepermission/><div class="card my-1"><div class="card-body py-2">文件权限 &rarr;</div></div></a></div><script src=https://utteranc.es/client.js repo=koktlzz/koktlzz.github.io issue-term=pathname theme=photon-dark crossorigin=anonymous async></script></main><nav class="docs-toc d-none d-xl-block col-lg-3 col-xl-2" aria-label="Secondary navigation"><div class=page-links><h3>On this page</h3><nav id=TableOfContents><ul><li><a href=#信息的存储>信息的存储</a><ul><li><a href=#十六进制表示法>十六进制表示法</a></li><li><a href=#数据大小>数据大小</a></li><li><a href=#寻址和字节顺序>寻址和字节顺序</a></li><li><a href=#字符串>字符串</a></li><li><a href=#代码>代码</a></li><li><a href=#布尔代数简介>布尔代数简介</a></li><li><a href=#c-中的位级运算>C 中的位级运算</a></li><li><a href=#c-中的逻辑运算>C 中的逻辑运算</a></li><li><a href=#c-中的移位运算>C 中的移位运算</a></li></ul></li><li><a href=#整数的表示>整数的表示</a><ul><li><a href=#无符号编码>无符号编码</a></li><li><a href=#二进制补码>二进制补码</a></li><li><a href=#有符号数和无符号数的转换>有符号数和无符号数的转换</a></li><li><a href=#c-中的有符号数和无符号数>C 中的有符号数和无符号数</a></li><li><a href=#扩展一个数的位级表示>扩展一个数的位级表示</a></li><li><a href=#截断数字>截断数字</a></li></ul></li><li><a href=#整数的运算>整数的运算</a></li><li><a href=#浮点>浮点</a></li><li><a href=#小结>小结</a></li></ul></nav></div></nav></div></div></div><footer class="footer text-muted"><div class=container><div class=row><div class="col-lg-8 order-last order-lg-first"><ul class=list-inline><li class=list-inline-item></li></ul></div><div class="col-lg-8 order-first order-lg-last text-lg-end"><ul class=list-inline></ul></div></div></div></footer><script src=https://koktlzz.github.io/js/bootstrap.min.d67050adf5d370668aede4201f82af781b16970934804995a1ca37c1ee9222c2fc530972aa6d5d2b6124caf1fe318f139aac99df2c1e89af65504fc1185c7972.js integrity="sha512-1nBQrfXTcGaK7eQgH4KveBsWlwk0gEmVoco3we6SIsL8Uwlyqm1dK2EkyvH+MY8TmqyZ3yweia9lUE/BGFx5cg==" crossorigin=anonymous defer></script><script src=https://koktlzz.github.io/js/vendor/katex/dist/katex.min.b334e5b00c45f572e7f38a543046f36854bf4cbb543880480c09271a0efedc694d6905f719934f6ede2f26f52e80411c05b90121d722cbf8be2fa8fc51bc6b81.js integrity="sha512-szTlsAxF9XLn84pUMEbzaFS/TLtUOIBIDAknGg7+3GlNaQX3GZNPbt4vJvUugEEcBbkBIdciy/i+L6j8UbxrgQ==" crossorigin=anonymous defer></script><script src=https://koktlzz.github.io/js/vendor/katex/dist/contrib/auto-render.min.916823ec103cf367b71e28a6f01513cb9c3ac6708ccb5229402ec46b8e30a8b25003db694df35d80e9dd666a371f327c6152790617b6256390c164109a90bd4c.js integrity="sha512-kWgj7BA882e3Hiim8BUTy5w6xnCMy1IpQC7Ea44wqLJQA9tpTfNdgOndZmo3HzJ8YVJ5Bhe2JWOQwWQQmpC9TA==" crossorigin=anonymous defer></script><script src=https://koktlzz.github.io/main.min.1febbf2f6fd6a36fc2f57dd50d7935fbb640743329baeb4ef7cefcf2e7630e413371fbba976e103656b82808ee227dc4a84237edb0f8433648bef3a56900661a.js integrity="sha512-H+u/L2/Wo2/C9X3VDXk1+7ZAdDMpuutO98788udjDkEzcfu6l24QNla4KAjuIn3EqEI37bD4QzZIvvOlaQBmGg==" crossorigin=anonymous defer></script></body></html>