<!doctype html><html lang=en-us><head><script async src="https://www.googletagmanager.com/gtag/js?id=G-D022F6NT2P"></script><script>window.dataLayer=window.dataLayer||[];function gtag(){dataLayer.push(arguments)}gtag('js',new Date),gtag('config','G-D022F6NT2P')</script><script>(function(b,d,e,a,g){b[a]=b[a]||[],b[a].push({'gtm.start':(new Date).getTime(),event:'gtm.js'});var f=d.getElementsByTagName(e)[0],c=d.createElement(e),h=a!='dataLayer'?'&l='+a:'';c.async=!0,c.src='https://www.googletagmanager.com/gtm.js?id='+g+h,f.parentNode.insertBefore(c,f)})(window,document,'script','dataLayer','GTM-P72R45W')</script><meta charset=utf-8><meta http-equiv=x-ua-compatible content="ie=edge"><meta name=viewport content="width=device-width,initial-scale=1,shrink-to-fit=no"><link rel=preload as=font href=https://koktlzz.github.io/fonts/vendor/jost/jost-v4-latin-regular.woff2 type=font/woff2 crossorigin><link rel=preload as=font href=https://koktlzz.github.io/fonts/vendor/jost/jost-v4-latin-700.woff2 type=font/woff2 crossorigin><link rel=preload as=font href=https://koktlzz.github.io/fonts/KaTeX_Main-Regular.woff2 type=font/woff2 crossorigin><link rel=preload as=font href=https://koktlzz.github.io/fonts/KaTeX_Math-Italic.woff2 type=font/woff2 crossorigin><link rel=stylesheet href=https://koktlzz.github.io/main.c0a326aac8520a62438538689a1c0d4f407d29cb8008a79181cc47b1abf30dabb964d49559fe59ca12ab3bd551bf41abb29c58bbcdbf661bcf690afb189fd2e6.css integrity="sha512-wKMmqshSCmJDhThomhwNT0B9KcuACKeRgcxHsavzDau5ZNSVWf5ZyhKrO9VRv0GrspxYu82/ZhvPaQr7GJ/S5g==" crossorigin=anonymous><noscript><style>img.lazyload{display:none}</style></noscript><meta name=robots content="index, follow"><meta name=googlebot content="index, follow, max-snippet:-1, max-image-preview:large, max-video-preview:-1"><meta name=bingbot content="index, follow, max-snippet:-1, max-image-preview:large, max-video-preview:-1"><title>性能调优 | Inspire Hub</title><meta name=description content><link rel=canonical href=https://koktlzz.github.io/elastic/elasticsearch/%E6%80%A7%E8%83%BD%E8%B0%83%E4%BC%98/><meta property="og:locale" content="en_US"><meta property="og:type" content="article"><meta property="og:title" content="性能调优"><meta property="og:description" content="吞吐量（throughput）和延迟（latency）是评估 Elasticsearch 集群性能的指标，前者代表每秒写入（index）或查询（search）文档的数量，后者则代表单个请求的延迟。上述指标之间也有一定联系：延迟越低，吞吐量就越高。
JVM 内存压力 Elasticsearch 集群的吞吐量显然与节点的负载相关，尤其是大量的请求将引起节点的 JVM 内存压力升高。Elasticsearch 使用断路器（Circuit Breaker）来防止节点出现 JVM 堆内存溢出。如果 Elasticsearch 评估一项操作将触发断路器，那么便会返回一个 HTTP 错误码 429：
{ 'error': { 'type': 'circuit_breaking_exception', 'reason': '[parent] Data too large, data for [<http_request>] would be [123848638/118.1mb], which is larger than the limit of [123273216/117.5mb], real usage: [120182112/114.6mb], new bytes reserved: [3666526/3.4mb]', 'bytes_wanted': 123848638, 'bytes_limit': 123273216, 'durability': 'TRANSIENT' }, 'status': 429 } 由于断路器有多个，首先应先查看其具体的触发情况：
GET _nodes/stats/breaker // 返回 &#34;breakers&#34; : { &#34;request&#34; : { &#34;limit_size_in_bytes&#34; : 1278030643, &#34;limit_size&#34; : &#34;1."><meta property="og:url" content="https://koktlzz.github.io/elastic/elasticsearch/%E6%80%A7%E8%83%BD%E8%B0%83%E4%BC%98/"><meta property="og:site_name" content="Inspire Hub"><meta property="article:published_time" content="2020-11-04T09:19:42+01:00"><meta property="article:modified_time" content="2020-11-04T09:19:42+01:00"><meta property="og:image" content="https://koktlzz.github.io/doks.png"><meta property="og:image:alt" content="Inspire Hub"><meta name=twitter:card content="summary_large_image"><meta name=twitter:site content="@getdoks"><meta name=twitter:creator content="@henkverlinde"><meta name=twitter:title content="性能调优"><meta name=twitter:description content><meta name=twitter:image content="https://koktlzz.github.io/doks.png"><meta name=twitter:image:alt content="性能调优"><script type=application/ld+json>{"@context":"https://schema.org","@graph":[{"@type":"Organization","@id":"https://koktlzz.github.io/#/schema/organization/1","name":"Doks","url":"https://koktlzz.github.io/","sameAs":["https://twitter.com/getdoks","https://github.com/h-enk/doks"],"logo":{"@type":"ImageObject","@id":"https://koktlzz.github.io/#/schema/image/1","url":"https://koktlzz.github.io/logo-doks.png","width":512,"height":512,"caption":"Doks"},"image":{"@id":"https://koktlzz.github.io/#/schema/image/1"}},{"@type":"WebSite","@id":"https://koktlzz.github.io/#/schema/website/1","url":"https://koktlzz.github.io/","name":"Inspire Hub","description":"","publisher":{"@id":"https://koktlzz.github.io/#/schema/organization/1"}},{"@type":"WebPage","@id":"https://koktlzz.github.io/elastic/elasticsearch/%E6%80%A7%E8%83%BD%E8%B0%83%E4%BC%98/","url":"https://koktlzz.github.io/elastic/elasticsearch/%E6%80%A7%E8%83%BD%E8%B0%83%E4%BC%98/","name":"性能调优","description":"","isPartOf":{"@id":"https://koktlzz.github.io/#/schema/website/1"},"about":{"@id":"https://koktlzz.github.io/#/schema/organization/1"},"datePublished":"2020-11-04T09:19:42CET","dateModified":"2020-11-04T09:19:42CET","breadcrumb":{"@id":"https://koktlzz.github.io/elastic/elasticsearch/%E6%80%A7%E8%83%BD%E8%B0%83%E4%BC%98/#/schema/breadcrumb/1"},"primaryImageOfPage":{"@id":"https://koktlzz.github.io/elastic/elasticsearch/%E6%80%A7%E8%83%BD%E8%B0%83%E4%BC%98/#/schema/image/2"},"inLanguage":"en-US","potentialAction":[{"@type":"ReadAction","target":["https://koktlzz.github.io/elastic/elasticsearch/%E6%80%A7%E8%83%BD%E8%B0%83%E4%BC%98/"]}]},{"@type":"BreadcrumbList","@id":"https://koktlzz.github.io/elastic/elasticsearch/%E6%80%A7%E8%83%BD%E8%B0%83%E4%BC%98/#/schema/breadcrumb/1","name":"Breadcrumbs","itemListElement":[{"@type":"ListItem","position":1,"item":{"@type":"WebPage","@id":"https://koktlzz.github.io/","url":"https://koktlzz.github.io/","name":"Home"}},{"@type":"ListItem","position":2,"item":{"@type":"WebPage","@id":"https://koktlzz.github.io/elastic/","url":"https://koktlzz.github.io/elastic/","name":"Elastic"}},{"@type":"ListItem","position":3,"item":{"@type":"WebPage","@id":"https://koktlzz.github.io/elastic/elasticsearch/","url":"https://koktlzz.github.io/elastic/elasticsearch/","name":"Elasticsearch"}},{"@type":"ListItem","position":4,"item":{"@id":"https://koktlzz.github.io/elastic/elasticsearch/%E6%80%A7%E8%83%BD%E8%B0%83%E4%BC%98/"}}]},{"@context":"https://schema.org","@graph":[{"@type":"ImageObject","@id":"https://koktlzz.github.io/elastic/elasticsearch/%E6%80%A7%E8%83%BD%E8%B0%83%E4%BC%98/#/schema/image/2","url":"https://koktlzz.github.io/doks.png","contentUrl":"https://koktlzz.github.io/doks.png","caption":"性能调优"}]}]}</script><meta name=theme-color content="#fff"><link rel=apple-touch-icon sizes=180x180 href=https://koktlzz.github.io/apple-touch-icon.png><link rel=icon type=image/png sizes=32x32 href=https://koktlzz.github.io/favicon-32x32.ico><link rel=icon type=image/png sizes=16x16 href=https://koktlzz.github.io/favicon-16x16.ico><link rel=manifest crossorigin=use-credentials href=https://koktlzz.github.io/site.webmanifest></head><body class="Elastic single dark"><noscript><iframe src="https://www.googletagmanager.com/ns.html?id=GTM-P72R45W" height=0 width=0 style=display:none;visibility:hidden></iframe></noscript><div class="header-bar fixed-top"></div><header class="navbar fixed-top navbar-expand-md navbar-light"><div class=container-fluid><input class="menu-btn order-0" type=checkbox id=menu-btn>
<label class="menu-icon d-md-none" for=menu-btn><span class=navicon></span></label><a class="navbar-brand order-1 order-md-0 me-auto" href=https://koktlzz.github.io/>Inspire Hub</a>
<button id=mode class="btn btn-link order-2 order-md-4" type=button aria-label="Toggle mode">
<span class=toggle-dark><svg xmlns="http://www.w3.org/2000/svg" width="20" height="20" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="feather feather-moon"><path d="M21 12.79A9 9 0 1111.21 3 7 7 0 0021 12.79z"/></svg></span><span class=toggle-light><svg xmlns="http://www.w3.org/2000/svg" width="20" height="20" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="feather feather-sun"><circle cx="12" cy="12" r="5"/><line x1="12" y1="1" x2="12" y2="3"/><line x1="12" y1="21" x2="12" y2="23"/><line x1="4.22" y1="4.22" x2="5.64" y2="5.64"/><line x1="18.36" y1="18.36" x2="19.78" y2="19.78"/><line x1="1" y1="12" x2="3" y2="12"/><line x1="21" y1="12" x2="23" y2="12"/><line x1="4.22" y1="19.78" x2="5.64" y2="18.36"/><line x1="18.36" y1="5.64" x2="19.78" y2="4.22"/></svg></span></button><ul class="navbar-nav social-nav order-3 order-md-5"><li class=nav-item><a class=nav-link href=https://github.com/koktlzz><svg xmlns="http://www.w3.org/2000/svg" width="20" height="20" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="feather feather-github"><path d="M9 19c-5 1.5-5-2.5-7-3m14 6v-3.87a3.37 3.37.0 00-.94-2.61c3.14-.35 6.44-1.54 6.44-7A5.44 5.44.0 0020 4.77 5.07 5.07.0 0019.91 1S18.73.65 16 2.48a13.38 13.38.0 00-7 0C6.27.65 5.09 1 5.09 1A5.07 5.07.0 005 4.77 5.44 5.44.0 003.5 8.55c0 5.42 3.3 6.61 6.44 7A3.37 3.37.0 009 18.13V22"/></svg><span class="ms-2 visually-hidden">GitHub</span></a></li></ul><div class="collapse navbar-collapse order-4 order-md-1"><ul class="navbar-nav main-nav me-auto order-5 order-md-2"><li class=nav-item><a class=nav-link href=https://koktlzz.github.io/docker/docker%E5%9F%BA%E7%A1%80/intro>Docker</a></li><li class=nav-item><a class=nav-link href=https://koktlzz.github.io/kubernetes/kubernetes%E5%9F%BA%E7%A1%80/intro>Kubernetes</a></li><li class=nav-item><a class=nav-link href=https://koktlzz.github.io/elastic/elasticstack/intro>Elastic</a></li><li class=nav-item><a class=nav-link href=https://koktlzz.github.io/go/go%E5%9F%BA%E7%A1%80/intro>Go</a></li><li class=nav-item><a class=nav-link href=https://koktlzz.github.io/infra/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E5%9F%BA%E7%A1%80/tcpip%E7%BD%91%E7%BB%9C%E6%A8%A1%E5%9E%8B>Infra</a></li></ul><div class="break order-6 d-md-none"></div></div></div></header><div class="wrap container-fluid" role=document><div class=content><div class="row flex-xl-nowrap"><div class="col-lg-3 col-xl-2 d-none d-xl-block"><nav class=docs-links aria-label="Main navigation"><h3>ElasticStack</h3><ul class=list-unstyled><li><a class=docs-link href=https://koktlzz.github.io/elastic/elasticstack/intro/>Get Started</a></li><li><a class=docs-link href=https://koktlzz.github.io/elastic/elasticstack/%E5%8D%95%E8%8A%82%E7%82%B9%E9%83%A8%E7%BD%B2%E6%B5%81%E7%A8%8B/>单节点部署流程</a></li></ul><h3>Elasticsearch</h3><ul class=list-unstyled><li><a class=docs-link href=https://koktlzz.github.io/elastic/elasticsearch/infrastructure/>Infrastructure</a></li><li><a class=docs-link href=https://koktlzz.github.io/elastic/elasticsearch/mapping/>Mapping</a></li><li><a class=docs-link href=https://koktlzz.github.io/elastic/elasticsearch/textanalysis/>Text analysis</a></li><li><a class=docs-link href=https://koktlzz.github.io/elastic/elasticsearch/template/>Template</a></li><li><a class=docs-link href=https://koktlzz.github.io/elastic/elasticsearch/ilm/>ILM</a></li><li><a class=docs-link href=https://koktlzz.github.io/elastic/elasticsearch/snapshot/>Snapshot</a></li><li><a class=docs-link href=https://koktlzz.github.io/elastic/elasticsearch/%E6%80%A7%E8%83%BD%E8%B0%83%E4%BC%98/>性能调优</a></li></ul><h3>Kafka</h3><ul class=list-unstyled><li><a class=docs-link href=https://koktlzz.github.io/elastic/kafka/intro/>Intro</a></li><li><a class=docs-link href=https://koktlzz.github.io/elastic/kafka/hw/>副本备份机制</a></li><li><a class=docs-link href=https://koktlzz.github.io/elastic/kafka/transaction/>事务</a></li></ul></nav></div><main class="docs-content col-lg-13 col-xl-11"><h1>性能调优</h1><p class=lead></p><p>吞吐量（throughput）和延迟（latency）是评估 Elasticsearch 集群性能的指标，前者代表每秒写入（index）或查询（search）文档的数量，后者则代表单个请求的延迟。上述指标之间也有一定联系：延迟越低，吞吐量就越高。</p><p><img src=https://cdn.jsdelivr.net/gh/koktlzz/NoteImg@main/20210608105408.png alt=20210608105408></p><h2 id=jvm-内存压力>JVM 内存压力<a href=#jvm-内存压力 class=anchor aria-hidden=true>#</a></h2><p>Elasticsearch 集群的吞吐量显然与节点的负载相关，尤其是大量的请求将引起节点的 JVM 内存压力升高。Elasticsearch 使用断路器（<a href=https://www.elastic.co/guide/en/elasticsearch/reference/7.13/circuit-breaker.html>Circuit Breaker</a>）来防止节点出现 JVM 堆内存溢出。如果 Elasticsearch 评估一项操作将触发断路器，那么便会返回一个 HTTP 错误码 429：</p><div class=highlight><pre style=color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-json data-lang=json>{
  &#39;error&#39;: {
    &#39;type&#39;: &#39;circuit_breaking_exception&#39;,
    &#39;reason&#39;: &#39;[parent] Data too large, data for [&lt;http_request&gt;] would be [123848638/118.1mb], which is larger than the limit of [123273216/117.5mb], real usage: [120182112/114.6mb], new bytes reserved: [3666526/3.4mb]&#39;,
    &#39;bytes_wanted&#39;: 123848638,
    &#39;bytes_limit&#39;: 123273216,
    &#39;durability&#39;: &#39;TRANSIENT&#39;
  },
  &#39;status&#39;: <span style=color:#bd93f9>429</span>
}
</code></pre></div><p>由于断路器有多个，首先应先查看其具体的触发情况：</p><div class=highlight><pre style=color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-json data-lang=json>GET _nodes/stats/breaker

// 返回
<span style=color:#f1fa8c>&#34;breakers&#34;</span> : {
    <span style=color:#ff79c6>&#34;request&#34;</span> : {
        <span style=color:#ff79c6>&#34;limit_size_in_bytes&#34;</span> : <span style=color:#bd93f9>1278030643</span>,
        <span style=color:#ff79c6>&#34;limit_size&#34;</span> : <span style=color:#f1fa8c>&#34;1.1gb&#34;</span>,
        <span style=color:#ff79c6>&#34;estimated_size_in_bytes&#34;</span> : <span style=color:#bd93f9>0</span>,
        <span style=color:#ff79c6>&#34;estimated_size&#34;</span> : <span style=color:#f1fa8c>&#34;0b&#34;</span>,
        <span style=color:#ff79c6>&#34;overhead&#34;</span> : <span style=color:#bd93f9>1.0</span>,
        <span style=color:#ff79c6>&#34;tripped&#34;</span> : <span style=color:#bd93f9>0</span>
    },
    <span style=color:#ff79c6>&#34;fielddata&#34;</span> : {
        <span style=color:#ff79c6>&#34;limit_size_in_bytes&#34;</span> : <span style=color:#bd93f9>852020428</span>,
        <span style=color:#ff79c6>&#34;limit_size&#34;</span> : <span style=color:#f1fa8c>&#34;812.5mb&#34;</span>,
        <span style=color:#ff79c6>&#34;estimated_size_in_bytes&#34;</span> : <span style=color:#bd93f9>1112</span>,
        <span style=color:#ff79c6>&#34;estimated_size&#34;</span> : <span style=color:#f1fa8c>&#34;1kb&#34;</span>,
        <span style=color:#ff79c6>&#34;overhead&#34;</span> : <span style=color:#bd93f9>1.03</span>,
        <span style=color:#ff79c6>&#34;tripped&#34;</span> : <span style=color:#bd93f9>0</span>
    },
    ...
    <span style=color:#ff79c6>&#34;parent&#34;</span> : {
        <span style=color:#ff79c6>&#34;limit_size_in_bytes&#34;</span> : <span style=color:#bd93f9>2023548518</span>,
        <span style=color:#ff79c6>&#34;limit_size&#34;</span> : <span style=color:#f1fa8c>&#34;1.8gb&#34;</span>,
        <span style=color:#ff79c6>&#34;estimated_size_in_bytes&#34;</span> : <span style=color:#bd93f9>1129775232</span>,
        <span style=color:#ff79c6>&#34;estimated_size&#34;</span> : <span style=color:#f1fa8c>&#34;1gb&#34;</span>,
        <span style=color:#ff79c6>&#34;overhead&#34;</span> : <span style=color:#bd93f9>1.0</span>,
        <span style=color:#ff79c6>&#34;tripped&#34;</span> : <span style=color:#bd93f9>0</span>
    }
}
</code></pre></div><p>默认情况下，parent（父级）断路器在 JVM 内存达到 95%时触发。为了预防报错的产生，我们需要在其持续超过 85%时采取相应措施：</p><ul><li>如果 fielddata 断路器触发，则应减少 <a href=https://koktlzz.github.io/elastic/elasticsearch/mapping/#fielddata>fielddata</a> 的使用；</li><li>清除 fielddata 缓存：<code>POST _cache/clear?fielddata=true</code>；</li><li>避免“昂贵的”搜索（expensive search);</li><li>避免“映射爆炸”(mapping explosions);</li><li>将批量请求（bulk request）拆分为多个小的请求；</li><li>升级节点内存；</li><li><strong>减少索引分片的数量</strong>。</li></ul><p>详见官方文档：<a href=https://www.elastic.co/guide/en/elasticsearch/reference/7.13/fix-common-cluster-issues.html#high-jvm-memory-pressure>High JVM memory pressure</a></p><h2 id=索引分片策略>索引分片策略<a href=#索引分片策略 class=anchor aria-hidden=true>#</a></h2><p>上文提到，我们可以通过减少索引分片的数量来降低节点的 JVM 内存压力，这是因为：</p><ul><li>分片过多会导致底层的 Segment 过多，而 Segment 会消耗文件句柄、内存和 CPU 资源，并且每次搜索请求都必须轮流检查每个 Segment，进而导致开销增加；</li><li>对于每个 Elasticsearch 索引，Mapping 和 State 的相关信息都保存在集群状态 (<code>GET /_cluster/state</code>) 中。它们存储在内存中，以便快速访问。因此，如果集群中的索引和分片数量过多，而 Mapping 又比较复杂的话，将占用大量内存。</li></ul><p><a href=https://www.elastic.co/cn/blog/how-many-shards-should-i-have-in-my-elasticsearch-cluster>官方博客</a> 给出了分片策略的相关建议：</p><ul><li>建议将分片的平均大小控制在几 GB 到几十 GB 之间。对时序型数据用例而言，分片大小通常介于 20GB 至 40GB 之间；</li><li>将分片数量/节点内存（GB）保持在 20 以下。例如，某个节点拥有 30GB 的堆内存，那其最多可有 600 个分片。在此限值范围内，设置的分片数量越少，性能就会越好；</li><li>对于时序型索引，使用 <a href=https://www.elastic.co/cn/blog/managing-time-based-indices-efficiently>shrink 或 rollover API</a> 减少索引和分片的数量。</li></ul><p>当然，分片的大小也不能无限制地扩大，因为会对集群的故障恢复造成不利影响。尽管并没有关于分片大小的固定限值，但通常将 50GB 作为分片大小的上限，而这一限值在各种用例中都已得到验证。</p><h2 id=索引写入性能>索引写入性能<a href=#索引写入性能 class=anchor aria-hidden=true>#</a></h2><p>优化索引的写入性能主要有以下途径：</p><ul><li>使用批量请求写入索引，而非单个文档写入；</li><li>使用多个线程或进程向 Elasticsearch 发送数据；</li><li>如果对实时搜索要求不高，可以将索引的 <a href=https://koktlzz.github.io/elastic/elasticsearch/infrastructure/#refresh>refresh</a> 间隔时间 (<code>index.refresh_interval</code>) 从默认值 1s 提升到 30s 左右；</li><li>先将索引的副本数 (<code>index.number_of_replicas</code>) 设置为 0，待写入全部完成后，再将其恢复到原始值；</li><li>文件系统缓存（Filesystem Cache）将用于缓冲 I/O 操作，因此应确保节点的内存至少有一半分配给了文件系统缓存；</li><li>若文档使用自定义的<code>_id</code>，那么 Elasticsearch 将在其写入分片时检查<code>_id</code>是否重复。这是一项代价高昂的操作，因此建议使用自动生成的<code>_id</code>；</li><li>物理存储设备使用 SSD 而非 HDD 或 NFS；</li><li>减少磁盘的使用率，详见 <a href=https://www.elastic.co/guide/en/elasticsearch/reference/7.13/tune-for-disk-usage.html>Tune for disk usage</a>。</li></ul><p>在硬件设备无法升级的情况下，第一个方法是我们提升索引写入性能的常用手段。然而，大量的批量请求可能引发 Elasticsearch 的 429 错误：<strong>Too many requests</strong>。因此在搭建集群前，我们需要对单节点单分片进行基准测试（benchmark），从而确认批量请求的最佳大小。首先尝试一次索引 100 个文档，然后提高到 200，400，等等。在每次基准测试中，批量请求中的文档数量加倍。当索引写入速度开始趋于平稳时，则说明批量请求达到了最佳大小。</p><p>那么如果生产环境的 Elasticsearch 向客户端返回 429 错误，我们有没有什么办法解决呢？这就要从批量请求的处理方式说起。Elasticsearch 节点使用线程池（Thread Pool）来管理内存消费，多个线程池队列使得客户端的请求能够在缓冲区保留而非丢弃。这样便可以防止客户端大量的写入请求造成集群的过载，进而提升集群的可靠性和稳定性。</p><p>当批量请求到达集群中的协调节点后，首先进入批量队列中，并交由线程池中的线程进行处理。由于其中的文档可能属于多个不同的索引和分片，因此需要根据分片对其进行拆分。随后拆分后的文档会被路由到其主分片所在的数据节点上，进入该节点的批量队列中。如果队列中没有多余空间，将会通知协调节点该子请求（sub-request）被拒绝。若索引的副本数不为 0，数据节点的线程池还要将文档发往其副本所在的节点上。待同步完成后，数据节点同样会向协调节点发送响应。一旦所有的子请求全部完成（或部分被拒绝），协调节点就会创建一个响应返回给客户端。</p><p>Elasticsearch API 可以查看节点线程池中各线程的批量队列配置：</p><div class=highlight><pre style=color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-json data-lang=json>Get _nodes/thread_pool

// 返回
...
<span style=color:#f1fa8c>&#34;thread_pool&#34;</span>: {
    <span style=color:#ff79c6>&#34;watcher&#34;</span>: {
        <span style=color:#ff79c6>&#34;type&#34;</span>: <span style=color:#f1fa8c>&#34;fixed&#34;</span>,
        <span style=color:#ff79c6>&#34;size&#34;</span>: <span style=color:#bd93f9>50</span>,
        <span style=color:#ff79c6>&#34;queue_size&#34;</span>: <span style=color:#bd93f9>1000</span>
    },
    <span style=color:#ff79c6>&#34;force_merge&#34;</span>: {
        <span style=color:#ff79c6>&#34;type&#34;</span>: <span style=color:#f1fa8c>&#34;fixed&#34;</span>,
        <span style=color:#ff79c6>&#34;size&#34;</span>: <span style=color:#bd93f9>1</span>,
        <span style=color:#ff79c6>&#34;queue_size&#34;</span>: <span style=color:#bd93f9>-1</span>
    },
    <span style=color:#ff79c6>&#34;search&#34;</span>: {
        <span style=color:#ff79c6>&#34;type&#34;</span>: <span style=color:#f1fa8c>&#34;fixed_auto_queue_size&#34;</span>,
        <span style=color:#ff79c6>&#34;size&#34;</span>: <span style=color:#bd93f9>25</span>,
        <span style=color:#ff79c6>&#34;queue_size&#34;</span>: <span style=color:#bd93f9>1000</span>
    },
    <span style=color:#ff79c6>&#34;write&#34;</span>: {
        <span style=color:#ff79c6>&#34;type&#34;</span>: <span style=color:#f1fa8c>&#34;fixed&#34;</span>,
        <span style=color:#ff79c6>&#34;size&#34;</span>: <span style=color:#bd93f9>16</span>,
        <span style=color:#ff79c6>&#34;queue_size&#34;</span>: <span style=color:#bd93f9>200</span>
    }
}
...
</code></pre></div><p>其中，size 为线程数，queue_size 为待处理请求队列的大小。<code>write</code>线程负责处理每个文档的索引、删除、更新操作以及批量请求，若存在大量拒绝，则说明集群的写入性能达到了瓶颈：</p><div class=highlight><pre style=color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-json data-lang=json>GET _cat/thread_pool/write?v

// 返回
node_name           name  active queue rejected
instance<span style=color:#bd93f9>-0000000015</span> write     <span style=color:#bd93f9>16</span>    <span style=color:#bd93f9>75</span>   <span style=color:#bd93f9>912687</span>
instance<span style=color:#bd93f9>-0000000017</span> write      <span style=color:#bd93f9>4</span>     <span style=color:#bd93f9>0</span>   <span style=color:#bd93f9>808414</span>
instance<span style=color:#bd93f9>-0000000016</span> write      <span style=color:#bd93f9>4</span>     <span style=color:#bd93f9>0</span>   <span style=color:#bd93f9>514021</span>
</code></pre></div><p>为解决这一问题，我们首先想到的是增加批量请求队列的大小。但实际上它并不会增大集群的吞吐量，只是让更多的数据在节点的内存中排队，甚至可能导致批量请求的处理时间增长。队列中的批量处理越多，被消耗的宝贵堆内存就越多。堆上压力过大将引起性能的下降，甚至导致集群的不稳定。</p><p>Cat Thread Pool 的返回结果可以看出拒绝发生在整个集群还是在单个节点，从而判断写入压力是否分布不均。根据 <a href=https://www.elastic.co/cn/blog/why-am-i-seeing-bulk-rejections-in-my-elasticsearch-cluster>官方博客</a> 中的测试结果，三节点集群的写入性能显著优于单节点和两节点集群。而两节点相比单节点提升不大，可能是因为两节点分担写入压力不够完美且副本同步操作增加了集群的负载。因此生产环境建议使用三节点部署，这样既实现了高可用，又大大提升了索引的写入性能。</p><p>我们还可以通过降低发送批量请求的频率来避免 Elasticsearch 出现 429 报错。以数据源 Logstash 为例，涉及的主要参数如下：</p><ul><li><code>pipeline.batch.size</code>：单个工作线程在尝试执行 filter，output 之前收集的最大事件数。数值越大，处理则通常更高效，但增加了内存开销；</li><li><code>pipeline.batch.delay</code>：当前工作线程中接收到事件后等待新消息的最大时间（毫秒）。在此时间过后，Logstash 开始执行 filter 和 output。</li></ul><p>Logstash 从接收事件到 filter 处理事件之间等待的最大时间是<code>pipeline.batch.delay</code>和<code>pipeline.batch.size</code>的乘积。将上述两参数适当调大，可以增大每次批量请求的大小而降低发送的频率，防止 Elasticsearch 集群过载。</p><h2 id=索引搜索性能>索引搜索性能<a href=#索引搜索性能 class=anchor aria-hidden=true>#</a></h2><p>提升索引的写入性能有多种途径，如：</p><ul><li>对文档进行建模 (Document modeling)；</li><li>尽可能减少搜索的字段数量；</li><li>使用 term 进行查询，速度较快；</li><li>减少脚本的使用 &mldr;</li></ul><p>更多调优方案详见官方文档中的说明：<a href=https://www.elastic.co/guide/en/elasticsearch/reference/7.13/tune-for-search-speed.html>Tune for search speed</a></p><h2 id=参考文献>参考文献<a href=#参考文献 class=anchor aria-hidden=true>#</a></h2><p><a href=https://www.elastic.co/cn/blog/how-many-shards-should-i-have-in-my-elasticsearch-cluster>我在 Elasticsearch 集群内应该设置多少个分片？</a></p><p><a href=https://elasticstack.blog.csdn.net/article/details/117443617>Elasticsearch：针对日志和指标对 Elasticsearch 集群进行基准测试并确定集群规模</a></p><p><a href=https://www.elastic.co/cn/blog/why-am-i-seeing-bulk-rejections-in-my-elasticsearch-cluster>Why am I seeing bulk rejections in my Elasticsearch cluster?</a></p><p><a href=https://www.elastic.co/guide/en/elasticsearch/reference/7.13/fix-common-cluster-issues.html>Fix common cluster issues</a></p><p><a href=https://www.elastic.co/guide/en/elasticsearch/reference/7.13/tune-for-indexing-speed.html>Tune for indexing speed</a></p><p><a href=https://www.elastic.co/guide/en/elasticsearch/reference/7.13/tune-for-disk-usage.html>Tune for disk usage</a></p><p><a href=https://www.elastic.co/guide/en/elasticsearch/reference/7.13/tune-for-search-speed.html>Tune for search speed</a></p><p class=edit-page><a href=https://github.com/koktlzz/koktlzz.github.io/blob/master/content/Elastic/Elasticsearch/%e6%80%a7%e8%83%bd%e8%b0%83%e4%bc%98.md><svg xmlns="http://www.w3.org/2000/svg" width="16" height="16" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="feather feather-edit-2"><path d="M17 3a2.828 2.828.0 114 4L7.5 20.5 2 22l1.5-5.5L17 3z"/></svg>Edit this page on GitHub</a></p><div class="docs-navigation d-flex justify-content-between"><a href=https://koktlzz.github.io/elastic/elasticsearch/snapshot/><div class="card my-1"><div class="card-body py-2">&larr; Snapshot</div></div></a><a class=ms-auto href=https://koktlzz.github.io/elastic/kafka/intro/><div class="card my-1"><div class="card-body py-2">Intro &rarr;</div></div></a></div><script src=https://utteranc.es/client.js repo=koktlzz/koktlzz.github.io issue-term=pathname theme=photon-dark crossorigin=anonymous async></script></main><nav class="docs-toc d-none d-xl-block col-lg-3 col-xl-2" aria-label="Secondary navigation"><div class=page-links><h3>On this page</h3><nav id=TableOfContents><ul><li><a href=#jvm-内存压力>JVM 内存压力</a></li><li><a href=#索引分片策略>索引分片策略</a></li><li><a href=#索引写入性能>索引写入性能</a></li><li><a href=#索引搜索性能>索引搜索性能</a></li><li><a href=#参考文献>参考文献</a></li></ul></nav></div></nav></div></div></div><footer class="footer text-muted"><div class=container><div class=row><div class="col-lg-8 order-last order-lg-first"><ul class=list-inline><li class=list-inline-item></li></ul></div><div class="col-lg-8 order-first order-lg-last text-lg-end"><ul class=list-inline></ul></div></div></div></footer><script src=https://koktlzz.github.io/js/bootstrap.min.d67050adf5d370668aede4201f82af781b16970934804995a1ca37c1ee9222c2fc530972aa6d5d2b6124caf1fe318f139aac99df2c1e89af65504fc1185c7972.js integrity="sha512-1nBQrfXTcGaK7eQgH4KveBsWlwk0gEmVoco3we6SIsL8Uwlyqm1dK2EkyvH+MY8TmqyZ3yweia9lUE/BGFx5cg==" crossorigin=anonymous defer></script><script src=https://koktlzz.github.io/js/vendor/katex/dist/katex.min.b334e5b00c45f572e7f38a543046f36854bf4cbb543880480c09271a0efedc694d6905f719934f6ede2f26f52e80411c05b90121d722cbf8be2fa8fc51bc6b81.js integrity="sha512-szTlsAxF9XLn84pUMEbzaFS/TLtUOIBIDAknGg7+3GlNaQX3GZNPbt4vJvUugEEcBbkBIdciy/i+L6j8UbxrgQ==" crossorigin=anonymous defer></script><script src=https://koktlzz.github.io/js/vendor/katex/dist/contrib/auto-render.min.916823ec103cf367b71e28a6f01513cb9c3ac6708ccb5229402ec46b8e30a8b25003db694df35d80e9dd666a371f327c6152790617b6256390c164109a90bd4c.js integrity="sha512-kWgj7BA882e3Hiim8BUTy5w6xnCMy1IpQC7Ea44wqLJQA9tpTfNdgOndZmo3HzJ8YVJ5Bhe2JWOQwWQQmpC9TA==" crossorigin=anonymous defer></script><script src=https://koktlzz.github.io/main.min.1febbf2f6fd6a36fc2f57dd50d7935fbb640743329baeb4ef7cefcf2e7630e413371fbba976e103656b82808ee227dc4a84237edb0f8433648bef3a56900661a.js integrity="sha512-H+u/L2/Wo2/C9X3VDXk1+7ZAdDMpuutO98788udjDkEzcfu6l24QNla4KAjuIn3EqEI37bD4QzZIvvOlaQBmGg==" crossorigin=anonymous defer></script></body></html>