<!doctype html><html lang=en-us><head><script async src="https://www.googletagmanager.com/gtag/js?id=G-D022F6NT2P"></script><script>window.dataLayer=window.dataLayer||[];function gtag(){dataLayer.push(arguments)}gtag('js',new Date),gtag('config','G-D022F6NT2P')</script><script>(function(b,d,e,a,g){b[a]=b[a]||[],b[a].push({'gtm.start':(new Date).getTime(),event:'gtm.js'});var f=d.getElementsByTagName(e)[0],c=d.createElement(e),h=a!='dataLayer'?'&l='+a:'';c.async=!0,c.src='https://www.googletagmanager.com/gtm.js?id='+g+h,f.parentNode.insertBefore(c,f)})(window,document,'script','dataLayer','GTM-P72R45W')</script><meta charset=utf-8><meta http-equiv=x-ua-compatible content="ie=edge"><meta name=viewport content="width=device-width,initial-scale=1,shrink-to-fit=no"><link rel=preload as=font href=https://koktlzz.github.io/fonts/vendor/jost/jost-v4-latin-regular.woff2 type=font/woff2 crossorigin><link rel=preload as=font href=https://koktlzz.github.io/fonts/vendor/jost/jost-v4-latin-700.woff2 type=font/woff2 crossorigin><link rel=preload as=font href=https://koktlzz.github.io/fonts/KaTeX_Main-Regular.woff2 type=font/woff2 crossorigin><link rel=preload as=font href=https://koktlzz.github.io/fonts/KaTeX_Math-Italic.woff2 type=font/woff2 crossorigin><link rel=stylesheet href=https://koktlzz.github.io/main.0ae7165cfeda76c765ab05aa408a696be65779f1e277afd078efecc543cc00bb72be873f087e148ccf7ac1016b22c2d2586f058c7ee5d92dcca60206eae2dd99.css integrity="sha512-CucWXP7adsdlqwWqQIppa+ZXefHid6/QeO/sxUPMALtyvoc/CH4UjM96wQFrIsLSWG8FjH7l2S3MpgIG6uLdmQ==" crossorigin=anonymous><noscript><style>img.lazyload{display:none}</style></noscript><meta name=robots content="index, follow"><meta name=googlebot content="index, follow, max-snippet:-1, max-image-preview:large, max-video-preview:-1"><meta name=bingbot content="index, follow, max-snippet:-1, max-image-preview:large, max-video-preview:-1"><title>Volume | Inspire Hub</title><meta name=description content><link rel=canonical href=https://koktlzz.github.io/kubernetes/kubernetes%E5%9F%BA%E7%A1%80/volume/><meta property="og:locale" content="en_US"><meta property="og:type" content="article"><meta property="og:title" content="Volume"><meta property="og:description" content="意义 Kubernetes 引入 Volume 资源来解决以下问题：
 容器中的文件在磁盘上是临时存放的，kubelet 重启容器后，文件将会丢失； 在运行多个容器的 Pod 内实现文件共享。  配置 一个典型的有挂载卷的 Pod 配置如下：
apiVersion: v1 kind: Pod metadata: name: nginx spec: containers: - image: docker.io/nginx:latest name: nginx volumeMounts: - mountPath: /nginx-master-data name: test-volume volumes: - name: test-volume emptyDir: {}  spec.containers.volumeMounts.mountPath字段定义了 Volume 在容器中的挂载位置； 字段spec.containers.volumeMounts与spec.volumes.name必须相同； spec.volumes.emptyDir代表 Volume 的类型。  类型 Volume 的核心是包含一些数据的一个目录，Pod 中的容器可以访问该目录。Volume 的类型将决定该目录如何形成的、使用何种介质保存数据以及目录中存放的内容。
emptyDir 在当前 Pod 对应的目录创建了一个空的文件夹，这个文件夹会随着 Pod 的删除而删除。
hostPath 将 Pod 所在节点文件系统上的文件或目录挂载到 Pod 中。
nfs 将 NFS（Network File System）挂载到 Pod 中，可以在不同节点上的不同 Pod 之间共享数据并被多个 Pod 同时读写。当 Pod 被移除时，将仅仅卸载 nfs 数据卷，Volume 中的数据仍将被保留；"><meta property="og:url" content="https://koktlzz.github.io/kubernetes/kubernetes%E5%9F%BA%E7%A1%80/volume/"><meta property="og:site_name" content="Inspire Hub"><meta property="article:published_time" content="2020-11-04T09:19:42+01:00"><meta property="article:modified_time" content="2020-11-04T09:19:42+01:00"><meta property="og:image" content="https://koktlzz.github.io/doks.png"><meta property="og:image:alt" content="Inspire Hub"><meta name=twitter:card content="summary_large_image"><meta name=twitter:site content="@getdoks"><meta name=twitter:creator content="@henkverlinde"><meta name=twitter:title content="Volume"><meta name=twitter:description content><meta name=twitter:image content="https://koktlzz.github.io/doks.png"><meta name=twitter:image:alt content="Volume"><script type=application/ld+json>{"@context":"https://schema.org","@graph":[{"@type":"Organization","@id":"https://koktlzz.github.io/#/schema/organization/1","name":"Doks","url":"https://koktlzz.github.io/","sameAs":["https://twitter.com/getdoks","https://github.com/h-enk/doks"],"logo":{"@type":"ImageObject","@id":"https://koktlzz.github.io/#/schema/image/1","url":"https://koktlzz.github.io/logo-doks.png","width":512,"height":512,"caption":"Doks"},"image":{"@id":"https://koktlzz.github.io/#/schema/image/1"}},{"@type":"WebSite","@id":"https://koktlzz.github.io/#/schema/website/1","url":"https://koktlzz.github.io/","name":"Inspire Hub","description":"","publisher":{"@id":"https://koktlzz.github.io/#/schema/organization/1"}},{"@type":"WebPage","@id":"https://koktlzz.github.io/kubernetes/kubernetes%E5%9F%BA%E7%A1%80/volume/","url":"https://koktlzz.github.io/kubernetes/kubernetes%E5%9F%BA%E7%A1%80/volume/","name":"Volume","description":"","isPartOf":{"@id":"https://koktlzz.github.io/#/schema/website/1"},"about":{"@id":"https://koktlzz.github.io/#/schema/organization/1"},"datePublished":"2020-11-04T09:19:42CET","dateModified":"2020-11-04T09:19:42CET","breadcrumb":{"@id":"https://koktlzz.github.io/kubernetes/kubernetes%E5%9F%BA%E7%A1%80/volume/#/schema/breadcrumb/1"},"primaryImageOfPage":{"@id":"https://koktlzz.github.io/kubernetes/kubernetes%E5%9F%BA%E7%A1%80/volume/#/schema/image/2"},"inLanguage":"en-US","potentialAction":[{"@type":"ReadAction","target":["https://koktlzz.github.io/kubernetes/kubernetes%E5%9F%BA%E7%A1%80/volume/"]}]},{"@type":"BreadcrumbList","@id":"https://koktlzz.github.io/kubernetes/kubernetes%E5%9F%BA%E7%A1%80/volume/#/schema/breadcrumb/1","name":"Breadcrumbs","itemListElement":[{"@type":"ListItem","position":1,"item":{"@type":"WebPage","@id":"https://koktlzz.github.io/","url":"https://koktlzz.github.io/","name":"Home"}},{"@type":"ListItem","position":2,"item":{"@type":"WebPage","@id":"https://koktlzz.github.io/kubernetes/","url":"https://koktlzz.github.io/kubernetes/","name":"Kubernetes"}},{"@type":"ListItem","position":3,"item":{"@type":"WebPage","@id":"https://koktlzz.github.io/kubernetes/kubernetes%E5%9F%BA%E7%A1%80/","url":"https://koktlzz.github.io/kubernetes/kubernetes%E5%9F%BA%E7%A1%80/","name":"Kubernetes% E5%9 F% Ba% E7% A1%80"}},{"@type":"ListItem","position":4,"item":{"@id":"https://koktlzz.github.io/kubernetes/kubernetes%E5%9F%BA%E7%A1%80/volume/"}}]},{"@context":"https://schema.org","@graph":[{"@type":"ImageObject","@id":"https://koktlzz.github.io/kubernetes/kubernetes%E5%9F%BA%E7%A1%80/volume/#/schema/image/2","url":"https://koktlzz.github.io/doks.png","contentUrl":"https://koktlzz.github.io/doks.png","caption":"Volume"}]}]}</script><meta name=theme-color content="#fff"><link rel=apple-touch-icon sizes=180x180 href=https://koktlzz.github.io/apple-touch-icon.png><link rel=icon type=image/png sizes=32x32 href=https://koktlzz.github.io/favicon-32x32.ico><link rel=icon type=image/png sizes=16x16 href=https://koktlzz.github.io/favicon-16x16.ico><link rel=manifest crossorigin=use-credentials href=https://koktlzz.github.io/site.webmanifest></head><body class="Kubernetes single dark"><noscript><iframe src="https://www.googletagmanager.com/ns.html?id=GTM-P72R45W" height=0 width=0 style=display:none;visibility:hidden></iframe></noscript><div class="header-bar fixed-top"></div><header class="navbar fixed-top navbar-expand-md navbar-light"><div class=container-fluid><input class="menu-btn order-0" type=checkbox id=menu-btn>
<label class="menu-icon d-md-none" for=menu-btn><span class=navicon></span></label><a class="navbar-brand order-1 order-md-0 me-auto" href=https://koktlzz.github.io/>Inspire Hub</a>
<button id=mode class="btn btn-link order-2 order-md-4" type=button aria-label="Toggle mode">
<span class=toggle-dark><svg xmlns="http://www.w3.org/2000/svg" width="20" height="20" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="feather feather-moon"><path d="M21 12.79A9 9 0 1111.21 3 7 7 0 0021 12.79z"/></svg></span><span class=toggle-light><svg xmlns="http://www.w3.org/2000/svg" width="20" height="20" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="feather feather-sun"><circle cx="12" cy="12" r="5"/><line x1="12" y1="1" x2="12" y2="3"/><line x1="12" y1="21" x2="12" y2="23"/><line x1="4.22" y1="4.22" x2="5.64" y2="5.64"/><line x1="18.36" y1="18.36" x2="19.78" y2="19.78"/><line x1="1" y1="12" x2="3" y2="12"/><line x1="21" y1="12" x2="23" y2="12"/><line x1="4.22" y1="19.78" x2="5.64" y2="18.36"/><line x1="18.36" y1="5.64" x2="19.78" y2="4.22"/></svg></span></button><ul class="navbar-nav social-nav order-3 order-md-5"><li class=nav-item><a class=nav-link href=https://github.com/koktlzz><svg xmlns="http://www.w3.org/2000/svg" width="20" height="20" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="feather feather-github"><path d="M9 19c-5 1.5-5-2.5-7-3m14 6v-3.87a3.37 3.37.0 00-.94-2.61c3.14-.35 6.44-1.54 6.44-7A5.44 5.44.0 0020 4.77 5.07 5.07.0 0019.91 1S18.73.65 16 2.48a13.38 13.38.0 00-7 0C6.27.65 5.09 1 5.09 1A5.07 5.07.0 005 4.77 5.44 5.44.0 003.5 8.55c0 5.42 3.3 6.61 6.44 7A3.37 3.37.0 009 18.13V22"/></svg><span class="ms-2 visually-hidden">GitHub</span></a></li></ul><div class="collapse navbar-collapse order-4 order-md-1"><ul class="navbar-nav main-nav me-auto order-5 order-md-2"><li class=nav-item><a class=nav-link href=https://koktlzz.github.io/docker/docker%E5%9F%BA%E7%A1%80/intro>Docker</a></li><li class=nav-item><a class=nav-link href=https://koktlzz.github.io/kubernetes/kubernetes%E5%9F%BA%E7%A1%80/intro>Kubernetes</a></li><li class=nav-item><a class=nav-link href=https://koktlzz.github.io/elastic/elasticstack/intro>Elastic</a></li><li class=nav-item><a class=nav-link href=https://koktlzz.github.io/go/go%E5%9F%BA%E7%A1%80/intro>Go</a></li><li class=nav-item><a class=nav-link href=https://koktlzz.github.io/infra/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E5%9F%BA%E7%A1%80/tcpip%E7%BD%91%E7%BB%9C%E6%A8%A1%E5%9E%8B>Infra</a></li><li class=nav-item><a class=nav-link href=https://koktlzz.github.io/prometheus/prometheus/intro>Prometheus</a></li></ul><div class="break order-6 d-md-none"></div></div></div></header><div class="wrap container-fluid" role=document><div class=content><div class="row flex-xl-nowrap"><div class="col-lg-3 col-xl-2 d-none d-xl-block"><nav class=docs-links aria-label="Main navigation"><h3>Kubernetes 基础</h3><ul class=list-unstyled><li><a class=docs-link href=https://koktlzz.github.io/kubernetes/kubernetes%E5%9F%BA%E7%A1%80/intro/>Getting Started</a></li><li><a class=docs-link href=https://koktlzz.github.io/kubernetes/kubernetes%E5%9F%BA%E7%A1%80/infrastructure/>Infrastructure</a></li><li><a class=docs-link href=https://koktlzz.github.io/kubernetes/kubernetes%E5%9F%BA%E7%A1%80/pod%E4%B8%8Enamespace/>Pod 与 Namespace</a></li><li><a class=docs-link href=https://koktlzz.github.io/kubernetes/kubernetes%E5%9F%BA%E7%A1%80/service/>Service</a></li><li><a class=docs-link href=https://koktlzz.github.io/kubernetes/kubernetes%E5%9F%BA%E7%A1%80/volume/>Volume</a></li><li><a class=docs-link href=https://koktlzz.github.io/kubernetes/kubernetes%E5%9F%BA%E7%A1%80/workloads/>Workloads</a></li></ul><h3>Kubernetes 进阶</h3><ul class=list-unstyled><li><a class=docs-link href=https://koktlzz.github.io/kubernetes/kubernetes%E8%BF%9B%E9%98%B6/networkpolicy/>Network Policy</a></li><li><a class=docs-link href=https://koktlzz.github.io/kubernetes/kubernetes%E8%BF%9B%E9%98%B6/ingress/>Ingress</a></li><li><a class=docs-link href=https://koktlzz.github.io/kubernetes/kubernetes%E8%BF%9B%E9%98%B6/sdn/>SDN</a></li><li><a class=docs-link href=https://koktlzz.github.io/kubernetes/kubernetes%E8%BF%9B%E9%98%B6/openvswitch/>Open vSwitch</a></li></ul></nav></div><main class="docs-content col-lg-13 col-xl-11"><h1>Volume</h1><p class=lead></p><h2 id=意义>意义<a href=#意义 class=anchor aria-hidden=true>#</a></h2><p>Kubernetes 引入 Volume 资源来解决以下问题：</p><ul><li>容器中的文件在磁盘上是临时存放的，kubelet 重启容器后，文件将会丢失；</li><li>在运行多个容器的 Pod 内实现文件共享。</li></ul><h2 id=配置>配置<a href=#配置 class=anchor aria-hidden=true>#</a></h2><p>一个典型的有挂载卷的 Pod 配置如下：</p><div class=highlight><pre style=color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yaml data-lang=yaml><span style=color:#ff79c6>apiVersion</span>: v1
<span style=color:#ff79c6>kind</span>: Pod
<span style=color:#ff79c6>metadata</span>:
  <span style=color:#ff79c6>name</span>: nginx
<span style=color:#ff79c6>spec</span>:
  <span style=color:#ff79c6>containers</span>:
  - <span style=color:#ff79c6>image</span>: docker.io/nginx:latest
    <span style=color:#ff79c6>name</span>: nginx
    <span style=color:#ff79c6>volumeMounts</span>:
    - <span style=color:#ff79c6>mountPath</span>: /nginx-master-data
      <span style=color:#ff79c6>name</span>: test-volume
  <span style=color:#ff79c6>volumes</span>:
  - <span style=color:#ff79c6>name</span>: test-volume
    <span style=color:#ff79c6>emptyDir</span>: {}
</code></pre></div><ul><li><code>spec.containers.volumeMounts.mountPath</code>字段定义了 Volume 在容器中的挂载位置；</li><li>字段<code>spec.containers.volumeMounts</code>与<code>spec.volumes.name</code>必须相同；</li><li><code>spec.volumes.emptyDir</code>代表 Volume 的类型。</li></ul><h2 id=类型>类型<a href=#类型 class=anchor aria-hidden=true>#</a></h2><p>Volume 的核心是包含一些数据的一个目录，Pod 中的容器可以访问该目录。Volume 的类型将决定该目录如何形成的、使用何种介质保存数据以及目录中存放的内容。</p><p><img src=https://cdn.jsdelivr.net/gh/koktlzz/ImgBed@master/20210313162624.png alt=20210313162624></p><h3 id=emptydir>emptyDir<a href=#emptydir class=anchor aria-hidden=true>#</a></h3><p>在当前 Pod 对应的目录创建了一个空的文件夹，这个文件夹会随着 Pod 的删除而删除。</p><h3 id=hostpath>hostPath<a href=#hostpath class=anchor aria-hidden=true>#</a></h3><p>将 Pod 所在节点文件系统上的文件或目录挂载到 Pod 中。</p><h3 id=nfs>nfs<a href=#nfs class=anchor aria-hidden=true>#</a></h3><p>将 NFS（Network File System）挂载到 Pod 中，可以在不同节点上的不同 Pod 之间共享数据并被多个 Pod 同时读写。当 Pod 被移除时，将仅仅卸载 nfs 数据卷，Volume 中的数据仍将被保留；</p><h3 id=configmap>configMap<a href=#configmap class=anchor aria-hidden=true>#</a></h3><p>提供了向 Pod 注入配置数据的方法。ConfigMap 对象中存储的数据可以被 configMap 类型的卷引用，然后被 Pod 中运行的应用使用。其典型配置如下：</p><div class=highlight><pre style=color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yaml data-lang=yaml><span style=color:#ff79c6>apiVersion</span>: v1
<span style=color:#ff79c6>kind</span>: Pod
<span style=color:#ff79c6>metadata</span>:
  <span style=color:#ff79c6>name</span>: configmap-pod
<span style=color:#ff79c6>spec</span>:
  <span style=color:#ff79c6>containers</span>:
    - <span style=color:#ff79c6>name</span>: test
      <span style=color:#ff79c6>image</span>: busybox
      <span style=color:#ff79c6>volumeMounts</span>:
        - <span style=color:#ff79c6>name</span>: config-vol
          <span style=color:#ff79c6>mountPath</span>: /etc/config
  <span style=color:#ff79c6>volumes</span>:
    - <span style=color:#ff79c6>name</span>: config-vol
      <span style=color:#ff79c6>configMap</span>:
        <span style=color:#ff79c6>name</span>: log-config
        <span style=color:#ff79c6>items</span>:
          - <span style=color:#ff79c6>key</span>: log_key
            <span style=color:#ff79c6>path</span>: log_path
</code></pre></div><p>名为 log-config 的 ConfigMap 对象以卷的形式挂载到 Pod 中。其中，挂载的目录为 ConfigMap 对象中键为 log_key 的所有内容（<code>spec.volumes.configMap.items.key</code>），路径为 Pod 中的/etc/config/log_path（<code>spec.containers.volumeMounts.mountPath</code>/<code>spec.volumes.configMap.items.path</code>）。</p><h3 id=secret>secret<a href=#secret class=anchor aria-hidden=true>#</a></h3><p>secret 类型的数据卷可以用来注入敏感信息（例如密码）到 Pod 中。</p><h3 id=persistentvolumeclaimpvc>persistentVolumeClaim（PVC）<a href=#persistentvolumeclaimpvc class=anchor aria-hidden=true>#</a></h3><p>常见的 Volume 类型，如 emptyDir、hostPath、configMap 和 secret 等，与所属的 Pod 具有相同的生命周期。为了实现数据的持久化存储，我们需要使用 persistentVolumeClaim 类型的 Volume“申领”持久卷 PV（Persistent Volume）并挂载到 Pod 中。</p><p>PV、PVC 和存储类（Storage Class）三者之间的关系如下：</p><ul><li><p>PV 是集群中的持久化存储资源，通常由集群管理员创建和管理；</p></li><li><p>Storage Class 用于用于描述集群中可以提供的 PV 的类型。若 PVC 关联了 Storage Class 且配置符合要求，Storage Class 也可以根据自身配置中的<code>provisioner</code>、<code>parameters</code>和<code>reclaimPolicy</code>字段动态创建 PV；</p><div class=highlight><pre style=color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yaml data-lang=yaml><span style=color:#ff79c6>apiVersion</span>: storage.k8s.io/v1
<span style=color:#ff79c6>kind</span>: StorageClass
<span style=color:#ff79c6>metadata</span>:
  <span style=color:#ff79c6>name</span>: standard
<span style=color:#ff79c6>provisioner</span>: kubernetes.io/aws-ebs
<span style=color:#ff79c6>parameters</span>:
  <span style=color:#ff79c6>type</span>: gp2
  <span style=color:#ff79c6>fsType</span>: ext4
<span style=color:#ff79c6>reclaimPolicy</span>: Retain
<span style=color:#ff79c6>allowVolumeExpansion</span>: <span style=color:#ff79c6>true</span>
<span style=color:#ff79c6>mountOptions</span>:
  - debug
<span style=color:#ff79c6>volumeBindingMode</span>: Immediate
</code></pre></div></li><li><p>Storage Class 配置中的<code>provisioner</code>字段定义了使用哪种数据卷插件（如 AWS EBS）来创建 PV（大多数由云服务商提供），<code>parameters</code>字段则定义了数据卷类型（如 gp2）、文件系统类型（如 ext4）等；</p></li><li><p>Storage Class 配置中的<code>reclaimPolicy</code>字段定义了 PV 的回收策略，默认为 Delete，代表移除 PV 及其关联的外部存储介质。若设置为 Retain，则 PVC 删除后 PV 及 PV 中的数据依然存在，只是不会再被其他 PVC 申领；</p></li><li><p>PVC 是申领 PV 资源的请求，通常由应用程序发出并指定 Storage Class 和需求的 Volume 空间大小；</p></li></ul><p><img src=https://cdn.jsdelivr.net/gh/koktlzz/NoteImg@main/193990293059406992.jpg alt=193990293059406992></p><h3 id=volume-snapshot>Volume Snapshot<a href=#volume-snapshot class=anchor aria-hidden=true>#</a></h3><ul><li>Volume Snapshot 是用户对存储卷创建快照的请求，相当于 PVC；</li><li>Volume Snapshot Content 是根据集群中已存在的存储卷（如 PVC）创建的快照资源，相当于 PV。因此，PVC 也可以反过来根据 Volume Snapshot Content 初始化；</li><li>Volume Snapshot Class 指定了 Volume Snapshot 的属性，相当于 Storage Class。即使从相同存储卷获取的快照，也可能因 Volume Snapshot Class 的配置不同而有所不同。</li></ul><p>一个简单的 Volume Snapshot 配置如下，该对象将根据指定的 PVC 动态创建 Volume Snapshot Content：</p><div class=highlight><pre style=color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yaml data-lang=yaml><span style=color:#ff79c6>apiVersion</span>: snapshot.storage.k8s.io/v1
<span style=color:#ff79c6>kind</span>: VolumeSnapshot
<span style=color:#ff79c6>metadata</span>:
  <span style=color:#ff79c6>name</span>: new-snapshot-test
<span style=color:#ff79c6>spec</span>:
  <span style=color:#ff79c6>volumeSnapshotClassName</span>: csi-hostpath-snapclass   <span style=color:#6272a4># 指定 Volume Snapshot Class</span>
  <span style=color:#ff79c6>source</span>:
    <span style=color:#ff79c6>persistentVolumeClaimName</span>: pvc-test             <span style=color:#6272a4># 指定快照的数据源</span>
</code></pre></div><p>当数据源不为 PVC 时，Volume Snapshot 也可以根据预定义的方式创建 Volume Snapshot Content:</p><div class=highlight><pre style=color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yaml data-lang=yaml><span style=color:#ff79c6>apiVersion</span>: snapshot.storage.k8s.io/v1
<span style=color:#ff79c6>kind</span>: VolumeSnapshot
<span style=color:#ff79c6>metadata</span>:
  <span style=color:#ff79c6>name</span>: test-snapshot
<span style=color:#ff79c6>spec</span>:
  <span style=color:#ff79c6>source</span>:
    <span style=color:#ff79c6>volumeSnapshotContentName</span>: test-content    
</code></pre></div><p>该方法需提前定义好对应的 Volume Snapshot Content 配置：</p><div class=highlight><pre style=color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yaml data-lang=yaml><span style=color:#ff79c6>apiVersion</span>: snapshot.storage.k8s.io/v1
<span style=color:#ff79c6>kind</span>: VolumeSnapshotContent
<span style=color:#ff79c6>metadata</span>:
  <span style=color:#ff79c6>name</span>: test-content
<span style=color:#ff79c6>spec</span>:
  <span style=color:#ff79c6>deletionPolicy</span>: Delete
  <span style=color:#ff79c6>driver</span>: hostpath.csi.k8s.io
  <span style=color:#ff79c6>source</span>:
    <span style=color:#ff79c6>snapshotHandle</span>: 7bdd0de3-aaeb-11e8-9aae-0242ac110002    
  <span style=color:#ff79c6>volumeSnapshotRef</span>:
    <span style=color:#ff79c6>name</span>: new-snapshot-test
    <span style=color:#ff79c6>namespace</span>: default
</code></pre></div><p><code>spec.source.snapshotHandle</code>字段指定了 Volume Snapshot Content 的数据源，其值为存储后端创建卷时返回的唯一标识符。</p><h2 id=数据卷内子路径>数据卷内子路径<a href=#数据卷内子路径 class=anchor aria-hidden=true>#</a></h2><p>定义<code>spec.containers.volumeMounts.subPath</code>字段，可以使容器在挂载 Volume 时指向数据卷内部的一个子路径，而不是直接指向数据卷的根路径。在下面的例子中，一个运行 LAMP（Linux Apache Mysql PHP）应用的 Pod 使用了一个共享数据卷，HTML 内容映射到数据卷内部的 html 目录，而数据库的内容映射到了 mysql 目录：</p><div class=highlight><pre style=color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yaml data-lang=yaml><span style=color:#ff79c6>apiVersion</span>: v1
<span style=color:#ff79c6>kind</span>: Pod
<span style=color:#ff79c6>metadata</span>:
  <span style=color:#ff79c6>name</span>: my-lamp-site
<span style=color:#ff79c6>spec</span>:
    <span style=color:#ff79c6>containers</span>:
    - <span style=color:#ff79c6>name</span>: mysql
      <span style=color:#ff79c6>image</span>: mysql
      <span style=color:#ff79c6>env</span>:
      - <span style=color:#ff79c6>name</span>: MYSQL_ROOT_PASSWORD
        <span style=color:#ff79c6>value</span>: <span style=color:#f1fa8c>&#34;rootpasswd&#34;</span>
      <span style=color:#ff79c6>volumeMounts</span>:
      - <span style=color:#ff79c6>mountPath</span>: /var/lib/mysql
        <span style=color:#ff79c6>name</span>: site-data
        <span style=color:#ff79c6>subPath</span>: mysql
        <span style=color:#ff79c6>readOnly</span>: <span style=color:#ff79c6>false</span>
    - <span style=color:#ff79c6>name</span>: php
      <span style=color:#ff79c6>image</span>: php:7.0-apache
      <span style=color:#ff79c6>volumeMounts</span>:
      - <span style=color:#ff79c6>mountPath</span>: /var/www/html
        <span style=color:#ff79c6>name</span>: site-data
        <span style=color:#ff79c6>subPath</span>: html
        <span style=color:#ff79c6>readOnly</span>: <span style=color:#ff79c6>false</span>
    <span style=color:#ff79c6>volumes</span>:
    - <span style=color:#ff79c6>name</span>: site-data
      <span style=color:#ff79c6>persistentVolumeClaim</span>:
        <span style=color:#ff79c6>claimName</span>: my-lamp-site-data
</code></pre></div><h2 id=挂载传播>挂载传播<a href=#挂载传播 class=anchor aria-hidden=true>#</a></h2><p>Volume 的传播能力允许将容器挂载的 Volume 共享到同一 Pod 中的其他容器，甚至共享到同一节点上的其他 Pod。由 Pod 配置中的<code>spec.containers.volumeMounts.mountPropagation</code>字段控制。可选的取值有：</p><ul><li>None：默认值。在数据卷被挂载到容器之后，此挂载卷将不会接受主机或其他容器后续在此卷或其任何子目录上执行的挂载操作。类似的，容器所创建的卷挂载在主机上也不可见。</li><li>HostToContainer：在数据卷被挂载到容器之后，宿主机向该数据卷对应目录添加挂载时，容器是可见的。</li><li>Bidirectional：在数据卷被挂载到容器之后，宿主机向该数据卷对应目录添加挂载时，容器是可见的；同时，从容器中向该数据卷创建挂载，宿主机同样可见。如果在容器内进行不合适的挂载，可能影响宿主机的操作系统正常执行。</li></ul><p class=edit-page><a href=https://github.com/koktlzz/koktlzz.github.io/blob/master/content/Kubernetes/Kubernetes%e5%9f%ba%e7%a1%80/Volume.md><svg xmlns="http://www.w3.org/2000/svg" width="16" height="16" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="feather feather-edit-2"><path d="M17 3a2.828 2.828.0 114 4L7.5 20.5 2 22l1.5-5.5L17 3z"/></svg>Edit this page on GitHub</a></p><div class="docs-navigation d-flex justify-content-between"><a href=https://koktlzz.github.io/kubernetes/kubernetes%E5%9F%BA%E7%A1%80/service/><div class="card my-1"><div class="card-body py-2">&larr; Service</div></div></a><a class=ms-auto href=https://koktlzz.github.io/kubernetes/kubernetes%E8%BF%9B%E9%98%B6/networkpolicy/><div class="card my-1"><div class="card-body py-2">Network Policy &rarr;</div></div></a></div><script src=https://utteranc.es/client.js repo=koktlzz/koktlzz.github.io issue-term=pathname theme=photon-dark crossorigin=anonymous async></script></main><nav class="docs-toc d-none d-xl-block col-lg-3 col-xl-2" aria-label="Secondary navigation"><div class=page-links><h3>On this page</h3><nav id=TableOfContents><ul><li><a href=#意义>意义</a></li><li><a href=#配置>配置</a></li><li><a href=#类型>类型</a><ul><li><a href=#emptydir>emptyDir</a></li><li><a href=#hostpath>hostPath</a></li><li><a href=#nfs>nfs</a></li><li><a href=#configmap>configMap</a></li><li><a href=#secret>secret</a></li><li><a href=#persistentvolumeclaimpvc>persistentVolumeClaim（PVC）</a></li><li><a href=#volume-snapshot>Volume Snapshot</a></li></ul></li><li><a href=#数据卷内子路径>数据卷内子路径</a></li><li><a href=#挂载传播>挂载传播</a></li></ul></nav></div></nav></div></div></div><footer class="footer text-muted"><div class=container><div class=row><div class="col-lg-8 order-last order-lg-first"><ul class=list-inline><li class=list-inline-item></li></ul></div><div class="col-lg-8 order-first order-lg-last text-lg-end"><ul class=list-inline></ul></div></div></div></footer><script src=https://koktlzz.github.io/js/bootstrap.min.d67050adf5d370668aede4201f82af781b16970934804995a1ca37c1ee9222c2fc530972aa6d5d2b6124caf1fe318f139aac99df2c1e89af65504fc1185c7972.js integrity="sha512-1nBQrfXTcGaK7eQgH4KveBsWlwk0gEmVoco3we6SIsL8Uwlyqm1dK2EkyvH+MY8TmqyZ3yweia9lUE/BGFx5cg==" crossorigin=anonymous defer></script><script src=https://koktlzz.github.io/js/vendor/katex/dist/katex.min.b334e5b00c45f572e7f38a543046f36854bf4cbb543880480c09271a0efedc694d6905f719934f6ede2f26f52e80411c05b90121d722cbf8be2fa8fc51bc6b81.js integrity="sha512-szTlsAxF9XLn84pUMEbzaFS/TLtUOIBIDAknGg7+3GlNaQX3GZNPbt4vJvUugEEcBbkBIdciy/i+L6j8UbxrgQ==" crossorigin=anonymous defer></script><script src=https://koktlzz.github.io/js/vendor/katex/dist/contrib/auto-render.min.916823ec103cf367b71e28a6f01513cb9c3ac6708ccb5229402ec46b8e30a8b25003db694df35d80e9dd666a371f327c6152790617b6256390c164109a90bd4c.js integrity="sha512-kWgj7BA882e3Hiim8BUTy5w6xnCMy1IpQC7Ea44wqLJQA9tpTfNdgOndZmo3HzJ8YVJ5Bhe2JWOQwWQQmpC9TA==" crossorigin=anonymous defer></script><script src=https://koktlzz.github.io/main.min.1febbf2f6fd6a36fc2f57dd50d7935fbb640743329baeb4ef7cefcf2e7630e413371fbba976e103656b82808ee227dc4a84237edb0f8433648bef3a56900661a.js integrity="sha512-H+u/L2/Wo2/C9X3VDXk1+7ZAdDMpuutO98788udjDkEzcfu6l24QNla4KAjuIn3EqEI37bD4QzZIvvOlaQBmGg==" crossorigin=anonymous defer></script></body></html>