<!doctype html><html lang=en-us><head><script async src="https://www.googletagmanager.com/gtag/js?id=G-D022F6NT2P"></script><script>window.dataLayer=window.dataLayer||[];function gtag(){dataLayer.push(arguments)}gtag('js',new Date),gtag('config','G-D022F6NT2P')</script><script>(function(b,d,e,a,g){b[a]=b[a]||[],b[a].push({'gtm.start':(new Date).getTime(),event:'gtm.js'});var f=d.getElementsByTagName(e)[0],c=d.createElement(e),h=a!='dataLayer'?'&l='+a:'';c.async=!0,c.src='https://www.googletagmanager.com/gtm.js?id='+g+h,f.parentNode.insertBefore(c,f)})(window,document,'script','dataLayer','GTM-P72R45W')</script><meta charset=utf-8><meta http-equiv=x-ua-compatible content="ie=edge"><meta name=viewport content="width=device-width,initial-scale=1,shrink-to-fit=no"><link rel=preload as=font href=https://koktlzz.github.io/fonts/vendor/jost/jost-v4-latin-regular.woff2 type=font/woff2 crossorigin><link rel=preload as=font href=https://koktlzz.github.io/fonts/vendor/jost/jost-v4-latin-700.woff2 type=font/woff2 crossorigin><link rel=preload as=font href=https://koktlzz.github.io/fonts/KaTeX_Main-Regular.woff2 type=font/woff2 crossorigin><link rel=preload as=font href=https://koktlzz.github.io/fonts/KaTeX_Math-Italic.woff2 type=font/woff2 crossorigin><link rel=stylesheet href=https://koktlzz.github.io/main.ebca557cf3c32b5d7383007b1d6530ae70a1c5514b328a864833775693332c3b061b5d3b53c07da94226d83ae7e1b1154ae602c9af23bf774333c01006692c0e.css integrity="sha512-68pVfPPDK11zgwB7HWUwrnChxVFLMoqGSDN3VpMzLDsGG107U8B9qUIm2Drn4bEVSuYCya8jv3dDM8AQBmksDg==" crossorigin=anonymous><noscript><style>img.lazyload{display:none}</style></noscript><meta name=robots content="index, follow"><meta name=googlebot content="index, follow, max-snippet:-1, max-image-preview:large, max-video-preview:-1"><meta name=bingbot content="index, follow, max-snippet:-1, max-image-preview:large, max-video-preview:-1"><title>SDN | KnowledgeBase</title><meta name=description content><link rel=canonical href=https://koktlzz.github.io/container/kubernetes/sdn/><meta property="og:locale" content="en_US"><meta property="og:type" content="article"><meta property="og:title" content="SDN"><meta property="og:description" content="前言 A Guide to the Kubernetes Networking Model 一文生动形象地介绍了 Kubernetes 中的网络模型，然而受篇幅所限，作者并没有对 Pod 跨节点通信时数据包在节点之间传递的细节进行过多讨论。
我们已经知道，Docker 使用端口映射的方式实现不同主机间容器的通信，Kubernetes 中同样也有 hostPort 的概念。但是当节点和 Pod 的数量上升后，手动管理节点上绑定的端口是十分困难的，这也是NodePort类型的 Service 的缺点之一。而一旦 Pod 不再“借用”节点的 IP 和端口来暴露自身的服务，就不得不面临一个棘手的问题：Pod 的本质是节点中的进程，节点外的物理网络设备（交换机/路由器）并不知晓 Pod 的存在。它们在接收目的地址为 Pod IP 的数据包时，无法完成进一步的传输工作。
为此我们需要使用一些 CNI（Container Network Interface）插件（如 Flannel、Calico 和 Open vSwitch 等）来优化 Kubernetes 集群的网络模型，这种新型的网络设计理念称为 SDN（Software-defined Networking）。根据 SDN 实现的层级，我们可以将其分为 Underlay Network 和 Overlay Network：
 Overlay 网络允许设备跨越底层物理网络（Underlay Network）进行通信，而底层却并不知晓 Overlay 网络的存在。Underlay 网络是专门用来承载用户 IP 流量的基础架构层，它与 Overlay 网络之间的关系有点类似物理机和虚拟机。Underlay 网络和物理机都是真正存在的实体，它们分别对应着真实存在的网络设备和计算设备，而 Overlay 网络和虚拟机都是依托在下层实体使用软件虚拟出来的层级。
 Underlay Network 利用 Underlay Network 实现 Pod 跨节点通信，既可以只依赖 TCP/IP 模型中的二层协议，也可以使用三层。但无论哪种实现方式，都必须对底层的物理网络有所要求。"><meta property="og:url" content="https://koktlzz.github.io/container/kubernetes/sdn/"><meta property="og:site_name" content="KnowledgeBase"><meta property="article:published_time" content="2020-11-04T09:19:42+01:00"><meta property="article:modified_time" content="2020-11-04T09:19:42+01:00"><meta property="og:image" content="https://koktlzz.github.io/doks.png"><meta property="og:image:alt" content="KnowledgeBase"><meta name=twitter:card content="summary_large_image"><meta name=twitter:site content="@getdoks"><meta name=twitter:creator content="@henkverlinde"><meta name=twitter:title content="SDN"><meta name=twitter:description content><meta name=twitter:image content="https://koktlzz.github.io/doks.png"><meta name=twitter:image:alt content="SDN"><script type=application/ld+json>{"@context":"https://schema.org","@graph":[{"@type":"Organization","@id":"https://koktlzz.github.io/#/schema/organization/1","name":"Doks","url":"https://koktlzz.github.io/","sameAs":["https://twitter.com/getdoks","https://github.com/h-enk/doks"],"logo":{"@type":"ImageObject","@id":"https://koktlzz.github.io/#/schema/image/1","url":"https://koktlzz.github.io/logo-doks.png","width":512,"height":512,"caption":"Doks"},"image":{"@id":"https://koktlzz.github.io/#/schema/image/1"}},{"@type":"WebSite","@id":"https://koktlzz.github.io/#/schema/website/1","url":"https://koktlzz.github.io/","name":"KnowledgeBase","description":"","publisher":{"@id":"https://koktlzz.github.io/#/schema/organization/1"}},{"@type":"WebPage","@id":"https://koktlzz.github.io/container/kubernetes/sdn/","url":"https://koktlzz.github.io/container/kubernetes/sdn/","name":"SDN","description":"","isPartOf":{"@id":"https://koktlzz.github.io/#/schema/website/1"},"about":{"@id":"https://koktlzz.github.io/#/schema/organization/1"},"datePublished":"2020-11-04T09:19:42CET","dateModified":"2020-11-04T09:19:42CET","breadcrumb":{"@id":"https://koktlzz.github.io/container/kubernetes/sdn/#/schema/breadcrumb/1"},"primaryImageOfPage":{"@id":"https://koktlzz.github.io/container/kubernetes/sdn/#/schema/image/2"},"inLanguage":"en-US","potentialAction":[{"@type":"ReadAction","target":["https://koktlzz.github.io/container/kubernetes/sdn/"]}]},{"@type":"BreadcrumbList","@id":"https://koktlzz.github.io/container/kubernetes/sdn/#/schema/breadcrumb/1","name":"Breadcrumbs","itemListElement":[{"@type":"ListItem","position":1,"item":{"@type":"WebPage","@id":"https://koktlzz.github.io/","url":"https://koktlzz.github.io/","name":"Home"}},{"@type":"ListItem","position":2,"item":{"@type":"WebPage","@id":"https://koktlzz.github.io/container/","url":"https://koktlzz.github.io/container/","name":"Container"}},{"@type":"ListItem","position":3,"item":{"@type":"WebPage","@id":"https://koktlzz.github.io/container/kubernetes/","url":"https://koktlzz.github.io/container/kubernetes/","name":"Kubernetes"}},{"@type":"ListItem","position":4,"item":{"@id":"https://koktlzz.github.io/container/kubernetes/sdn/"}}]},{"@context":"https://schema.org","@graph":[{"@type":"ImageObject","@id":"https://koktlzz.github.io/container/kubernetes/sdn/#/schema/image/2","url":"https://koktlzz.github.io/doks.png","contentUrl":"https://koktlzz.github.io/doks.png","caption":"SDN"}]}]}</script><meta name=theme-color content="#fff"><link rel=apple-touch-icon sizes=180x180 href=https://koktlzz.github.io/apple-touch-icon.png><link rel=icon type=image/png sizes=32x32 href=https://koktlzz.github.io/favicon-32x32.ico><link rel=icon type=image/png sizes=16x16 href=https://koktlzz.github.io/favicon-16x16.ico><link rel=manifest crossorigin=use-credentials href=https://koktlzz.github.io/site.webmanifest></head><body class="Container single dark"><noscript><iframe src="https://www.googletagmanager.com/ns.html?id=GTM-P72R45W" height=0 width=0 style=display:none;visibility:hidden></iframe></noscript><div class="header-bar fixed-top"></div><header class="navbar fixed-top navbar-expand-md navbar-light"><div class=container-fluid><input class="menu-btn order-0" type=checkbox id=menu-btn>
<label class="menu-icon d-md-none" for=menu-btn><span class=navicon></span></label><a class="navbar-brand order-1 order-md-0 me-auto" href=https://koktlzz.github.io/>KnowledgeBase</a>
<button id=mode class="btn btn-link order-2 order-md-4" type=button aria-label="Toggle mode">
<span class=toggle-dark><svg xmlns="http://www.w3.org/2000/svg" width="20" height="20" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="feather feather-moon"><path d="M21 12.79A9 9 0 1111.21 3 7 7 0 0021 12.79z"/></svg></span><span class=toggle-light><svg xmlns="http://www.w3.org/2000/svg" width="20" height="20" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="feather feather-sun"><circle cx="12" cy="12" r="5"/><line x1="12" y1="1" x2="12" y2="3"/><line x1="12" y1="21" x2="12" y2="23"/><line x1="4.22" y1="4.22" x2="5.64" y2="5.64"/><line x1="18.36" y1="18.36" x2="19.78" y2="19.78"/><line x1="1" y1="12" x2="3" y2="12"/><line x1="21" y1="12" x2="23" y2="12"/><line x1="4.22" y1="19.78" x2="5.64" y2="18.36"/><line x1="18.36" y1="5.64" x2="19.78" y2="4.22"/></svg></span></button><ul class="navbar-nav social-nav order-3 order-md-5"><li class=nav-item><a class=nav-link href=https://github.com/koktlzz><svg xmlns="http://www.w3.org/2000/svg" width="20" height="20" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="feather feather-github"><path d="M9 19c-5 1.5-5-2.5-7-3m14 6v-3.87a3.37 3.37.0 00-.94-2.61c3.14-.35 6.44-1.54 6.44-7A5.44 5.44.0 0020 4.77 5.07 5.07.0 0019.91 1S18.73.65 16 2.48a13.38 13.38.0 00-7 0C6.27.65 5.09 1 5.09 1A5.07 5.07.0 005 4.77 5.44 5.44.0 003.5 8.55c0 5.42 3.3 6.61 6.44 7A3.37 3.37.0 009 18.13V22"/></svg><span class="ms-2 visually-hidden">GitHub</span></a></li></ul><div class="collapse navbar-collapse order-4 order-md-1"><ul class="navbar-nav main-nav me-auto order-5 order-md-2"><li class=nav-item><a class=nav-link href=https://koktlzz.github.io/container/docker/intro>Container</a></li><li class=nav-item><a class=nav-link href=https://koktlzz.github.io/observability/elasticstack/intro>Observability</a></li><li class=nav-item><a class=nav-link href=https://koktlzz.github.io/programming/go/intro>Programming</a></li><li class=nav-item><a class=nav-link href=https://koktlzz.github.io/infrastructure/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/tcpip%E7%BD%91%E7%BB%9C%E6%A8%A1%E5%9E%8B>Infrastructure</a></li></ul><div class="break order-6 d-md-none"></div></div></div></header><div class="wrap container-fluid" role=document><div class=content><div class="row flex-xl-nowrap"><div class="col-lg-4 col-xl-3 d-none d-xl-block"><nav class=docs-links aria-label="Main navigation"><h3>Docker</h3><ul class=list-unstyled><li><a class=docs-link href=https://koktlzz.github.io/container/docker/intro/>Getting Started</a></li><li><a class=docs-link href=https://koktlzz.github.io/container/docker/%E7%8B%82%E7%A5%9Edocker%E8%AF%BE%E7%A8%8B%E7%AC%94%E8%AE%B0/>狂神 Docker 课程笔记</a></li><li><a class=docs-link href=https://koktlzz.github.io/container/docker/dockercompose/>Docker Compose</a></li><li><a class=docs-link href=https://koktlzz.github.io/container/docker/namespace%E9%9A%94%E7%A6%BB/>Namespace 隔离</a></li><li><a class=docs-link href=https://koktlzz.github.io/container/docker/cgroups%E9%9A%94%E7%A6%BB/>CGroups 隔离</a></li><li><a class=docs-link href=https://koktlzz.github.io/container/docker/%E9%95%9C%E5%83%8F%E4%B8%8E%E5%AE%B9%E5%99%A8/>镜像与容器</a></li></ul><h3>Kubernetes</h3><ul class=list-unstyled><li><a class=docs-link href=https://koktlzz.github.io/container/kubernetes/intro/>Getting Started</a></li><li><a class=docs-link href=https://koktlzz.github.io/container/kubernetes/infrastructure/>Infrastructure</a></li><li><a class=docs-link href=https://koktlzz.github.io/container/kubernetes/pod%E4%B8%8Enamespace/>Pod 与 Namespace</a></li><li><a class=docs-link href=https://koktlzz.github.io/container/kubernetes/service/>Service</a></li><li><a class=docs-link href=https://koktlzz.github.io/container/kubernetes/volume/>Volume</a></li><li><a class=docs-link href=https://koktlzz.github.io/container/kubernetes/workloads/>Workloads</a></li><li><a class=docs-link href=https://koktlzz.github.io/container/kubernetes/ingress/>Ingress</a></li><li><a class=docs-link href=https://koktlzz.github.io/container/kubernetes/networkpolicy/>Network Policy</a></li><li><a class=docs-link href=https://koktlzz.github.io/container/kubernetes/sdn/>SDN</a></li><li><a class=docs-link href=https://koktlzz.github.io/container/kubernetes/openvswitch/>Open vSwitch</a></li></ul></nav></div><main class="docs-content col-lg-12 col-xl-10"><h1>SDN</h1><p class=lead></p><h2 id=前言>前言<a href=#前言 class=anchor aria-hidden=true>#</a></h2><p><a href=https://sookocheff.com/post/kubernetes/understanding-kubernetes-networking-model/>A Guide to the Kubernetes Networking Model</a> 一文生动形象地介绍了 Kubernetes 中的网络模型，然而受篇幅所限，作者并没有对 Pod 跨节点通信时数据包在节点之间传递的细节进行过多讨论。</p><p>我们已经知道，Docker 使用端口映射的方式实现不同主机间容器的通信，Kubernetes 中同样也有 <a href=https://kubernetes.io/docs/reference/generated/kubernetes-api/v1.20/#pod-v1-core><code>hostPort</code></a> 的概念。但是当节点和 Pod 的数量上升后，手动管理节点上绑定的端口是十分困难的，这也是<code>NodePort</code>类型的 Service 的缺点之一。而一旦 Pod 不再“借用”节点的 IP 和端口来暴露自身的服务，就不得不面临一个棘手的问题：Pod 的本质是节点中的进程，节点外的物理网络设备（交换机/路由器）并不知晓 Pod 的存在。它们在接收目的地址为 Pod IP 的数据包时，无法完成进一步的传输工作。</p><p>为此我们需要使用一些 CNI（Container Network Interface）插件（如 Flannel、Calico 和 Open vSwitch 等）来优化 Kubernetes 集群的网络模型，这种新型的网络设计理念称为 SDN（Software-defined Networking）。根据 SDN 实现的层级，我们可以将其分为 Underlay Network 和 Overlay Network：</p><blockquote><p>Overlay 网络允许设备跨越底层物理网络（Underlay Network）进行通信，而底层却并不知晓 Overlay 网络的存在。Underlay 网络是专门用来承载用户 IP 流量的基础架构层，它与 Overlay 网络之间的关系有点类似物理机和虚拟机。Underlay 网络和物理机都是真正存在的实体，它们分别对应着真实存在的网络设备和计算设备，而 Overlay 网络和虚拟机都是依托在下层实体使用软件虚拟出来的层级。</p></blockquote><h2 id=underlay-network>Underlay Network<a href=#underlay-network class=anchor aria-hidden=true>#</a></h2><p>利用 Underlay Network 实现 Pod 跨节点通信，既可以只依赖 TCP/IP 模型中的二层协议，也可以使用三层。但无论哪种实现方式，都必须对底层的物理网络有所要求。</p><h3 id=二层>二层<a href=#二层 class=anchor aria-hidden=true>#</a></h3><p><img src=https://cdn.jsdelivr.net/gh/koktlzz/ImgBed@master/202105072039.jpeg alt=202105072039></p><p>如图所示，Pod 与节点的 IP 地址均处于同一网段。当 Pod1 向另一节点上的 Pod2 发起通信时，数据包首先通过<code>veth-pair</code>和<code>cbr0</code>送往 Node1 的网卡。由于目的地址 10.86.44.4 与 Node1 同网段，因此 Node1 将通过 ARP 广播请求 10.86.44.4 的 MAC 地址。</p><p>CNI 插件不仅为 Pod 分配 IP 地址，它还会将每个 Pod 所在的节点信息下发给 SDN 交换机。这样当 SDN 交换机接收到 ARP 请求时，将会答复 Pod2 所在节点 Node2 的 MAC 地址，数据包也就顺利地送到了 Node2 上。</p><h3 id=三层>三层<a href=#三层 class=anchor aria-hidden=true>#</a></h3><p><img src=https://cdn.jsdelivr.net/gh/koktlzz/ImgBed@master/202105080143.jpeg alt=202105080143></p><p>如图所示，Pod 与节点的 IP 地址不再处于同一网段。当 Pod1 向另一节点上的 Pod2 发起通信时，数据包首先通过<code>veth-pair</code>和<code>cbr0</code>进入宿主机内核的路由表（Routing Table）。CNI 插件在该表中添加了若干条路由规则，如目的地址为 Pod2 IP 的网关为 Node2 的 IP。这样数据包的目的 MAC 地址就变为了 Node2 的 MAC 地址，它将会通过交换机发送到 Node2 上。</p><p>由于这种实现方式基于三层协议，因此不要求 Node1 和 Node2 处于同一网段。如下图所示，此时需要将目的地址为 Pod2 IP 的网关设置为路由器的 IP。数据包的目的 MAC 地址首先变为路由器的 MAC 地址，然后经过路由器后再变为 Node2 的 MAC 地址。</p><p><img src=https://cdn.jsdelivr.net/gh/koktlzz/ImgBed@master/202205080146.jpeg alt=202205080146></p><p>通过上面的描述我们可以发现，想要实现三层的 Underlay 网络，需要在多个节点间下发和同步路由表。于是很容易想到用于交换路由信息的 BGP（Border Gateway Protocol）协议：</p><blockquote><p>边界网关协议（英语：Border Gateway Protocol，缩写：BGP）是互联网上一个核心的去中心化自治路由协议。它通过维护 IP 路由表或“前缀”表来实现自治系统（AS）之间的可达性，属于矢量路由协议。BGP 不使用传统的内部网关协议（IGP）的指标，而使用基于路径、网络策略或规则集来决定路由。因此，它更适合被称为矢量性协议，而不是路由协议。</p></blockquote><p>对于 Calico 的 BGP 模式来说，我们可以把集群网络模型视为在每个节点上都部署了一台虚拟路由器。路由器可以与其他节点上的路由器通过 BGP 协议互通，它们称为一对 BGP Peers。Calico 的默认部署方式为 Full-mesh，即创建一个完整的内部 BGP 连接网，每个节点上的路由器均互为 BGP Peers。这种方式仅适用于 100 个节点以内的中小型集群，在大型集群中使用的效率低下。而 Route reflectors 模式则将部分节点作为路由反射器，其他节点上的路由器只需与路由反射器互为 BGP Peers。这样便可以大大减少集群中 BGP Peers 的数量，从而提升效率。</p><h2 id=overlay-network>Overlay Network<a href=#overlay-network class=anchor aria-hidden=true>#</a></h2><p>Overlay 网络可以通过多种协议实现，但通常是对 IP 数据包进行一层外部封装（Encapsulation）。这样底层的 Underlay 网络便只会看到外部封装的数据，而无需处理内部的原有数据。Overlay 网络发送数据包的方式取决于其类型和使用的协议，如基于 VxLAN 实现 Overlay 网络，数据包将被外部封装后以 UDP 协议进行发送：</p><p><img src=https://cdn.jsdelivr.net/gh/koktlzz/NoteImg@main/20210508103310.png alt=20210508103310></p><p>Overlay 网络的实现并不依赖于底层物理网络设备，因此我们就以一个两节点不处于同一网段且 Pod 与节点亦处于不同网段的例子来说明 Overlay 网络中的数据包传递过程。集群网络使用 VxLAN 技术组建，虚拟网络设备 VTEP（Virtual Tunnel End Point）将会完成数据包的封装和解封操作。</p><p><img src=https://cdn.jsdelivr.net/gh/koktlzz/ImgBed@master/202105080221.jpeg alt=202105080221></p><p>Node1 上的 VTEP 收到 Pod1 发来的数据包后，首先会在本地的转发表中查找目的 Pod 所在节点的 IP，即 192.168.1.100。随后它将本机 IP 地址 10.86.44.2、Node2 的 IP 地址 192.168.1.100 和 Pod1 的 VNID（VxLAN Network Identifier）封装在原始数据包外，从 Node1 的网络接口 eth0 送出。由于新构建的数据包源/目的地址均为节点的 IP，因此外部的路由器可以将其转发到 Node2 上。Node2 中的 VTEP 在接收到数据包后会首先进行解封，若源 VNID（Pod1 的 VNID）与目的 VNID（Pod2 的 VNID）一致，便会根据原始数据包中的目的地址 172.100.1.2 将其发送到 Pod2 上。此处的 VNID 检查，主要是为了实现集群的网络策略管理和多租户隔离。</p><h2 id=总结>总结<a href=#总结 class=anchor aria-hidden=true>#</a></h2><p>通过对上述几种 SDN 网络模型的讨论，我们可以发现只有 Overlay 网络需要对数据包进行封装和解封，因此它的性能相比于 Underlay 网络较差。但 Overlay 网络也有以下优点：</p><ul><li>对底层网络设备的依赖性最小。即使 Pod 所在的节点发生迁移，依然可以通过 Overlay 网络与原集群实现二层网络的互通；</li><li>VNID 共有 24 位，因此可以构造出约 1600 万个互相隔离的虚拟网络。</li></ul><h2 id=参考文献>参考文献<a href=#参考文献 class=anchor aria-hidden=true>#</a></h2><p><a href=https://docs.projectcalico.org/about/about-kubernetes-networking>About Kubernetes Networking</a></p><p><a href=https://zh.wikipedia.org/wiki/%E8%BE%B9%E7%95%8C%E7%BD%91%E5%85%B3%E5%8D%8F%E8%AE%AE>边界网关协议</a></p><p><a href=https://docs.projectcalico.org/networking/bgp>Configure BGP peering</a></p><p><a href=https://draveness.me/whys-the-design-overlay-network/>为什么集群需要 Overlay 网络</a></p><p class=edit-page><a href=https://github.com/koktlzz/koktlzz.github.io/blob/master/content/Container/Kubernetes/SDN.md><svg xmlns="http://www.w3.org/2000/svg" width="16" height="16" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="feather feather-edit-2"><path d="M17 3a2.828 2.828.0 114 4L7.5 20.5 2 22l1.5-5.5L17 3z"/></svg>Edit this page on GitHub</a></p><div class="docs-navigation d-flex justify-content-between"><a href=https://koktlzz.github.io/container/kubernetes/networkpolicy/><div class="card my-1"><div class="card-body py-2">&larr; Network Policy</div></div></a><a class=ms-auto href=https://koktlzz.github.io/container/kubernetes/openvswitch/><div class="card my-1"><div class="card-body py-2">Open vSwitch &rarr;</div></div></a></div><script src=https://utteranc.es/client.js repo=koktlzz/koktlzz.github.io issue-term=pathname theme=photon-dark crossorigin=anonymous async></script></main><nav class="docs-toc d-none d-xl-block col-lg-3 col-xl-2" aria-label="Secondary navigation"><div class=page-links><h3>On this page</h3><nav id=TableOfContents><ul><li><a href=#前言>前言</a></li><li><a href=#underlay-network>Underlay Network</a><ul><li><a href=#二层>二层</a></li><li><a href=#三层>三层</a></li></ul></li><li><a href=#overlay-network>Overlay Network</a></li><li><a href=#总结>总结</a></li><li><a href=#参考文献>参考文献</a></li></ul></nav></div></nav></div></div></div><script src=https://koktlzz.github.io/js/bootstrap.min.d67050adf5d370668aede4201f82af781b16970934804995a1ca37c1ee9222c2fc530972aa6d5d2b6124caf1fe318f139aac99df2c1e89af65504fc1185c7972.js integrity="sha512-1nBQrfXTcGaK7eQgH4KveBsWlwk0gEmVoco3we6SIsL8Uwlyqm1dK2EkyvH+MY8TmqyZ3yweia9lUE/BGFx5cg==" crossorigin=anonymous defer></script><script src=https://koktlzz.github.io/js/vendor/katex/dist/katex.min.b334e5b00c45f572e7f38a543046f36854bf4cbb543880480c09271a0efedc694d6905f719934f6ede2f26f52e80411c05b90121d722cbf8be2fa8fc51bc6b81.js integrity="sha512-szTlsAxF9XLn84pUMEbzaFS/TLtUOIBIDAknGg7+3GlNaQX3GZNPbt4vJvUugEEcBbkBIdciy/i+L6j8UbxrgQ==" crossorigin=anonymous defer></script><script src=https://koktlzz.github.io/js/vendor/katex/dist/contrib/auto-render.min.916823ec103cf367b71e28a6f01513cb9c3ac6708ccb5229402ec46b8e30a8b25003db694df35d80e9dd666a371f327c6152790617b6256390c164109a90bd4c.js integrity="sha512-kWgj7BA882e3Hiim8BUTy5w6xnCMy1IpQC7Ea44wqLJQA9tpTfNdgOndZmo3HzJ8YVJ5Bhe2JWOQwWQQmpC9TA==" crossorigin=anonymous defer></script><script src=https://koktlzz.github.io/main.min.1febbf2f6fd6a36fc2f57dd50d7935fbb640743329baeb4ef7cefcf2e7630e413371fbba976e103656b82808ee227dc4a84237edb0f8433648bef3a56900661a.js integrity="sha512-H+u/L2/Wo2/C9X3VDXk1+7ZAdDMpuutO98788udjDkEzcfu6l24QNla4KAjuIn3EqEI37bD4QzZIvvOlaQBmGg==" crossorigin=anonymous defer></script></body></html>