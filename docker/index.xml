<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>Dockers on</title><link>https://koktlzz.github.io/docker/</link><description>Recent content in Dockers on</description><generator>Hugo -- gohugo.io</generator><language>en-US</language><lastBuildDate>Wed, 24 Feb 2021 22:05:45 +0800</lastBuildDate><atom:link href="https://koktlzz.github.io/docker/index.xml" rel="self" type="application/rss+xml"/><item><title>Get Started</title><link>https://koktlzz.github.io/docker/docker%E5%9F%BA%E7%A1%80/intro/</link><pubDate>Wed, 24 Feb 2021 22:05:45 +0800</pubDate><guid>https://koktlzz.github.io/docker/docker%E5%9F%BA%E7%A1%80/intro/</guid><description>官方网站 https://www.docker.com/
推荐阅读 Docker——容器与容器云（第 2 版）
Docker 核心技术与实现原理</description></item><item><title>狂神 Docker 课程笔记</title><link>https://koktlzz.github.io/docker/docker%E5%9F%BA%E7%A1%80/%E7%8B%82%E7%A5%9Edocker%E8%AF%BE%E7%A8%8B%E7%AC%94%E8%AE%B0/</link><pubDate>Wed, 24 Feb 2021 22:05:45 +0800</pubDate><guid>https://koktlzz.github.io/docker/docker%E5%9F%BA%E7%A1%80/%E7%8B%82%E7%A5%9Edocker%E8%AF%BE%E7%A8%8B%E7%AC%94%E8%AE%B0/</guid><description>课程链接 https://www.bilibili.com/video/BV1og4y1q7M4?from=search&amp;amp;seid=18106350651153543104
Docker 为什么出现？ 开发和运维两套环境，而环境配置十分麻烦。 如在 Windows 上开发，要发布到 Linux 上运行。Docker 给以上问题提出了解决方案： Java &amp;mdash; Jar（环境）&amp;mdash;打包项目带上环境（镜像）&amp;mdash;Docker 仓库（应用商店）&amp;mdash;下载镜像&amp;mdash;直接运行 Docker 的思想来自于集装箱，核心思想：隔离。 即将应用打包装箱，每个箱子是互相隔离的，可以将服务器利用到极致。 官方文档 仓库地址 Docker 能做什么？ 传统虚拟机与 Docker 对比 Docker 的优点 不模拟完整的操作系统，系统内核（kernel）非常小，更少的抽象层（GuestOS：如 Centos） 容器内的应用直接运行在宿主机的内核，容器本身没有自己的内核，也没有虚拟硬件。 每个容器相互隔离，内部都有属于自己的文件系统，互不影响。 Docker 实现 DevOps 应用更快速的交付和部署 打包镜像发布测试，一键运行；不再需要写大量帮助文档，安装程序 更便捷的升级和扩缩容？ 部署应用就和搭积木一样 更简单的系统运维 开发和测试的环境高度一致 更高效的计算资源利用 内核级别的虚拟化，可以在一个物理机上运行很多的容器实例，服务器性能可以被压榨到极致。 Docker 的基本组成 镜像（image）：镜像是一种轻量级、可执行的独立软件包，用来打包软件运行环境和基于运行环境开发的软件。它包含运行某个软件所需的所有内容，包括代码、运行时、库、环境变量和配置文件。相当于一个模板，通过这个模板来创建容器服务，可以通过一个镜像创建多个容器。 容器（container）：独立运行一个或一组应用/基本命令有：启动，停止，删除等。可理解为一个简单的 linux 系统。 仓库（repository）：存放镜像的地方（公有/私有） Docker 运行原理 Docker 是一个 Client-Server 结构的系统，以守护进程运行在主机上。通过 Socket 从客户端进行访问。
Docker 的常用命令 帮助命令 docker --help # 帮助信息 docker info # 系统信息，包括镜像和容器的数量 帮助文档地址：https://docs.</description></item><item><title>Docker Compose</title><link>https://koktlzz.github.io/docker/docker%E5%9F%BA%E7%A1%80/dockercompose/</link><pubDate>Wed, 24 Feb 2021 22:05:45 +0800</pubDate><guid>https://koktlzz.github.io/docker/docker%E5%9F%BA%E7%A1%80/dockercompose/</guid><description>简介 学习了 Docker 基础知识 后，我们已经可以使用 Dockerfile 和 docker build 命令创建一个镜像，并使用 docker run 命令运行一个容器。但如果想要同时运行多个容器，并建立容器之间的依赖关系，仅仅依靠上述的命令就显得十分复杂。因此，我们需要一个新的工具能够高效地对多个容器进行运行管理（批量容器编排），这便是 Docker Compose。
官方文档：
Compose is a tool for defining and running multi-container Docker applications. With Compose, you use a YAML file to configure your application’s services. Then, with a single command, you create and start all the services from your configuration. To learn more about all the features of Compose, see the list of features. Compose works in all environments: production, staging, development, testing, as well as CI workflows.</description></item><item><title>Namespace 隔离</title><link>https://koktlzz.github.io/docker/docker%E6%A0%B8%E5%BF%83%E5%8E%9F%E7%90%86/namespace%E9%9A%94%E7%A6%BB/</link><pubDate>Wed, 24 Feb 2021 22:05:45 +0800</pubDate><guid>https://koktlzz.github.io/docker/docker%E6%A0%B8%E5%BF%83%E5%8E%9F%E7%90%86/namespace%E9%9A%94%E7%A6%BB/</guid><description>简介 在 Linux 中可以使用 lsns 命令查看系统中的所有 namespace：
[root@koktlzz ~]# lsns NS TYPE NPROCS PID USER COMMAND 4026531835 cgroup 94 1 root /usr/lib/systemd/systemd --switched-root --system --deserialize 17 4026531836 pid 94 1 root /usr/lib/systemd/systemd --switched-root --system --deserialize 17 4026531837 user 94 1 root /usr/lib/systemd/systemd --switched-root --system --deserialize 17 4026531838 uts 94 1 root /usr/lib/systemd/systemd --switched-root --system --deserialize 17 4026531839 ipc 94 1 root /usr/lib/systemd/systemd --switched-root --system --deserialize 17 4026531840 mnt 88 1 root /usr/lib/systemd/systemd --switched-root --system --deserialize 17 4026531860 mnt 1 16 root kdevtmpfs 4026531992 net 94 1 root /usr/lib/systemd/systemd --switched-root --system --deserialize 17 4026532193 mnt 1 599 root /usr/lib/systemd/systemd-udevd 4026532195 mnt 2 693 root /sbin/auditd 4026532196 mnt 1 782 chrony /usr/sbin/chronyd 4026532197 mnt 1 893 root /usr/sbin/NetworkManager --no-daemon Namespace 系统调用参数 隔离内容 应用意义 UTS CLONE_NEWUTS 主机与域名 每个容器在网络中可以被视作一个独立的节点，而非宿主机的一个进程 IPC CLONE_NEWIPC 信号量、消息队列和共享内存 隔离容器间、容器与宿主机之间的进程间通信 PID CLONE_NEWPID 进程编号 隔离容器间、容器与宿主机之间的进程 PID Network CLONE_NEWNET 网络设备、网络栈、端口等 避免产生容器间、容器与宿主机之间产生端口已占用的问题 Mount CLONE_NEWNS 挂载点（文件系统） 容器间、容器与宿主机之间的文件系统互不影响 User CLONE_NEWUSER 用户和用户组 普通用户（组）在容器内部也可以成为超级用户（组），从而进行权限管理 进行 Namespace API 操作的方式 clone() clone() 可以在创建新进程（子进程）的同时创建 namespace，是 Docker 使用 namespace 最基本的方法。</description></item><item><title>cgroups 隔离</title><link>https://koktlzz.github.io/docker/docker%E6%A0%B8%E5%BF%83%E5%8E%9F%E7%90%86/cgroups%E9%9A%94%E7%A6%BB/</link><pubDate>Wed, 24 Feb 2021 22:05:45 +0800</pubDate><guid>https://koktlzz.github.io/docker/docker%E6%A0%B8%E5%BF%83%E5%8E%9F%E7%90%86/cgroups%E9%9A%94%E7%A6%BB/</guid><description>作用 cgroups(controll groups) 可以把一系列系统任务及其子任务（线程/进程）划分为等级不同的组，从而对任务组使用的物理资源（CPU、内存、IO 等）进行限制和记录。
资源限制：对任务使用的资源总额进行限制，一旦超过这个配额就发出相关提示； 优先级分配：通过分配的 CPU 时间片数量及磁盘 IO 带宽大小，实际上就相当于控制了任务运行的优先级； 资源统计：cgroups 可以统计系统的资源使用量，如 CPU 使用时长，内存用量等； 任务控制：cgroups 可以对任务执行挂起、恢复等操作。 组织结构 cgroups 的组织结构中有以下几种元素：
任务（task）：系统的一个进程或线程；
控制组（cgroup）：按某种资源控制标准划分而成的任务组，一个任务可以加入某个 cgroup，也可以在不同 cgroup 中迁移；
子系统（subsystem）：即资源调度器，如 CPU 子系统可以控制 CPU 时间分配；
层级（hierarchy）：由一系列控制组以一个树状结构排列而成，每个层级通过绑定对应的子系统进行资源控制。
它们之间的关系需要遵循一定的规则：
同一个层级可以绑定多个子系统； 一个已经有层级绑定的子系统，不能附加到其他含有别的子系统的层级之上； 一个任务不能存在于同一层级的不同控制组中； 调用 fork() 或 clone() 方法后，父子任务（进程）的控制组互不影响。 在上图的 cgroups 结构中，左侧的层级同时绑定了 CPU 子系统和 Memory 子系统；由于此时 Memory 子系统已经有层级绑定，因此无法附加到一个已经绑定了 Net_ls 子系统的层级上；如果任务 task1 处于左侧层级下的 cg1 控制组中，那么便无法加入同一层级下的 cg2 控制组，但是可以加入右侧层级的 cg3 控制中。</description></item><item><title>镜像与容器</title><link>https://koktlzz.github.io/docker/docker%E6%A0%B8%E5%BF%83%E5%8E%9F%E7%90%86/%E9%95%9C%E5%83%8F%E4%B8%8E%E5%AE%B9%E5%99%A8/</link><pubDate>Wed, 24 Feb 2021 22:05:45 +0800</pubDate><guid>https://koktlzz.github.io/docker/docker%E6%A0%B8%E5%BF%83%E5%8E%9F%E7%90%86/%E9%95%9C%E5%83%8F%E4%B8%8E%E5%AE%B9%E5%99%A8/</guid><description>镜像 Docker 镜像是一个只读的容器模板，含有启动 Docker 容器所需的文件系统。Docker 镜像的文件内容和一些运行容器的配置文件组成了 Docker 容器的文件系统运行环境——rootfs。
当我们使用 docker pull 下载一个 nginx 镜像后，可以在 Docker 的工作目录 /var/lib/docker/image/overlay2 下找到它的相关信息（路径中的 overlay2 是 Docker 目前使用的一种存储驱动，我们后面会详细讲解这项技术）：
[root@localhost ~]# docker images REPOSITORY TAG IMAGE ID CREATED SIZE nginx latest f6d0b4767a6c 3 weeks ago 133MB [root@localhost ~]# ls /var/lib/docker/image/overlay2 distribution imagedb layerdb repositories.json Repository 在 Docker 的镜像管理系统中，registry 代表镜像仓库，如官方的 Docker Hub。而 repository 则代表镜像组，即包含了不同版本的镜像集合。repositories.json 文件中描述了宿主机上所有镜像的 repository 元数据，主要包括镜像名、tag 和镜像 ID。而镜像 ID 是 Docker 采用 SHA256 算法，根据镜像元数据配置文件计算得出的。
[root@localhost ~]# cat /var/lib/docker/image/overlay2/repositories.</description></item></channel></rss>